{
  "version": 3,
  "sources": ["../node_modules/isexe/windows.js", "../node_modules/isexe/mode.js", "../node_modules/isexe/index.js", "../node_modules/which/which.js", "../node_modules/path-key/index.js", "../node_modules/cross-spawn/lib/util/resolveCommand.js", "../node_modules/cross-spawn/lib/util/escape.js", "../node_modules/shebang-regex/index.js", "../node_modules/shebang-command/index.js", "../node_modules/cross-spawn/lib/util/readShebang.js", "../node_modules/cross-spawn/lib/parse.js", "../node_modules/cross-spawn/lib/enoent.js", "../node_modules/cross-spawn/index.js", "../node_modules/signal-exit/signals.js", "../node_modules/signal-exit/index.js", "../node_modules/get-stream/buffer-stream.js", "../node_modules/get-stream/index.js", "../node_modules/merge-stream/index.js", "../node_modules/node-stream-zip/node_stream_zip.js", "../src/create-folder.tsx", "../src/context/bitwarden.tsx", "../src/api/bitwarden.ts", "../node_modules/execa/index.js", "../node_modules/strip-final-newline/index.js", "../node_modules/npm-run-path/index.js", "../node_modules/npm-run-path/node_modules/path-key/index.js", "../node_modules/mimic-fn/index.js", "../node_modules/onetime/index.js", "../node_modules/human-signals/build/src/main.js", "../node_modules/human-signals/build/src/realtime.js", "../node_modules/human-signals/build/src/signals.js", "../node_modules/human-signals/build/src/core.js", "../node_modules/execa/lib/error.js", "../node_modules/execa/lib/stdio.js", "../node_modules/execa/lib/kill.js", "../node_modules/is-stream/index.js", "../node_modules/execa/lib/stream.js", "../node_modules/execa/lib/promise.js", "../node_modules/execa/lib/command.js", "../src/constants/general.ts", "../src/utils/passwords.ts", "../src/constants/passwords.ts", "../src/utils/preferences.ts", "../src/constants/preferences.ts", "../src/constants/labels.ts", "../src/utils/errors.ts", "../src/utils/fs.ts", "../src/utils/network.ts", "../src/utils/development.ts", "../src/utils/crypto.ts", "../src/api/bitwarden.helpers.ts", "../src/utils/cache.ts", "../src/utils/platform.ts", "../src/components/LoadingFallback.tsx", "../src/components/TroubleshootingGuide.tsx", "../src/components/actions/ActionWithReprompt.tsx", "../src/components/searchVault/context/vaultItem.tsx", "../src/utils/hooks/useReprompt.tsx", "../src/components/RepromptForm.tsx", "../src/context/session/session.tsx", "../src/components/UnlockForm.tsx", "../src/utils/objects.ts", "../src/utils/debug.ts", "../src/utils/hooks/useVaultMessages.ts", "../src/utils/localstorage.ts", "../node_modules/dequal/lite/index.mjs", "../node_modules/@raycast/utils/dist/src/index.ts", "../node_modules/@raycast/utils/dist/src/usePromise.ts", "../node_modules/@raycast/utils/dist/src/useDeepMemo.ts", "../node_modules/@raycast/utils/dist/src/useLatest.ts", "../node_modules/@raycast/utils/dist/src/showFailureToast.ts", "../node_modules/@raycast/utils/dist/src/useCachedState.ts", "../node_modules/@raycast/utils/dist/src/helpers.ts", "../node_modules/@raycast/utils/dist/src/vendors/type-hasher.ts", "../node_modules/@raycast/utils/dist/src/useCachedPromise.ts", "../node_modules/@raycast/utils/dist/src/useFetch.ts", "../node_modules/@raycast/utils/dist/src/fetch-utils.ts", "../node_modules/@raycast/utils/dist/src/useExec.ts", "../node_modules/@raycast/utils/dist/src/exec-utils.ts", "../node_modules/@raycast/utils/dist/src/vendors/signal-exit.ts", "../node_modules/@raycast/utils/dist/src/useStreamJSON.ts", "../node_modules/@raycast/utils/dist/src/vendors/stream-chain.ts", "../node_modules/@raycast/utils/dist/src/vendors/stream-json.ts", "../node_modules/@raycast/utils/dist/src/useSQL.tsx", "../node_modules/@raycast/utils/dist/src/sql-utils.ts", "../node_modules/@raycast/utils/dist/src/useForm.tsx", "../node_modules/@raycast/utils/dist/src/useAI.ts", "../node_modules/@raycast/utils/dist/src/useFrecencySorting.ts", "../node_modules/@raycast/utils/dist/src/useLocalStorage.ts", "../node_modules/@raycast/utils/dist/src/icon/index.ts", "../node_modules/@raycast/utils/dist/src/icon/avatar.ts", "../node_modules/@raycast/utils/dist/src/icon/color.ts", "../node_modules/@raycast/utils/dist/src/icon/favicon.ts", "../node_modules/@raycast/utils/dist/src/icon/progress.ts", "../node_modules/@raycast/utils/dist/src/oauth/index.ts", "../node_modules/@raycast/utils/dist/src/oauth/OAuthService.ts", "../node_modules/@raycast/utils/dist/src/oauth/providers.ts", "../node_modules/@raycast/utils/dist/src/oauth/withAccessToken.tsx", "../node_modules/@raycast/utils/dist/src/createDeeplink.ts", "../node_modules/@raycast/utils/dist/src/executeSQL.ts", "../node_modules/@raycast/utils/dist/src/run-applescript.ts", "../node_modules/@raycast/utils/dist/src/run-powershell-script.ts", "../node_modules/@raycast/utils/dist/src/cache.ts", "../src/components/searchVault/VaultLoadingFallback.tsx", "../src/context/session/reducer.ts", "../src/context/session/utils.ts", "../src/utils/hooks/useOnceEffect.ts", "../src/components/actions/BugReportCollectDataAction.tsx", "../src/components/actions/BugReportOpenAction.tsx", "../src/components/actions/CopyRuntimeErrorLog.tsx", "../src/components/actions/DebuggingBugReportingActionSection.tsx", "../src/utils/hooks/useCliVersion.ts", "../src/components/actions/VaultActionsSection.tsx", "../src/context/vault.tsx", "../src/components/searchVault/context/vaultListeners.tsx", "../src/components/searchVault/utils/useVaultCaching.ts", "../src/utils/hooks/useContentEncryptor.ts", "../src/components/RootErrorBoundary.tsx"],
  "sourcesContent": ["module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n", "module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n", "var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n", "const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n", "'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n", "'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n", "'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n    // It's slightly altered to disable JS backtracking to avoid hanging on specially crafted input\n    // Please see https://github.com/moxystudio/node-cross-spawn/pull/160 for more information\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(?=(\\\\+?)?)\\1\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(?=(\\\\+?)?)\\1$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n", "'use strict';\nmodule.exports = /^#!(.*)/;\n", "'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n", "'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n", "'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n", "'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed);\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n", "'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n", "// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n", "// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n}\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {}\n  }\n} else {\n  var assert = require('assert')\n  var signals = require('./signals.js')\n  var isWin = /^win/i.test(process.platform)\n\n  var EE = require('events')\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter\n  }\n\n  var emitter\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE()\n    emitter.count = 0\n    emitter.emitted = {}\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity)\n    emitter.infinite = true\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {}\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n    if (loaded === false) {\n      load()\n    }\n\n    var ev = 'exit'\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit'\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb)\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload()\n      }\n    }\n    emitter.on(ev, cb)\n\n    return remove\n  }\n\n  var unload = function unload () {\n    if (!loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = false\n\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    })\n    process.emit = originalProcessEmit\n    process.reallyExit = originalProcessReallyExit\n    emitter.count -= 1\n  }\n  module.exports.unload = unload\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true\n    emitter.emit(event, code, signal)\n  }\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {}\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig)\n      if (listeners.length === emitter.count) {\n        unload()\n        emit('exit', null, sig)\n        /* istanbul ignore next */\n        emit('afterexit', null, sig)\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT'\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig)\n      }\n    }\n  })\n\n  module.exports.signals = function () {\n    return signals\n  }\n\n  var loaded = false\n\n  var load = function load () {\n    if (loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1\n\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig])\n        return true\n      } catch (er) {\n        return false\n      }\n    })\n\n    process.emit = processEmit\n    process.reallyExit = processReallyExit\n  }\n  module.exports.load = load\n\n  var originalProcessReallyExit = process.reallyExit\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    process.exitCode = code || /* istanbul ignore next */ 0\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode)\n  }\n\n  var originalProcessEmit = process.emit\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg\n      }\n      var ret = originalProcessEmit.apply(this, arguments)\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null)\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null)\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  }\n}\n", "'use strict';\nconst {PassThrough: PassThroughStream} = require('stream');\n\nmodule.exports = options => {\n\toptions = {...options};\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst isBuffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || isBuffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tstream.on('data', chunk => {\n\t\tchunks.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlength = chunks.length;\n\t\t} else {\n\t\t\tlength += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn chunks;\n\t\t}\n\n\t\treturn isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\t};\n\n\tstream.getBufferedLength = () => length;\n\n\treturn stream;\n};\n", "'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst stream = require('stream');\nconst {promisify} = require('util');\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\tconst stream = bufferStream(options);\n\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tawait streamPipelinePromisified(inputStream, stream);\n\t\t\t\tresolve();\n\t\t\t} catch (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t}\n\t\t})();\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n", "'use strict';\n\nconst { PassThrough } = require('stream');\n\nmodule.exports = function (/*streams...*/) {\n  var sources = []\n  var output  = new PassThrough({objectMode: true})\n\n  output.setMaxListeners(0)\n\n  output.add = add\n  output.isEmpty = isEmpty\n\n  output.on('unpipe', remove)\n\n  Array.prototype.slice.call(arguments).forEach(add)\n\n  return output\n\n  function add (source) {\n    if (Array.isArray(source)) {\n      source.forEach(add)\n      return this\n    }\n\n    sources.push(source);\n    source.once('end', remove.bind(null, source))\n    source.once('error', output.emit.bind(output, 'error'))\n    source.pipe(output, {end: false})\n    return this\n  }\n\n  function isEmpty () {\n    return sources.length == 0;\n  }\n\n  function remove (source) {\n    sources = sources.filter(function (it) { return it !== source })\n    if (!sources.length && output.readable) { output.end() }\n  }\n}\n", "/**\n * @license node-stream-zip | (c) 2020 Antelle | https://github.com/antelle/node-stream-zip/blob/master/LICENSE\n * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/LICENSE\n */\n\nlet fs = require('fs');\nconst util = require('util');\nconst path = require('path');\nconst events = require('events');\nconst zlib = require('zlib');\nconst stream = require('stream');\n\nconst consts = {\n    /* The local file header */\n    LOCHDR: 30, // LOC header size\n    LOCSIG: 0x04034b50, // \"PK\\003\\004\"\n    LOCVER: 4, // version needed to extract\n    LOCFLG: 6, // general purpose bit flag\n    LOCHOW: 8, // compression method\n    LOCTIM: 10, // modification time (2 bytes time, 2 bytes date)\n    LOCCRC: 14, // uncompressed file crc-32 value\n    LOCSIZ: 18, // compressed size\n    LOCLEN: 22, // uncompressed size\n    LOCNAM: 26, // filename length\n    LOCEXT: 28, // extra field length\n\n    /* The Data descriptor */\n    EXTSIG: 0x08074b50, // \"PK\\007\\008\"\n    EXTHDR: 16, // EXT header size\n    EXTCRC: 4, // uncompressed file crc-32 value\n    EXTSIZ: 8, // compressed size\n    EXTLEN: 12, // uncompressed size\n\n    /* The central directory file header */\n    CENHDR: 46, // CEN header size\n    CENSIG: 0x02014b50, // \"PK\\001\\002\"\n    CENVEM: 4, // version made by\n    CENVER: 6, // version needed to extract\n    CENFLG: 8, // encrypt, decrypt flags\n    CENHOW: 10, // compression method\n    CENTIM: 12, // modification time (2 bytes time, 2 bytes date)\n    CENCRC: 16, // uncompressed file crc-32 value\n    CENSIZ: 20, // compressed size\n    CENLEN: 24, // uncompressed size\n    CENNAM: 28, // filename length\n    CENEXT: 30, // extra field length\n    CENCOM: 32, // file comment length\n    CENDSK: 34, // volume number start\n    CENATT: 36, // internal file attributes\n    CENATX: 38, // external file attributes (host system dependent)\n    CENOFF: 42, // LOC header offset\n\n    /* The entries in the end of central directory */\n    ENDHDR: 22, // END header size\n    ENDSIG: 0x06054b50, // \"PK\\005\\006\"\n    ENDSIGFIRST: 0x50,\n    ENDSUB: 8, // number of entries on this disk\n    ENDTOT: 10, // total number of entries\n    ENDSIZ: 12, // central directory size in bytes\n    ENDOFF: 16, // offset of first CEN header\n    ENDCOM: 20, // zip file comment length\n    MAXFILECOMMENT: 0xffff,\n\n    /* The entries in the end of ZIP64 central directory locator */\n    ENDL64HDR: 20, // ZIP64 end of central directory locator header size\n    ENDL64SIG: 0x07064b50, // ZIP64 end of central directory locator signature\n    ENDL64SIGFIRST: 0x50,\n    ENDL64OFS: 8, // ZIP64 end of central directory offset\n\n    /* The entries in the end of ZIP64 central directory */\n    END64HDR: 56, // ZIP64 end of central directory header size\n    END64SIG: 0x06064b50, // ZIP64 end of central directory signature\n    END64SIGFIRST: 0x50,\n    END64SUB: 24, // number of entries on this disk\n    END64TOT: 32, // total number of entries\n    END64SIZ: 40,\n    END64OFF: 48,\n\n    /* Compression methods */\n    STORED: 0, // no compression\n    SHRUNK: 1, // shrunk\n    REDUCED1: 2, // reduced with compression factor 1\n    REDUCED2: 3, // reduced with compression factor 2\n    REDUCED3: 4, // reduced with compression factor 3\n    REDUCED4: 5, // reduced with compression factor 4\n    IMPLODED: 6, // imploded\n    // 7 reserved\n    DEFLATED: 8, // deflated\n    ENHANCED_DEFLATED: 9, // deflate64\n    PKWARE: 10, // PKWare DCL imploded\n    // 11 reserved\n    BZIP2: 12, //  compressed using BZIP2\n    // 13 reserved\n    LZMA: 14, // LZMA\n    // 15-17 reserved\n    IBM_TERSE: 18, // compressed using IBM TERSE\n    IBM_LZ77: 19, //IBM LZ77 z\n\n    /* General purpose bit flag */\n    FLG_ENC: 0, // encrypted file\n    FLG_COMP1: 1, // compression option\n    FLG_COMP2: 2, // compression option\n    FLG_DESC: 4, // data descriptor\n    FLG_ENH: 8, // enhanced deflation\n    FLG_STR: 16, // strong encryption\n    FLG_LNG: 1024, // language encoding\n    FLG_MSK: 4096, // mask header values\n    FLG_ENTRY_ENC: 1,\n\n    /* 4.5 Extensible data fields */\n    EF_ID: 0,\n    EF_SIZE: 2,\n\n    /* Header IDs */\n    ID_ZIP64: 0x0001,\n    ID_AVINFO: 0x0007,\n    ID_PFS: 0x0008,\n    ID_OS2: 0x0009,\n    ID_NTFS: 0x000a,\n    ID_OPENVMS: 0x000c,\n    ID_UNIX: 0x000d,\n    ID_FORK: 0x000e,\n    ID_PATCH: 0x000f,\n    ID_X509_PKCS7: 0x0014,\n    ID_X509_CERTID_F: 0x0015,\n    ID_X509_CERTID_C: 0x0016,\n    ID_STRONGENC: 0x0017,\n    ID_RECORD_MGT: 0x0018,\n    ID_X509_PKCS7_RL: 0x0019,\n    ID_IBM1: 0x0065,\n    ID_IBM2: 0x0066,\n    ID_POSZIP: 0x4690,\n\n    EF_ZIP64_OR_32: 0xffffffff,\n    EF_ZIP64_OR_16: 0xffff,\n};\n\nconst StreamZip = function (config) {\n    let fd, fileSize, chunkSize, op, centralDirectory, closed;\n    const ready = false,\n        that = this,\n        entries = config.storeEntries !== false ? {} : null,\n        fileName = config.file,\n        textDecoder = config.nameEncoding ? new TextDecoder(config.nameEncoding) : null;\n\n    open();\n\n    function open() {\n        if (config.fd) {\n            fd = config.fd;\n            readFile();\n        } else {\n            fs.open(fileName, 'r', (err, f) => {\n                if (err) {\n                    return that.emit('error', err);\n                }\n                fd = f;\n                readFile();\n            });\n        }\n    }\n\n    function readFile() {\n        fs.fstat(fd, (err, stat) => {\n            if (err) {\n                return that.emit('error', err);\n            }\n            fileSize = stat.size;\n            chunkSize = config.chunkSize || Math.round(fileSize / 1000);\n            chunkSize = Math.max(\n                Math.min(chunkSize, Math.min(128 * 1024, fileSize)),\n                Math.min(1024, fileSize)\n            );\n            readCentralDirectory();\n        });\n    }\n\n    function readUntilFoundCallback(err, bytesRead) {\n        if (err || !bytesRead) {\n            return that.emit('error', err || new Error('Archive read error'));\n        }\n        let pos = op.lastPos;\n        let bufferPosition = pos - op.win.position;\n        const buffer = op.win.buffer;\n        const minPos = op.minPos;\n        while (--pos >= minPos && --bufferPosition >= 0) {\n            if (buffer.length - bufferPosition >= 4 && buffer[bufferPosition] === op.firstByte) {\n                // quick check first signature byte\n                if (buffer.readUInt32LE(bufferPosition) === op.sig) {\n                    op.lastBufferPosition = bufferPosition;\n                    op.lastBytesRead = bytesRead;\n                    op.complete();\n                    return;\n                }\n            }\n        }\n        if (pos === minPos) {\n            return that.emit('error', new Error('Bad archive'));\n        }\n        op.lastPos = pos + 1;\n        op.chunkSize *= 2;\n        if (pos <= minPos) {\n            return that.emit('error', new Error('Bad archive'));\n        }\n        const expandLength = Math.min(op.chunkSize, pos - minPos);\n        op.win.expandLeft(expandLength, readUntilFoundCallback);\n    }\n\n    function readCentralDirectory() {\n        const totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);\n        op = {\n            win: new FileWindowBuffer(fd),\n            totalReadLength,\n            minPos: fileSize - totalReadLength,\n            lastPos: fileSize,\n            chunkSize: Math.min(1024, chunkSize),\n            firstByte: consts.ENDSIGFIRST,\n            sig: consts.ENDSIG,\n            complete: readCentralDirectoryComplete,\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readCentralDirectoryComplete() {\n        const buffer = op.win.buffer;\n        const pos = op.lastBufferPosition;\n        try {\n            centralDirectory = new CentralDirectoryHeader();\n            centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));\n            centralDirectory.headerOffset = op.win.position + pos;\n            if (centralDirectory.commentLength) {\n                that.comment = buffer\n                    .slice(\n                        pos + consts.ENDHDR,\n                        pos + consts.ENDHDR + centralDirectory.commentLength\n                    )\n                    .toString();\n            } else {\n                that.comment = null;\n            }\n            that.entriesCount = centralDirectory.volumeEntries;\n            that.centralDirectory = centralDirectory;\n            if (\n                (centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 &&\n                    centralDirectory.totalEntries === consts.EF_ZIP64_OR_16) ||\n                centralDirectory.size === consts.EF_ZIP64_OR_32 ||\n                centralDirectory.offset === consts.EF_ZIP64_OR_32\n            ) {\n                readZip64CentralDirectoryLocator();\n            } else {\n                op = {};\n                readEntries();\n            }\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function readZip64CentralDirectoryLocator() {\n        const length = consts.ENDL64HDR;\n        if (op.lastBufferPosition > length) {\n            op.lastBufferPosition -= length;\n            readZip64CentralDirectoryLocatorComplete();\n        } else {\n            op = {\n                win: op.win,\n                totalReadLength: length,\n                minPos: op.win.position - length,\n                lastPos: op.win.position,\n                chunkSize: op.chunkSize,\n                firstByte: consts.ENDL64SIGFIRST,\n                sig: consts.ENDL64SIG,\n                complete: readZip64CentralDirectoryLocatorComplete,\n            };\n            op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n        }\n    }\n\n    function readZip64CentralDirectoryLocatorComplete() {\n        const buffer = op.win.buffer;\n        const locHeader = new CentralDirectoryLoc64Header();\n        locHeader.read(\n            buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR)\n        );\n        const readLength = fileSize - locHeader.headerOffset;\n        op = {\n            win: op.win,\n            totalReadLength: readLength,\n            minPos: locHeader.headerOffset,\n            lastPos: op.lastPos,\n            chunkSize: op.chunkSize,\n            firstByte: consts.END64SIGFIRST,\n            sig: consts.END64SIG,\n            complete: readZip64CentralDirectoryComplete,\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readZip64CentralDirectoryComplete() {\n        const buffer = op.win.buffer;\n        const zip64cd = new CentralDirectoryZip64Header();\n        zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));\n        that.centralDirectory.volumeEntries = zip64cd.volumeEntries;\n        that.centralDirectory.totalEntries = zip64cd.totalEntries;\n        that.centralDirectory.size = zip64cd.size;\n        that.centralDirectory.offset = zip64cd.offset;\n        that.entriesCount = zip64cd.volumeEntries;\n        op = {};\n        readEntries();\n    }\n\n    function readEntries() {\n        op = {\n            win: new FileWindowBuffer(fd),\n            pos: centralDirectory.offset,\n            chunkSize,\n            entriesLeft: centralDirectory.volumeEntries,\n        };\n        op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);\n    }\n\n    function readEntriesCallback(err, bytesRead) {\n        if (err || !bytesRead) {\n            return that.emit('error', err || new Error('Entries read error'));\n        }\n        let bufferPos = op.pos - op.win.position;\n        let entry = op.entry;\n        const buffer = op.win.buffer;\n        const bufferLength = buffer.length;\n        try {\n            while (op.entriesLeft > 0) {\n                if (!entry) {\n                    entry = new ZipEntry();\n                    entry.readHeader(buffer, bufferPos);\n                    entry.headerOffset = op.win.position + bufferPos;\n                    op.entry = entry;\n                    op.pos += consts.CENHDR;\n                    bufferPos += consts.CENHDR;\n                }\n                const entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;\n                const advanceBytes = entryHeaderSize + (op.entriesLeft > 1 ? consts.CENHDR : 0);\n                if (bufferLength - bufferPos < advanceBytes) {\n                    op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);\n                    op.move = true;\n                    return;\n                }\n                entry.read(buffer, bufferPos, textDecoder);\n                if (!config.skipEntryNameValidation) {\n                    entry.validateName();\n                }\n                if (entries) {\n                    entries[entry.name] = entry;\n                }\n                that.emit('entry', entry);\n                op.entry = entry = null;\n                op.entriesLeft--;\n                op.pos += entryHeaderSize;\n                bufferPos += entryHeaderSize;\n            }\n            that.emit('ready');\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function checkEntriesExist() {\n        if (!entries) {\n            throw new Error('storeEntries disabled');\n        }\n    }\n\n    Object.defineProperty(this, 'ready', {\n        get() {\n            return ready;\n        },\n    });\n\n    this.entry = function (name) {\n        checkEntriesExist();\n        return entries[name];\n    };\n\n    this.entries = function () {\n        checkEntriesExist();\n        return entries;\n    };\n\n    this.stream = function (entry, callback) {\n        return this.openEntry(\n            entry,\n            (err, entry) => {\n                if (err) {\n                    return callback(err);\n                }\n                const offset = dataOffset(entry);\n                let entryStream = new EntryDataReaderStream(fd, offset, entry.compressedSize);\n                if (entry.method === consts.STORED) {\n                    // nothing to do\n                } else if (entry.method === consts.DEFLATED) {\n                    entryStream = entryStream.pipe(zlib.createInflateRaw());\n                } else {\n                    return callback(new Error('Unknown compression method: ' + entry.method));\n                }\n                if (canVerifyCrc(entry)) {\n                    entryStream = entryStream.pipe(\n                        new EntryVerifyStream(entryStream, entry.crc, entry.size)\n                    );\n                }\n                callback(null, entryStream);\n            },\n            false\n        );\n    };\n\n    this.entryDataSync = function (entry) {\n        let err = null;\n        this.openEntry(\n            entry,\n            (e, en) => {\n                err = e;\n                entry = en;\n            },\n            true\n        );\n        if (err) {\n            throw err;\n        }\n        let data = Buffer.alloc(entry.compressedSize);\n        new FsRead(fd, data, 0, entry.compressedSize, dataOffset(entry), (e) => {\n            err = e;\n        }).read(true);\n        if (err) {\n            throw err;\n        }\n        if (entry.method === consts.STORED) {\n            // nothing to do\n        } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n            data = zlib.inflateRawSync(data);\n        } else {\n            throw new Error('Unknown compression method: ' + entry.method);\n        }\n        if (data.length !== entry.size) {\n            throw new Error('Invalid size');\n        }\n        if (canVerifyCrc(entry)) {\n            const verify = new CrcVerify(entry.crc, entry.size);\n            verify.data(data);\n        }\n        return data;\n    };\n\n    this.openEntry = function (entry, callback, sync) {\n        if (typeof entry === 'string') {\n            checkEntriesExist();\n            entry = entries[entry];\n            if (!entry) {\n                return callback(new Error('Entry not found'));\n            }\n        }\n        if (!entry.isFile) {\n            return callback(new Error('Entry is not file'));\n        }\n        if (!fd) {\n            return callback(new Error('Archive closed'));\n        }\n        const buffer = Buffer.alloc(consts.LOCHDR);\n        new FsRead(fd, buffer, 0, buffer.length, entry.offset, (err) => {\n            if (err) {\n                return callback(err);\n            }\n            let readEx;\n            try {\n                entry.readDataHeader(buffer);\n                if (entry.encrypted) {\n                    readEx = new Error('Entry encrypted');\n                }\n            } catch (ex) {\n                readEx = ex;\n            }\n            callback(readEx, entry);\n        }).read(sync);\n    };\n\n    function dataOffset(entry) {\n        return entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;\n    }\n\n    function canVerifyCrc(entry) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n        return (entry.flags & 0x8) !== 0x8;\n    }\n\n    function extract(entry, outPath, callback) {\n        that.stream(entry, (err, stm) => {\n            if (err) {\n                callback(err);\n            } else {\n                let fsStm, errThrown;\n                stm.on('error', (err) => {\n                    errThrown = err;\n                    if (fsStm) {\n                        stm.unpipe(fsStm);\n                        fsStm.close(() => {\n                            callback(err);\n                        });\n                    }\n                });\n                fs.open(outPath, 'w', (err, fdFile) => {\n                    if (err) {\n                        return callback(err);\n                    }\n                    if (errThrown) {\n                        fs.close(fd, () => {\n                            callback(errThrown);\n                        });\n                        return;\n                    }\n                    fsStm = fs.createWriteStream(outPath, { fd: fdFile });\n                    fsStm.on('finish', () => {\n                        that.emit('extract', entry, outPath);\n                        if (!errThrown) {\n                            callback();\n                        }\n                    });\n                    stm.pipe(fsStm);\n                });\n            }\n        });\n    }\n\n    function createDirectories(baseDir, dirs, callback) {\n        if (!dirs.length) {\n            return callback();\n        }\n        let dir = dirs.shift();\n        dir = path.join(baseDir, path.join(...dir));\n        fs.mkdir(dir, { recursive: true }, (err) => {\n            if (err && err.code !== 'EEXIST') {\n                return callback(err);\n            }\n            createDirectories(baseDir, dirs, callback);\n        });\n    }\n\n    function extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {\n        if (!files.length) {\n            return callback(null, extractedCount);\n        }\n        const file = files.shift();\n        const targetPath = path.join(baseDir, file.name.replace(baseRelPath, ''));\n        extract(file, targetPath, (err) => {\n            if (err) {\n                return callback(err, extractedCount);\n            }\n            extractFiles(baseDir, baseRelPath, files, callback, extractedCount + 1);\n        });\n    }\n\n    this.extract = function (entry, outPath, callback) {\n        let entryName = entry || '';\n        if (typeof entry === 'string') {\n            entry = this.entry(entry);\n            if (entry) {\n                entryName = entry.name;\n            } else {\n                if (entryName.length && entryName[entryName.length - 1] !== '/') {\n                    entryName += '/';\n                }\n            }\n        }\n        if (!entry || entry.isDirectory) {\n            const files = [],\n                dirs = [],\n                allDirs = {};\n            for (const e in entries) {\n                if (\n                    Object.prototype.hasOwnProperty.call(entries, e) &&\n                    e.lastIndexOf(entryName, 0) === 0\n                ) {\n                    let relPath = e.replace(entryName, '');\n                    const childEntry = entries[e];\n                    if (childEntry.isFile) {\n                        files.push(childEntry);\n                        relPath = path.dirname(relPath);\n                    }\n                    if (relPath && !allDirs[relPath] && relPath !== '.') {\n                        allDirs[relPath] = true;\n                        let parts = relPath.split('/').filter((f) => {\n                            return f;\n                        });\n                        if (parts.length) {\n                            dirs.push(parts);\n                        }\n                        while (parts.length > 1) {\n                            parts = parts.slice(0, parts.length - 1);\n                            const partsPath = parts.join('/');\n                            if (allDirs[partsPath] || partsPath === '.') {\n                                break;\n                            }\n                            allDirs[partsPath] = true;\n                            dirs.push(parts);\n                        }\n                    }\n                }\n            }\n            dirs.sort((x, y) => {\n                return x.length - y.length;\n            });\n            if (dirs.length) {\n                createDirectories(outPath, dirs, (err) => {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        extractFiles(outPath, entryName, files, callback, 0);\n                    }\n                });\n            } else {\n                extractFiles(outPath, entryName, files, callback, 0);\n            }\n        } else {\n            fs.stat(outPath, (err, stat) => {\n                if (stat && stat.isDirectory()) {\n                    extract(entry, path.join(outPath, path.basename(entry.name)), callback);\n                } else {\n                    extract(entry, outPath, callback);\n                }\n            });\n        }\n    };\n\n    this.close = function (callback) {\n        if (closed || !fd) {\n            closed = true;\n            if (callback) {\n                callback();\n            }\n        } else {\n            closed = true;\n            fs.close(fd, (err) => {\n                fd = null;\n                if (callback) {\n                    callback(err);\n                }\n            });\n        }\n    };\n\n    const originalEmit = events.EventEmitter.prototype.emit;\n    this.emit = function (...args) {\n        if (!closed) {\n            return originalEmit.call(this, ...args);\n        }\n    };\n};\n\nStreamZip.setFs = function (customFs) {\n    fs = customFs;\n};\n\nStreamZip.debugLog = (...args) => {\n    if (StreamZip.debug) {\n        // eslint-disable-next-line no-console\n        console.log(...args);\n    }\n};\n\nutil.inherits(StreamZip, events.EventEmitter);\n\nconst propZip = Symbol('zip');\n\nStreamZip.async = class StreamZipAsync extends events.EventEmitter {\n    constructor(config) {\n        super();\n\n        const zip = new StreamZip(config);\n\n        zip.on('entry', (entry) => this.emit('entry', entry));\n        zip.on('extract', (entry, outPath) => this.emit('extract', entry, outPath));\n\n        this[propZip] = new Promise((resolve, reject) => {\n            zip.on('ready', () => {\n                zip.removeListener('error', reject);\n                resolve(zip);\n            });\n            zip.on('error', reject);\n        });\n    }\n\n    get entriesCount() {\n        return this[propZip].then((zip) => zip.entriesCount);\n    }\n\n    get comment() {\n        return this[propZip].then((zip) => zip.comment);\n    }\n\n    async entry(name) {\n        const zip = await this[propZip];\n        return zip.entry(name);\n    }\n\n    async entries() {\n        const zip = await this[propZip];\n        return zip.entries();\n    }\n\n    async stream(entry) {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.stream(entry, (err, stm) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(stm);\n                }\n            });\n        });\n    }\n\n    async entryData(entry) {\n        const stm = await this.stream(entry);\n        return new Promise((resolve, reject) => {\n            const data = [];\n            stm.on('data', (chunk) => data.push(chunk));\n            stm.on('end', () => {\n                resolve(Buffer.concat(data));\n            });\n            stm.on('error', (err) => {\n                stm.removeAllListeners('end');\n                reject(err);\n            });\n        });\n    }\n\n    async extract(entry, outPath) {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.extract(entry, outPath, (err, res) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            });\n        });\n    }\n\n    async close() {\n        const zip = await this[propZip];\n        return new Promise((resolve, reject) => {\n            zip.close((err) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n};\n\nclass CentralDirectoryHeader {\n    read(data) {\n        if (data.length !== consts.ENDHDR || data.readUInt32LE(0) !== consts.ENDSIG) {\n            throw new Error('Invalid central directory');\n        }\n        // number of entries on this volume\n        this.volumeEntries = data.readUInt16LE(consts.ENDSUB);\n        // total number of entries\n        this.totalEntries = data.readUInt16LE(consts.ENDTOT);\n        // central directory size in bytes\n        this.size = data.readUInt32LE(consts.ENDSIZ);\n        // offset of first CEN header\n        this.offset = data.readUInt32LE(consts.ENDOFF);\n        // zip file comment length\n        this.commentLength = data.readUInt16LE(consts.ENDCOM);\n    }\n}\n\nclass CentralDirectoryLoc64Header {\n    read(data) {\n        if (data.length !== consts.ENDL64HDR || data.readUInt32LE(0) !== consts.ENDL64SIG) {\n            throw new Error('Invalid zip64 central directory locator');\n        }\n        // ZIP64 EOCD header offset\n        this.headerOffset = readUInt64LE(data, consts.ENDSUB);\n    }\n}\n\nclass CentralDirectoryZip64Header {\n    read(data) {\n        if (data.length !== consts.END64HDR || data.readUInt32LE(0) !== consts.END64SIG) {\n            throw new Error('Invalid central directory');\n        }\n        // number of entries on this volume\n        this.volumeEntries = readUInt64LE(data, consts.END64SUB);\n        // total number of entries\n        this.totalEntries = readUInt64LE(data, consts.END64TOT);\n        // central directory size in bytes\n        this.size = readUInt64LE(data, consts.END64SIZ);\n        // offset of first CEN header\n        this.offset = readUInt64LE(data, consts.END64OFF);\n    }\n}\n\nclass ZipEntry {\n    readHeader(data, offset) {\n        // data should be 46 bytes and start with \"PK 01 02\"\n        if (data.length < offset + consts.CENHDR || data.readUInt32LE(offset) !== consts.CENSIG) {\n            throw new Error('Invalid entry header');\n        }\n        // version made by\n        this.verMade = data.readUInt16LE(offset + consts.CENVEM);\n        // version needed to extract\n        this.version = data.readUInt16LE(offset + consts.CENVER);\n        // encrypt, decrypt flags\n        this.flags = data.readUInt16LE(offset + consts.CENFLG);\n        // compression method\n        this.method = data.readUInt16LE(offset + consts.CENHOW);\n        // modification time (2 bytes time, 2 bytes date)\n        const timebytes = data.readUInt16LE(offset + consts.CENTIM);\n        const datebytes = data.readUInt16LE(offset + consts.CENTIM + 2);\n        this.time = parseZipTime(timebytes, datebytes);\n\n        // uncompressed file crc-32 value\n        this.crc = data.readUInt32LE(offset + consts.CENCRC);\n        // compressed size\n        this.compressedSize = data.readUInt32LE(offset + consts.CENSIZ);\n        // uncompressed size\n        this.size = data.readUInt32LE(offset + consts.CENLEN);\n        // filename length\n        this.fnameLen = data.readUInt16LE(offset + consts.CENNAM);\n        // extra field length\n        this.extraLen = data.readUInt16LE(offset + consts.CENEXT);\n        // file comment length\n        this.comLen = data.readUInt16LE(offset + consts.CENCOM);\n        // volume number start\n        this.diskStart = data.readUInt16LE(offset + consts.CENDSK);\n        // internal file attributes\n        this.inattr = data.readUInt16LE(offset + consts.CENATT);\n        // external file attributes\n        this.attr = data.readUInt32LE(offset + consts.CENATX);\n        // LOC header offset\n        this.offset = data.readUInt32LE(offset + consts.CENOFF);\n    }\n\n    readDataHeader(data) {\n        // 30 bytes and should start with \"PK\\003\\004\"\n        if (data.readUInt32LE(0) !== consts.LOCSIG) {\n            throw new Error('Invalid local header');\n        }\n        // version needed to extract\n        this.version = data.readUInt16LE(consts.LOCVER);\n        // general purpose bit flag\n        this.flags = data.readUInt16LE(consts.LOCFLG);\n        // compression method\n        this.method = data.readUInt16LE(consts.LOCHOW);\n        // modification time (2 bytes time ; 2 bytes date)\n        const timebytes = data.readUInt16LE(consts.LOCTIM);\n        const datebytes = data.readUInt16LE(consts.LOCTIM + 2);\n        this.time = parseZipTime(timebytes, datebytes);\n\n        // uncompressed file crc-32 value\n        this.crc = data.readUInt32LE(consts.LOCCRC) || this.crc;\n        // compressed size\n        const compressedSize = data.readUInt32LE(consts.LOCSIZ);\n        if (compressedSize && compressedSize !== consts.EF_ZIP64_OR_32) {\n            this.compressedSize = compressedSize;\n        }\n        // uncompressed size\n        const size = data.readUInt32LE(consts.LOCLEN);\n        if (size && size !== consts.EF_ZIP64_OR_32) {\n            this.size = size;\n        }\n        // filename length\n        this.fnameLen = data.readUInt16LE(consts.LOCNAM);\n        // extra field length\n        this.extraLen = data.readUInt16LE(consts.LOCEXT);\n    }\n\n    read(data, offset, textDecoder) {\n        const nameData = data.slice(offset, (offset += this.fnameLen));\n        this.name = textDecoder\n            ? textDecoder.decode(new Uint8Array(nameData))\n            : nameData.toString('utf8');\n        const lastChar = data[offset - 1];\n        this.isDirectory = lastChar === 47 || lastChar === 92;\n\n        if (this.extraLen) {\n            this.readExtra(data, offset);\n            offset += this.extraLen;\n        }\n        this.comment = this.comLen ? data.slice(offset, offset + this.comLen).toString() : null;\n    }\n\n    validateName() {\n        if (/\\\\|^\\w+:|^\\/|(^|\\/)\\.\\.(\\/|$)/.test(this.name)) {\n            throw new Error('Malicious entry: ' + this.name);\n        }\n    }\n\n    readExtra(data, offset) {\n        let signature, size;\n        const maxPos = offset + this.extraLen;\n        while (offset < maxPos) {\n            signature = data.readUInt16LE(offset);\n            offset += 2;\n            size = data.readUInt16LE(offset);\n            offset += 2;\n            if (consts.ID_ZIP64 === signature) {\n                this.parseZip64Extra(data, offset, size);\n            }\n            offset += size;\n        }\n    }\n\n    parseZip64Extra(data, offset, length) {\n        if (length >= 8 && this.size === consts.EF_ZIP64_OR_32) {\n            this.size = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 8 && this.compressedSize === consts.EF_ZIP64_OR_32) {\n            this.compressedSize = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 8 && this.offset === consts.EF_ZIP64_OR_32) {\n            this.offset = readUInt64LE(data, offset);\n            offset += 8;\n            length -= 8;\n        }\n        if (length >= 4 && this.diskStart === consts.EF_ZIP64_OR_16) {\n            this.diskStart = data.readUInt32LE(offset);\n            // offset += 4; length -= 4;\n        }\n    }\n\n    get encrypted() {\n        return (this.flags & consts.FLG_ENTRY_ENC) === consts.FLG_ENTRY_ENC;\n    }\n\n    get isFile() {\n        return !this.isDirectory;\n    }\n}\n\nclass FsRead {\n    constructor(fd, buffer, offset, length, position, callback) {\n        this.fd = fd;\n        this.buffer = buffer;\n        this.offset = offset;\n        this.length = length;\n        this.position = position;\n        this.callback = callback;\n        this.bytesRead = 0;\n        this.waiting = false;\n    }\n\n    read(sync) {\n        StreamZip.debugLog('read', this.position, this.bytesRead, this.length, this.offset);\n        this.waiting = true;\n        let err;\n        if (sync) {\n            let bytesRead = 0;\n            try {\n                bytesRead = fs.readSync(\n                    this.fd,\n                    this.buffer,\n                    this.offset + this.bytesRead,\n                    this.length - this.bytesRead,\n                    this.position + this.bytesRead\n                );\n            } catch (e) {\n                err = e;\n            }\n            this.readCallback(sync, err, err ? bytesRead : null);\n        } else {\n            fs.read(\n                this.fd,\n                this.buffer,\n                this.offset + this.bytesRead,\n                this.length - this.bytesRead,\n                this.position + this.bytesRead,\n                this.readCallback.bind(this, sync)\n            );\n        }\n    }\n\n    readCallback(sync, err, bytesRead) {\n        if (typeof bytesRead === 'number') {\n            this.bytesRead += bytesRead;\n        }\n        if (err || !bytesRead || this.bytesRead === this.length) {\n            this.waiting = false;\n            return this.callback(err, this.bytesRead);\n        } else {\n            this.read(sync);\n        }\n    }\n}\n\nclass FileWindowBuffer {\n    constructor(fd) {\n        this.position = 0;\n        this.buffer = Buffer.alloc(0);\n        this.fd = fd;\n        this.fsOp = null;\n    }\n\n    checkOp() {\n        if (this.fsOp && this.fsOp.waiting) {\n            throw new Error('Operation in progress');\n        }\n    }\n\n    read(pos, length, callback) {\n        this.checkOp();\n        if (this.buffer.length < length) {\n            this.buffer = Buffer.alloc(length);\n        }\n        this.position = pos;\n        this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n    }\n\n    expandLeft(length, callback) {\n        this.checkOp();\n        this.buffer = Buffer.concat([Buffer.alloc(length), this.buffer]);\n        this.position -= length;\n        if (this.position < 0) {\n            this.position = 0;\n        }\n        this.fsOp = new FsRead(this.fd, this.buffer, 0, length, this.position, callback).read();\n    }\n\n    expandRight(length, callback) {\n        this.checkOp();\n        const offset = this.buffer.length;\n        this.buffer = Buffer.concat([this.buffer, Buffer.alloc(length)]);\n        this.fsOp = new FsRead(\n            this.fd,\n            this.buffer,\n            offset,\n            length,\n            this.position + offset,\n            callback\n        ).read();\n    }\n\n    moveRight(length, callback, shift) {\n        this.checkOp();\n        if (shift) {\n            this.buffer.copy(this.buffer, 0, shift);\n        } else {\n            shift = 0;\n        }\n        this.position += shift;\n        this.fsOp = new FsRead(\n            this.fd,\n            this.buffer,\n            this.buffer.length - shift,\n            shift,\n            this.position + this.buffer.length - shift,\n            callback\n        ).read();\n    }\n}\n\nclass EntryDataReaderStream extends stream.Readable {\n    constructor(fd, offset, length) {\n        super();\n        this.fd = fd;\n        this.offset = offset;\n        this.length = length;\n        this.pos = 0;\n        this.readCallback = this.readCallback.bind(this);\n    }\n\n    _read(n) {\n        const buffer = Buffer.alloc(Math.min(n, this.length - this.pos));\n        if (buffer.length) {\n            fs.read(this.fd, buffer, 0, buffer.length, this.offset + this.pos, this.readCallback);\n        } else {\n            this.push(null);\n        }\n    }\n\n    readCallback(err, bytesRead, buffer) {\n        this.pos += bytesRead;\n        if (err) {\n            this.emit('error', err);\n            this.push(null);\n        } else if (!bytesRead) {\n            this.push(null);\n        } else {\n            if (bytesRead !== buffer.length) {\n                buffer = buffer.slice(0, bytesRead);\n            }\n            this.push(buffer);\n        }\n    }\n}\n\nclass EntryVerifyStream extends stream.Transform {\n    constructor(baseStm, crc, size) {\n        super();\n        this.verify = new CrcVerify(crc, size);\n        baseStm.on('error', (e) => {\n            this.emit('error', e);\n        });\n    }\n\n    _transform(data, encoding, callback) {\n        let err;\n        try {\n            this.verify.data(data);\n        } catch (e) {\n            err = e;\n        }\n        callback(err, data);\n    }\n}\n\nclass CrcVerify {\n    constructor(crc, size) {\n        this.crc = crc;\n        this.size = size;\n        this.state = {\n            crc: ~0,\n            size: 0,\n        };\n    }\n\n    data(data) {\n        const crcTable = CrcVerify.getCrcTable();\n        let crc = this.state.crc;\n        let off = 0;\n        let len = data.length;\n        while (--len >= 0) {\n            crc = crcTable[(crc ^ data[off++]) & 0xff] ^ (crc >>> 8);\n        }\n        this.state.crc = crc;\n        this.state.size += data.length;\n        if (this.state.size >= this.size) {\n            const buf = Buffer.alloc(4);\n            buf.writeInt32LE(~this.state.crc & 0xffffffff, 0);\n            crc = buf.readUInt32LE(0);\n            if (crc !== this.crc) {\n                throw new Error('Invalid CRC');\n            }\n            if (this.state.size !== this.size) {\n                throw new Error('Invalid size');\n            }\n        }\n    }\n\n    static getCrcTable() {\n        let crcTable = CrcVerify.crcTable;\n        if (!crcTable) {\n            CrcVerify.crcTable = crcTable = [];\n            const b = Buffer.alloc(4);\n            for (let n = 0; n < 256; n++) {\n                let c = n;\n                for (let k = 8; --k >= 0; ) {\n                    if ((c & 1) !== 0) {\n                        c = 0xedb88320 ^ (c >>> 1);\n                    } else {\n                        c = c >>> 1;\n                    }\n                }\n                if (c < 0) {\n                    b.writeInt32LE(c, 0);\n                    c = b.readUInt32LE(0);\n                }\n                crcTable[n] = c;\n            }\n        }\n        return crcTable;\n    }\n}\n\nfunction parseZipTime(timebytes, datebytes) {\n    const timebits = toBits(timebytes, 16);\n    const datebits = toBits(datebytes, 16);\n\n    const mt = {\n        h: parseInt(timebits.slice(0, 5).join(''), 2),\n        m: parseInt(timebits.slice(5, 11).join(''), 2),\n        s: parseInt(timebits.slice(11, 16).join(''), 2) * 2,\n        Y: parseInt(datebits.slice(0, 7).join(''), 2) + 1980,\n        M: parseInt(datebits.slice(7, 11).join(''), 2),\n        D: parseInt(datebits.slice(11, 16).join(''), 2),\n    };\n    const dt_str = [mt.Y, mt.M, mt.D].join('-') + ' ' + [mt.h, mt.m, mt.s].join(':') + ' GMT+0';\n    return new Date(dt_str).getTime();\n}\n\nfunction toBits(dec, size) {\n    let b = (dec >>> 0).toString(2);\n    while (b.length < size) {\n        b = '0' + b;\n    }\n    return b.split('');\n}\n\nfunction readUInt64LE(buffer, offset) {\n    return buffer.readUInt32LE(offset + 4) * 0x0000000100000000 + buffer.readUInt32LE(offset);\n}\n\nmodule.exports = StreamZip;\n", "import { Form, Action, ActionPanel, showToast, Toast, Icon } from \"@raycast/api\";\nimport { BitwardenProvider, useBitwarden } from \"~/context/bitwarden\";\nimport RootErrorBoundary from \"~/components/RootErrorBoundary\";\nimport { SessionProvider } from \"~/context/session\";\nimport { FormValidation, useForm } from \"@raycast/utils\";\nimport { DebuggingBugReportingActionSection } from \"~/components/actions\";\n\nconst CreateFolderCommand = () => (\n  <RootErrorBoundary>\n    <BitwardenProvider>\n      <SessionProvider unlock>\n        <CreateFolderComponent />\n      </SessionProvider>\n    </BitwardenProvider>\n  </RootErrorBoundary>\n);\n\ninterface FormData {\n  name: string;\n}\n\nfunction CreateFolderComponent() {\n  const bitwarden = useBitwarden();\n\n  const { handleSubmit, itemProps } = useForm<FormData>({\n    onSubmit: async (formData) => {\n      const toast = await showToast({ title: \"Creating Folder...\", style: Toast.Style.Animated });\n      try {\n        const { error } = await bitwarden.createFolder(formData.name);\n        if (error) throw error;\n        toast.style = Toast.Style.Success;\n        toast.title = \"Folder created\";\n        toast.message = formData.name;\n      } catch (error) {\n        toast.style = Toast.Style.Failure;\n        toast.title = \"Failed to create folder\";\n        toast.message = undefined;\n      }\n    },\n    validation: {\n      name: FormValidation.Required,\n    },\n  });\n\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm title=\"Create Folder\" onSubmit={handleSubmit} icon={Icon.NewFolder} />\n          <DebuggingBugReportingActionSection />\n        </ActionPanel>\n      }\n    >\n      <Form.TextField title=\"Folder Name\" placeholder=\"eg: Personal, Work\" autoFocus {...itemProps.name} />\n    </Form>\n  );\n}\n\nexport default CreateFolderCommand;\n", "import { createContext, PropsWithChildren, ReactNode, useContext, useState } from \"react\";\nimport { Bitwarden } from \"~/api/bitwarden\";\nimport { LoadingFallback } from \"~/components/LoadingFallback\";\nimport TroubleshootingGuide from \"~/components/TroubleshootingGuide\";\nimport { InstalledCLINotFoundError } from \"~/utils/errors\";\nimport useOnceEffect from \"~/utils/hooks/useOnceEffect\";\n\nconst BitwardenContext = createContext<Bitwarden | null>(null);\n\nexport type BitwardenProviderProps = PropsWithChildren<{\n  loadingFallback?: ReactNode;\n}>;\n\nexport const BitwardenProvider = ({ children, loadingFallback = <LoadingFallback /> }: BitwardenProviderProps) => {\n  const [bitwarden, setBitwarden] = useState<Bitwarden>();\n  const [error, setError] = useState<Error>();\n\n  useOnceEffect(() => {\n    void new Bitwarden().initialize().then(setBitwarden).catch(handleBwInitError);\n  });\n\n  function handleBwInitError(error: Error) {\n    if (error instanceof InstalledCLINotFoundError) {\n      setError(error);\n    } else {\n      throw error;\n    }\n  }\n\n  if (error) return <TroubleshootingGuide error={error} />;\n  if (!bitwarden) return loadingFallback;\n\n  return <BitwardenContext.Provider value={bitwarden}>{children}</BitwardenContext.Provider>;\n};\n\nexport const useBitwarden = () => {\n  const context = useContext(BitwardenContext);\n  if (context == null) {\n    throw new Error(\"useBitwarden must be used within a BitwardenProvider\");\n  }\n\n  return context;\n};\n\nexport default BitwardenContext;\n", "import { environment, getPreferenceValues, LocalStorage, open, showToast, Toast } from \"@raycast/api\";\nimport { execa, ExecaChildProcess, ExecaError, ExecaReturnValue } from \"execa\";\nimport { existsSync, unlinkSync, writeFileSync, accessSync, constants, chmodSync } from \"fs\";\nimport { LOCAL_STORAGE_KEY, DEFAULT_SERVER_URL, CACHE_KEYS } from \"~/constants/general\";\nimport { VaultState, VaultStatus } from \"~/types/general\";\nimport { PasswordGeneratorOptions } from \"~/types/passwords\";\nimport { Folder, Item, ItemType, Login } from \"~/types/vault\";\nimport { getPasswordGeneratingArgs } from \"~/utils/passwords\";\nimport { getServerUrlPreference } from \"~/utils/preferences\";\nimport {\n  EnsureCliBinError,\n  InstalledCLINotFoundError,\n  ManuallyThrownError,\n  NotLoggedInError,\n  PremiumFeatureError,\n  SendInvalidPasswordError,\n  SendNeedsPasswordError,\n  tryExec,\n  VaultIsLockedError,\n} from \"~/utils/errors\";\nimport { join, dirname } from \"path\";\nimport { chmod, rename, rm } from \"fs/promises\";\nimport { decompressFile, removeFilesThatStartWith, unlinkAllSync, waitForFileAvailable } from \"~/utils/fs\";\nimport { download } from \"~/utils/network\";\nimport { captureException } from \"~/utils/development\";\nimport { ReceivedSend, Send, SendCreatePayload, SendType } from \"~/types/send\";\nimport { prepareSendPayload } from \"~/api/bitwarden.helpers\";\nimport { Cache } from \"~/utils/cache\";\nimport { platform } from \"~/utils/platform\";\n\ntype Env = {\n  BITWARDENCLI_APPDATA_DIR: string;\n  BW_CLIENTSECRET: string;\n  BW_CLIENTID: string;\n  PATH: string;\n  NODE_EXTRA_CA_CERTS?: string;\n  BW_SESSION?: string;\n};\n\ntype ActionListeners = {\n  login?: () => MaybePromise<void>;\n  logout?: (reason?: string) => MaybePromise<void>;\n  lock?: (reason?: string) => MaybePromise<void>;\n  unlock?: (password: string, sessionToken: string) => MaybePromise<void>;\n};\n\ntype ActionListenersMap<T extends keyof ActionListeners = keyof ActionListeners> = Map<T, Set<ActionListeners[T]>>;\n\ntype MaybeError<T = undefined> = { result: T; error?: undefined } | { result?: undefined; error: ManuallyThrownError };\n\ntype ExecProps = {\n  /** Reset the time of the last command that accessed data or modified the vault, used to determine if the vault timed out */\n  resetVaultTimeout: boolean;\n  abortController?: AbortController;\n  input?: string;\n};\n\ntype LockOptions = {\n  /** The reason for locking the vault */\n  reason?: string;\n  checkVaultStatus?: boolean;\n  /** The callbacks are called before the operation is finished (optimistic) */\n  immediate?: boolean;\n};\n\ntype LogoutOptions = {\n  /** The reason for locking the vault */\n  reason?: string;\n  /** The callbacks are called before the operation is finished (optimistic) */\n  immediate?: boolean;\n};\n\ntype ReceiveSendOptions = {\n  savePath?: string;\n  password?: string;\n};\n\ntype CreateLoginItemOptions = {\n  name: string;\n  username?: string;\n  password: string;\n  folderId: string | null;\n  uri?: string;\n};\n\nconst { supportPath } = environment;\n\nconst \u0394 = \"4\"; // changing this forces a new bin download for people that had a failed one\nconst BinDownloadLogger = (() => {\n  /* The idea of this logger is to write a log file when the bin download fails, so that we can let the extension crash,\n   but fallback to the local cli path in the next launch. This allows the error to be reported in the issues dashboard. It uses files to keep it synchronous, as it's needed in the constructor.\n   Although, the plan is to discontinue this method, if there's a better way of logging errors in the issues dashboard\n   or there are no crashes reported with the bin download after some time. */\n  const filePath = join(supportPath, `bw-bin-download-error-${\u0394}.log`);\n  return {\n    logError: (error: any) => tryExec(() => writeFileSync(filePath, error?.message ?? \"Unexpected error\")),\n    clearError: () => tryExec(() => unlinkSync(filePath)),\n    hasError: () => tryExec(() => existsSync(filePath), false),\n  };\n})();\n\nexport const cliInfo = {\n  version: \"2025.2.0\",\n  get sha256() {\n    if (platform === \"windows\") return \"33a131017ac9c99d721e430a86e929383314d3f91c9f2fbf413d872565654c18\";\n    return \"fade51012a46011c016a2e5aee2f2e534c1ed078e49d1178a69e2889d2812a96\";\n  },\n  downloadPage: \"https://github.com/bitwarden/clients/releases\",\n  path: {\n    get downloadedBin() {\n      return join(supportPath, cliInfo.binFilenameVersioned);\n    },\n    get installedBin() {\n      // We assume that it was installed using Chocolatey, if not, it's hard to make a good guess.\n      if (platform === \"windows\") return \"C:\\\\ProgramData\\\\chocolatey\\\\bin\\\\bw.exe\";\n      return process.arch === \"arm64\" ? \"/opt/homebrew/bin/bw\" : \"/usr/local/bin/bw\";\n    },\n    get bin() {\n      return !BinDownloadLogger.hasError() ? this.downloadedBin : this.installedBin;\n    },\n  },\n  get binFilename() {\n    return platform === \"windows\" ? \"bw.exe\" : \"bw\";\n  },\n  get binFilenameVersioned() {\n    const name = `bw-${this.version}`;\n    return platform === \"windows\" ? `${name}.exe` : `${name}`;\n  },\n  get downloadUrl() {\n    let archSuffix = \"\";\n    if (platform === \"macos\") {\n      archSuffix = process.arch === \"arm64\" ? \"-arm64\" : \"\";\n    }\n\n    return `${this.downloadPage}/download/cli-v${this.version}/bw-${platform}${archSuffix}-${this.version}.zip`;\n  },\n} as const;\n\nexport class Bitwarden {\n  private env: Env;\n  private initPromise: Promise<void>;\n  private tempSessionToken?: string;\n  private actionListeners: ActionListenersMap = new Map();\n  private preferences = getPreferenceValues<Preferences>();\n  private cliPath: string;\n  private toastInstance: Toast | undefined;\n  wasCliUpdated = false;\n\n  constructor(toastInstance?: Toast) {\n    const { cliPath: cliPathPreference, clientId, clientSecret, serverCertsPath } = this.preferences;\n    const serverUrl = getServerUrlPreference();\n\n    this.toastInstance = toastInstance;\n    this.cliPath = cliPathPreference || cliInfo.path.bin;\n    this.env = {\n      BITWARDENCLI_APPDATA_DIR: supportPath,\n      BW_CLIENTSECRET: clientSecret.trim(),\n      BW_CLIENTID: clientId.trim(),\n      PATH: dirname(process.execPath),\n      ...(serverUrl && serverCertsPath ? { NODE_EXTRA_CA_CERTS: serverCertsPath } : {}),\n    };\n\n    this.initPromise = (async (): Promise<void> => {\n      await this.ensureCliBinary();\n      void this.retrieveAndCacheCliVersion();\n      await this.checkServerUrl(serverUrl);\n    })();\n  }\n\n  private async ensureCliBinary(): Promise<void> {\n    if (this.checkCliBinIsReady(this.cliPath)) return;\n    if (this.cliPath === this.preferences.cliPath || this.cliPath === cliInfo.path.installedBin) {\n      throw new InstalledCLINotFoundError(`Bitwarden CLI not found at ${this.cliPath}`);\n    }\n    if (BinDownloadLogger.hasError()) BinDownloadLogger.clearError();\n\n    // remove old binaries to check if it's an update and because they are 100MB+\n    const hadOldBinaries = await removeFilesThatStartWith(\"bw-\", supportPath);\n    const toast = await this.showToast({\n      title: `${hadOldBinaries ? \"Updating\" : \"Initializing\"} Bitwarden CLI`,\n      style: Toast.Style.Animated,\n      primaryAction: { title: \"Open Download Page\", onAction: () => open(cliInfo.downloadPage) },\n    });\n    const tmpFileName = \"bw.zip\";\n    const zipPath = join(supportPath, tmpFileName);\n\n    try {\n      try {\n        toast.message = \"Downloading...\";\n        await download(cliInfo.downloadUrl, zipPath, {\n          onProgress: (percent) => (toast.message = `Downloading ${percent}%`),\n          sha256: cliInfo.sha256,\n        });\n      } catch (downloadError) {\n        toast.title = \"Failed to download Bitwarden CLI\";\n        throw downloadError;\n      }\n\n      try {\n        toast.message = \"Extracting...\";\n        await decompressFile(zipPath, supportPath);\n        const decompressedBinPath = join(supportPath, cliInfo.binFilename);\n\n        // For some reason this rename started throwing an error after succeeding, so for now we're just\n        // catching it and checking if the file exists \u00AF\\_(\u30C4)_/\u00AF\n        await rename(decompressedBinPath, this.cliPath).catch(() => null);\n        await waitForFileAvailable(this.cliPath);\n\n        await chmod(this.cliPath, \"755\");\n        await rm(zipPath, { force: true });\n\n        Cache.set(CACHE_KEYS.CLI_VERSION, cliInfo.version);\n        this.wasCliUpdated = true;\n      } catch (extractError) {\n        toast.title = \"Failed to extract Bitwarden CLI\";\n        throw extractError;\n      }\n      await toast.hide();\n    } catch (error) {\n      toast.message = error instanceof EnsureCliBinError ? error.message : \"Please try again\";\n      toast.style = Toast.Style.Failure;\n\n      unlinkAllSync(zipPath, this.cliPath);\n\n      if (!environment.isDevelopment) BinDownloadLogger.logError(error);\n      if (error instanceof Error) throw new EnsureCliBinError(error.message, error.stack);\n      throw error;\n    } finally {\n      await toast.restore();\n    }\n  }\n\n  private async retrieveAndCacheCliVersion(): Promise<void> {\n    try {\n      const { error, result } = await this.getVersion();\n      if (!error) Cache.set(CACHE_KEYS.CLI_VERSION, result);\n    } catch (error) {\n      captureException(\"Failed to retrieve and cache cli version\", error, { captureToRaycast: true });\n    }\n  }\n\n  private checkCliBinIsReady(filePath: string): boolean {\n    try {\n      if (!existsSync(this.cliPath)) return false;\n      accessSync(filePath, constants.X_OK);\n      return true;\n    } catch {\n      chmodSync(filePath, \"755\");\n      return true;\n    }\n  }\n\n  setSessionToken(token: string): void {\n    this.env = {\n      ...this.env,\n      BW_SESSION: token,\n    };\n  }\n\n  clearSessionToken(): void {\n    delete this.env.BW_SESSION;\n  }\n\n  withSession(token: string): this {\n    this.tempSessionToken = token;\n    return this;\n  }\n\n  async initialize(): Promise<this> {\n    await this.initPromise;\n    return this;\n  }\n\n  async checkServerUrl(serverUrl: string | undefined): Promise<void> {\n    // Check the CLI has been configured to use the preference Url\n    const storedServer = await LocalStorage.getItem<string>(LOCAL_STORAGE_KEY.SERVER_URL);\n    if (!serverUrl || storedServer === serverUrl) return;\n\n    // Update the server Url\n    const toast = await this.showToast({\n      style: Toast.Style.Animated,\n      title: \"Switching server...\",\n      message: \"Bitwarden server preference changed\",\n    });\n    try {\n      try {\n        await this.logout();\n      } catch {\n        // It doesn't matter if we weren't logged in.\n      }\n      // If URL is empty, set it to the default\n      await this.exec([\"config\", \"server\", serverUrl || DEFAULT_SERVER_URL], { resetVaultTimeout: false });\n      await LocalStorage.setItem(LOCAL_STORAGE_KEY.SERVER_URL, serverUrl);\n\n      toast.style = Toast.Style.Success;\n      toast.title = \"Success\";\n      toast.message = \"Bitwarden server changed\";\n    } catch (error) {\n      toast.style = Toast.Style.Failure;\n      toast.title = \"Failed to switch server\";\n      if (error instanceof Error) {\n        toast.message = error.message;\n      } else {\n        toast.message = \"Unknown error occurred\";\n      }\n    } finally {\n      await toast.restore();\n    }\n  }\n\n  private async exec(args: string[], options: ExecProps): Promise<ExecaChildProcess> {\n    const { abortController, input = \"\", resetVaultTimeout } = options ?? {};\n\n    let env = this.env;\n    if (this.tempSessionToken) {\n      env = { ...env, BW_SESSION: this.tempSessionToken };\n      this.tempSessionToken = undefined;\n    }\n\n    const result = await execa(this.cliPath, args, { input, env, signal: abortController?.signal });\n\n    if (this.isPromptWaitingForMasterPassword(result)) {\n      /* since we have the session token in the env, the password \n      should not be requested, unless the vault is locked */\n      await this.lock();\n      throw new VaultIsLockedError();\n    }\n\n    if (resetVaultTimeout) {\n      await LocalStorage.setItem(LOCAL_STORAGE_KEY.LAST_ACTIVITY_TIME, new Date().toISOString());\n    }\n\n    return result;\n  }\n\n  async getVersion(): Promise<MaybeError<string>> {\n    try {\n      const { stdout: result } = await this.exec([\"--version\"], { resetVaultTimeout: false });\n      return { result };\n    } catch (execError) {\n      captureException(\"Failed to get cli version\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async login(): Promise<MaybeError> {\n    try {\n      await this.exec([\"login\", \"--apikey\"], { resetVaultTimeout: true });\n      await this.saveLastVaultStatus(\"login\", \"unlocked\");\n      await this.callActionListeners(\"login\");\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to login\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async logout(options?: LogoutOptions): Promise<MaybeError> {\n    const { reason, immediate = false } = options ?? {};\n    try {\n      if (immediate) await this.handlePostLogout(reason);\n\n      await this.exec([\"logout\"], { resetVaultTimeout: false });\n      await this.saveLastVaultStatus(\"logout\", \"unauthenticated\");\n      if (!immediate) await this.handlePostLogout(reason);\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to logout\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async lock(options?: LockOptions): Promise<MaybeError> {\n    const { reason, checkVaultStatus = false, immediate = false } = options ?? {};\n    try {\n      if (immediate) await this.callActionListeners(\"lock\", reason);\n      if (checkVaultStatus) {\n        const { error, result } = await this.status();\n        if (error) throw error;\n        if (result.status === \"unauthenticated\") return { error: new NotLoggedInError(\"Not logged in\") };\n      }\n\n      await this.exec([\"lock\"], { resetVaultTimeout: false });\n      await this.saveLastVaultStatus(\"lock\", \"locked\");\n      if (!immediate) await this.callActionListeners(\"lock\", reason);\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to lock vault\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async unlock(password: string): Promise<MaybeError<string>> {\n    try {\n      const { stdout: sessionToken } = await this.exec([\"unlock\", password, \"--raw\"], { resetVaultTimeout: true });\n      this.setSessionToken(sessionToken);\n      await this.saveLastVaultStatus(\"unlock\", \"unlocked\");\n      await this.callActionListeners(\"unlock\", password, sessionToken);\n      return { result: sessionToken };\n    } catch (execError) {\n      captureException(\"Failed to unlock vault\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async sync(): Promise<MaybeError> {\n    try {\n      await this.exec([\"sync\"], { resetVaultTimeout: true });\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to sync vault\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async getItem(id: string): Promise<MaybeError<Item>> {\n    try {\n      const { stdout } = await this.exec([\"get\", \"item\", id], { resetVaultTimeout: true });\n      return { result: JSON.parse<Item>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to get item\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async listItems(): Promise<MaybeError<Item[]>> {\n    try {\n      const { stdout } = await this.exec([\"list\", \"items\"], { resetVaultTimeout: true });\n      const items = JSON.parse<Item[]>(stdout);\n      // Filter out items without a name property (they are not displayed in the bitwarden app)\n      return { result: items.filter((item: Item) => !!item.name) };\n    } catch (execError) {\n      captureException(\"Failed to list items\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async createLoginItem(options: CreateLoginItemOptions): Promise<MaybeError<Item>> {\n    try {\n      const { error: itemTemplateError, result: itemTemplate } = await this.getTemplate<Item>(\"item\");\n      if (itemTemplateError) throw itemTemplateError;\n\n      const { error: loginTemplateError, result: loginTemplate } = await this.getTemplate<Login>(\"item.login\");\n      if (loginTemplateError) throw loginTemplateError;\n\n      itemTemplate.name = options.name;\n      itemTemplate.type = ItemType.LOGIN;\n      itemTemplate.folderId = options.folderId || null;\n      itemTemplate.login = loginTemplate;\n      itemTemplate.notes = null;\n\n      loginTemplate.username = options.username || null;\n      loginTemplate.password = options.password;\n      loginTemplate.totp = null;\n      loginTemplate.fido2Credentials = undefined;\n\n      if (options.uri) {\n        loginTemplate.uris = [{ match: null, uri: options.uri }];\n      }\n\n      const { result: encodedItem, error: encodeError } = await this.encode(JSON.stringify(itemTemplate));\n      if (encodeError) throw encodeError;\n\n      const { stdout } = await this.exec([\"create\", \"item\", encodedItem], { resetVaultTimeout: true });\n      return { result: JSON.parse<Item>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to create login item\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async listFolders(): Promise<MaybeError<Folder[]>> {\n    try {\n      const { stdout } = await this.exec([\"list\", \"folders\"], { resetVaultTimeout: true });\n      return { result: JSON.parse<Folder[]>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to list folder\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async createFolder(name: string): Promise<MaybeError> {\n    try {\n      const { error, result: folder } = await this.getTemplate(\"folder\");\n      if (error) throw error;\n\n      folder.name = name;\n      const { result: encodedFolder, error: encodeError } = await this.encode(JSON.stringify(folder));\n      if (encodeError) throw encodeError;\n\n      await this.exec([\"create\", \"folder\", encodedFolder], { resetVaultTimeout: true });\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to create folder\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async getTotp(id: string): Promise<MaybeError<string>> {\n    try {\n      // this could return something like \"Not found.\" but checks for totp code are done before calling this function\n      const { stdout } = await this.exec([\"get\", \"totp\", id], { resetVaultTimeout: true });\n      return { result: stdout };\n    } catch (execError) {\n      captureException(\"Failed to get TOTP\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async status(): Promise<MaybeError<VaultState>> {\n    try {\n      const { stdout } = await this.exec([\"status\"], { resetVaultTimeout: false });\n      return { result: JSON.parse<VaultState>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to get status\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async checkLockStatus(): Promise<VaultStatus> {\n    try {\n      await this.exec([\"unlock\", \"--check\"], { resetVaultTimeout: false });\n      await this.saveLastVaultStatus(\"checkLockStatus\", \"unlocked\");\n      return \"unlocked\";\n    } catch (error) {\n      captureException(\"Failed to check lock status\", error);\n      const errorMessage = (error as ExecaError).stderr;\n      if (errorMessage === \"Vault is locked.\") {\n        await this.saveLastVaultStatus(\"checkLockStatus\", \"locked\");\n        return \"locked\";\n      }\n      await this.saveLastVaultStatus(\"checkLockStatus\", \"unauthenticated\");\n      return \"unauthenticated\";\n    }\n  }\n\n  async getTemplate<T = any>(type: string): Promise<MaybeError<T>> {\n    try {\n      const { stdout } = await this.exec([\"get\", \"template\", type], { resetVaultTimeout: true });\n      return { result: JSON.parse<T>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to get template\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async encode(input: string): Promise<MaybeError<string>> {\n    try {\n      const { stdout } = await this.exec([\"encode\"], { input, resetVaultTimeout: false });\n      return { result: stdout };\n    } catch (execError) {\n      captureException(\"Failed to encode\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async generatePassword(options?: PasswordGeneratorOptions, abortController?: AbortController): Promise<string> {\n    const args = options ? getPasswordGeneratingArgs(options) : [];\n    const { stdout } = await this.exec([\"generate\", ...args], { abortController, resetVaultTimeout: false });\n    return stdout;\n  }\n\n  async listSends(): Promise<MaybeError<Send[]>> {\n    try {\n      const { stdout } = await this.exec([\"send\", \"list\"], { resetVaultTimeout: true });\n      return { result: JSON.parse<Send[]>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to list sends\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async createSend(values: SendCreatePayload): Promise<MaybeError<Send>> {\n    try {\n      const { error: templateError, result: template } = await this.getTemplate(\n        values.type === SendType.Text ? \"send.text\" : \"send.file\"\n      );\n      if (templateError) throw templateError;\n\n      const payload = prepareSendPayload(template, values);\n      const { result: encodedPayload, error: encodeError } = await this.encode(JSON.stringify(payload));\n      if (encodeError) throw encodeError;\n\n      const { stdout } = await this.exec([\"send\", \"create\", encodedPayload], { resetVaultTimeout: true });\n\n      return { result: JSON.parse<Send>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to create send\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async editSend(values: SendCreatePayload): Promise<MaybeError<Send>> {\n    try {\n      const { result: encodedPayload, error: encodeError } = await this.encode(JSON.stringify(values));\n      if (encodeError) throw encodeError;\n\n      const { stdout } = await this.exec([\"send\", \"edit\", encodedPayload], { resetVaultTimeout: true });\n      return { result: JSON.parse<Send>(stdout) };\n    } catch (execError) {\n      captureException(\"Failed to delete send\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async deleteSend(id: string): Promise<MaybeError> {\n    try {\n      await this.exec([\"send\", \"delete\", id], { resetVaultTimeout: true });\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to delete send\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async removeSendPassword(id: string): Promise<MaybeError> {\n    try {\n      await this.exec([\"send\", \"remove-password\", id], { resetVaultTimeout: true });\n      return { result: undefined };\n    } catch (execError) {\n      captureException(\"Failed to remove send password\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async receiveSendInfo(url: string, options?: ReceiveSendOptions): Promise<MaybeError<ReceivedSend>> {\n    try {\n      const { stdout, stderr } = await this.exec([\"send\", \"receive\", url, \"--obj\"], {\n        resetVaultTimeout: true,\n        input: options?.password,\n      });\n      if (!stdout && /Invalid password/i.test(stderr)) return { error: new SendInvalidPasswordError() };\n      if (!stdout && /Send password/i.test(stderr)) return { error: new SendNeedsPasswordError() };\n\n      return { result: JSON.parse<ReceivedSend>(stdout) };\n    } catch (execError) {\n      const errorMessage = (execError as ExecaError).stderr;\n      if (/Invalid password/gi.test(errorMessage)) return { error: new SendInvalidPasswordError() };\n      if (/Send password/gi.test(errorMessage)) return { error: new SendNeedsPasswordError() };\n\n      captureException(\"Failed to receive send obj\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  async receiveSend(url: string, options?: ReceiveSendOptions): Promise<MaybeError<string>> {\n    try {\n      const { savePath, password } = options ?? {};\n      const args = [\"send\", \"receive\", url];\n      if (savePath) args.push(\"--output\", savePath);\n      const { stdout } = await this.exec(args, { resetVaultTimeout: true, input: password });\n      return { result: stdout };\n    } catch (execError) {\n      captureException(\"Failed to receive send\", execError);\n      const { error } = await this.handleCommonErrors(execError);\n      if (!error) throw execError;\n      return { error };\n    }\n  }\n\n  // utils below\n\n  async saveLastVaultStatus(callName: string, status: VaultStatus): Promise<void> {\n    await LocalStorage.setItem(LOCAL_STORAGE_KEY.VAULT_LAST_STATUS, status);\n  }\n\n  async getLastSavedVaultStatus(): Promise<VaultStatus | undefined> {\n    const lastSavedStatus = await LocalStorage.getItem<VaultStatus>(LOCAL_STORAGE_KEY.VAULT_LAST_STATUS);\n    if (!lastSavedStatus) {\n      const vaultStatus = await this.status();\n      return vaultStatus.result?.status;\n    }\n    return lastSavedStatus;\n  }\n\n  private isPromptWaitingForMasterPassword(result: ExecaReturnValue): boolean {\n    return !!(result.stderr && result.stderr.includes(\"Master password\"));\n  }\n\n  private async handlePostLogout(reason?: string): Promise<void> {\n    this.clearSessionToken();\n    await this.callActionListeners(\"logout\", reason);\n  }\n\n  private async handleCommonErrors(error: any): Promise<{ error?: ManuallyThrownError }> {\n    const errorMessage = (error as ExecaError).stderr;\n    if (!errorMessage) return {};\n\n    if (/not logged in/i.test(errorMessage)) {\n      await this.handlePostLogout();\n      return { error: new NotLoggedInError(\"Not logged in\") };\n    }\n    if (/Premium status/i.test(errorMessage)) {\n      return { error: new PremiumFeatureError() };\n    }\n    return {};\n  }\n\n  setActionListener<A extends keyof ActionListeners>(action: A, listener: ActionListeners[A]): this {\n    const listeners = this.actionListeners.get(action);\n    if (listeners && listeners.size > 0) {\n      listeners.add(listener);\n    } else {\n      this.actionListeners.set(action, new Set([listener]));\n    }\n    return this;\n  }\n\n  removeActionListener<A extends keyof ActionListeners>(action: A, listener: ActionListeners[A]): this {\n    const listeners = this.actionListeners.get(action);\n    if (listeners && listeners.size > 0) {\n      listeners.delete(listener);\n    }\n    return this;\n  }\n\n  private async callActionListeners<A extends keyof ActionListeners>(\n    action: A,\n    ...args: Parameters<NonNullable<ActionListeners[A]>>\n  ) {\n    const listeners = this.actionListeners.get(action);\n    if (listeners && listeners.size > 0) {\n      for (const listener of listeners) {\n        try {\n          await (listener as any)?.(...args);\n        } catch (error) {\n          captureException(`Error calling bitwarden action listener for ${action}`, error);\n        }\n      }\n    }\n  }\n\n  private showToast = async (toastOpts: Toast.Options): Promise<Toast & { restore: () => Promise<void> }> => {\n    if (this.toastInstance) {\n      const previousStateToastOpts: Toast.Options = {\n        message: this.toastInstance.message,\n        title: this.toastInstance.title,\n        primaryAction: this.toastInstance.primaryAction,\n        secondaryAction: this.toastInstance.secondaryAction,\n      };\n\n      if (toastOpts.style) this.toastInstance.style = toastOpts.style;\n      this.toastInstance.message = toastOpts.message;\n      this.toastInstance.title = toastOpts.title;\n      this.toastInstance.primaryAction = toastOpts.primaryAction;\n      this.toastInstance.secondaryAction = toastOpts.secondaryAction;\n      await this.toastInstance.show();\n\n      return Object.assign(this.toastInstance, {\n        restore: async () => {\n          await this.showToast(previousStateToastOpts);\n        },\n      });\n    } else {\n      const toast = await showToast(toastOpts);\n      return Object.assign(toast, { restore: () => toast.hide() });\n    }\n  };\n}\n", "import {Buffer} from 'node:buffer';\nimport path from 'node:path';\nimport childProcess from 'node:child_process';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport stripFinalNewline from 'strip-final-newline';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport onetime from 'onetime';\nimport {makeError} from './lib/error.js';\nimport {normalizeStdio, normalizeStdioNode} from './lib/stdio.js';\nimport {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} from './lib/kill.js';\nimport {handleInput, getSpawnedResult, makeAllStream, validateInputSync} from './lib/stream.js';\nimport {mergePromise, getSpawnedPromise} from './lib/promise.js';\nimport {joinCommand, parseCommand, getEscapedCommand} from './lib/command.js';\n\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal) {\n\t\treturn npmRunPathEnv({env, cwd: localDir, execPath});\n\t}\n\n\treturn env;\n};\n\nconst handleArguments = (file, args, options = {}) => {\n\tconst parsed = crossSpawn._parse(file, args, options);\n\tfile = parsed.command;\n\targs = parsed.args;\n\toptions = parsed.options;\n\n\toptions = {\n\t\tmaxBuffer: DEFAULT_MAX_BUFFER,\n\t\tbuffer: true,\n\t\tstripFinalNewline: true,\n\t\textendEnv: true,\n\t\tpreferLocal: false,\n\t\tlocalDir: options.cwd || process.cwd(),\n\t\texecPath: process.execPath,\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true,\n\t\tall: false,\n\t\twindowsHide: true,\n\t\t...options,\n\t};\n\n\toptions.env = getEnv(options);\n\n\toptions.stdio = normalizeStdio(options);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\targs.unshift('/q');\n\t}\n\n\treturn {file, args, options, parsed};\n};\n\nconst handleOutput = (options, value, error) => {\n\tif (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n\t\t// When `execaSync()` errors, we normalize it to '' to mimic `execa()`\n\t\treturn error === undefined ? undefined : '';\n\t}\n\n\tif (options.stripFinalNewline) {\n\t\treturn stripFinalNewline(value);\n\t}\n\n\treturn value;\n};\n\nexport function execa(file, args, options) {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\n\tvalidateTimeout(parsed.options);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\t// Ensure the returned error is always both a promise and a child process\n\t\tconst dummySpawned = new childProcess.ChildProcess();\n\t\tconst errorPromise = Promise.reject(makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t}));\n\t\treturn mergePromise(dummySpawned, errorPromise);\n\t}\n\n\tconst spawnedPromise = getSpawnedPromise(spawned);\n\tconst timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n\tconst processDone = setExitHandler(spawned, parsed.options, timedPromise);\n\n\tconst context = {isCanceled: false};\n\n\tspawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n\tspawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n\tconst handlePromise = async () => {\n\t\tconst [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n\t\tconst stdout = handleOutput(parsed.options, stdoutResult);\n\t\tconst stderr = handleOutput(parsed.options, stderrResult);\n\t\tconst all = handleOutput(parsed.options, allResult);\n\n\t\tif (error || exitCode !== 0 || signal !== null) {\n\t\t\tconst returnedError = makeError({\n\t\t\t\terror,\n\t\t\t\texitCode,\n\t\t\t\tsignal,\n\t\t\t\tstdout,\n\t\t\t\tstderr,\n\t\t\t\tall,\n\t\t\t\tcommand,\n\t\t\t\tescapedCommand,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut,\n\t\t\t\tisCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),\n\t\t\t\tkilled: spawned.killed,\n\t\t\t});\n\n\t\t\tif (!parsed.options.reject) {\n\t\t\t\treturn returnedError;\n\t\t\t}\n\n\t\t\tthrow returnedError;\n\t\t}\n\n\t\treturn {\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\texitCode: 0,\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\tall,\n\t\t\tfailed: false,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t};\n\t};\n\n\tconst handlePromiseOnce = onetime(handlePromise);\n\n\thandleInput(spawned, parsed.options.input);\n\n\tspawned.all = makeAllStream(spawned, parsed.options);\n\n\treturn mergePromise(spawned, handlePromiseOnce);\n}\n\nexport function execaSync(file, args, options) {\n\tconst parsed = handleArguments(file, args, options);\n\tconst command = joinCommand(file, args);\n\tconst escapedCommand = getEscapedCommand(file, args);\n\n\tvalidateInputSync(parsed.options);\n\n\tlet result;\n\ttry {\n\t\tresult = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\tthrow makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false,\n\t\t});\n\t}\n\n\tconst stdout = handleOutput(parsed.options, result.stdout, result.error);\n\tconst stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst error = makeError({\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\terror: result.error,\n\t\t\tsignal: result.signal,\n\t\t\texitCode: result.status,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tparsed,\n\t\t\ttimedOut: result.error && result.error.code === 'ETIMEDOUT',\n\t\t\tisCanceled: false,\n\t\t\tkilled: result.signal !== null,\n\t\t});\n\n\t\tif (!parsed.options.reject) {\n\t\t\treturn error;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\texitCode: 0,\n\t\tstdout,\n\t\tstderr,\n\t\tfailed: false,\n\t\ttimedOut: false,\n\t\tisCanceled: false,\n\t\tkilled: false,\n\t};\n}\n\nexport function execaCommand(command, options) {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa(file, args, options);\n}\n\nexport function execaCommandSync(command, options) {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execaSync(file, args, options);\n}\n\nexport function execaNode(scriptPath, args, options = {}) {\n\tif (args && !Array.isArray(args) && typeof args === 'object') {\n\t\toptions = args;\n\t\targs = [];\n\t}\n\n\tconst stdio = normalizeStdioNode(options);\n\tconst defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));\n\n\tconst {\n\t\tnodePath = process.execPath,\n\t\tnodeOptions = defaultExecArgv,\n\t} = options;\n\n\treturn execa(\n\t\tnodePath,\n\t\t[\n\t\t\t...nodeOptions,\n\t\t\tscriptPath,\n\t\t\t...(Array.isArray(args) ? args : []),\n\t\t],\n\t\t{\n\t\t\t...options,\n\t\t\tstdin: undefined,\n\t\t\tstdout: undefined,\n\t\t\tstderr: undefined,\n\t\t\tstdio,\n\t\t\tshell: false,\n\t\t},\n\t);\n}\n", "export default function stripFinalNewline(input) {\n\tconst LF = typeof input === 'string' ? '\\n' : '\\n'.charCodeAt();\n\tconst CR = typeof input === 'string' ? '\\r' : '\\r'.charCodeAt();\n\n\tif (input[input.length - 1] === LF) {\n\t\tinput = input.slice(0, -1);\n\t}\n\n\tif (input[input.length - 1] === CR) {\n\t\tinput = input.slice(0, -1);\n\t}\n\n\treturn input;\n}\n", "import process from 'node:process';\nimport path from 'node:path';\nimport url from 'node:url';\nimport pathKey from 'path-key';\n\nexport function npmRunPath(options = {}) {\n\tconst {\n\t\tcwd = process.cwd(),\n\t\tpath: path_ = process.env[pathKey()],\n\t\texecPath = process.execPath,\n\t} = options;\n\n\tlet previous;\n\tconst cwdString = cwd instanceof URL ? url.fileURLToPath(cwd) : cwd;\n\tlet cwdPath = path.resolve(cwdString);\n\tconst result = [];\n\n\twhile (previous !== cwdPath) {\n\t\tresult.push(path.join(cwdPath, 'node_modules/.bin'));\n\t\tprevious = cwdPath;\n\t\tcwdPath = path.resolve(cwdPath, '..');\n\t}\n\n\t// Ensure the running `node` binary is used.\n\tresult.push(path.resolve(cwdString, execPath, '..'));\n\n\treturn [...result, path_].join(path.delimiter);\n}\n\nexport function npmRunPathEnv({env = process.env, ...options} = {}) {\n\tenv = {...env};\n\n\tconst path = pathKey({env});\n\toptions.path = env[path];\n\tenv[path] = npmRunPath(options);\n\n\treturn env;\n}\n", "export default function pathKey(options = {}) {\n\tconst {\n\t\tenv = process.env,\n\t\tplatform = process.platform\n\t} = options;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n}\n", "const copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n// - one its descriptors is changed\n// - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nexport default function mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n}\n", "import mimicFunction from 'mimic-fn';\n\nconst calledFunctions = new WeakMap();\n\nconst onetime = (function_, options = {}) => {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError('Expected a function');\n\t}\n\n\tlet returnValue;\n\tlet callCount = 0;\n\tconst functionName = function_.displayName || function_.name || '<anonymous>';\n\n\tconst onetime = function (...arguments_) {\n\t\tcalledFunctions.set(onetime, ++callCount);\n\n\t\tif (callCount === 1) {\n\t\t\treturnValue = function_.apply(this, arguments_);\n\t\t\tfunction_ = null;\n\t\t} else if (options.throw === true) {\n\t\t\tthrow new Error(`Function \\`${functionName}\\` can only be called once`);\n\t\t}\n\n\t\treturn returnValue;\n\t};\n\n\tmimicFunction(onetime, function_);\n\tcalledFunctions.set(onetime, callCount);\n\n\treturn onetime;\n};\n\nonetime.callCount = function_ => {\n\tif (!calledFunctions.has(function_)) {\n\t\tthrow new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n\t}\n\n\treturn calledFunctions.get(function_);\n};\n\nexport default onetime;\n", "import{constants}from\"node:os\";\n\nimport{SIGRTMAX}from\"./realtime.js\";\nimport{getSignals}from\"./signals.js\";\n\n\n\nconst getSignalsByName=function(){\nconst signals=getSignals();\nreturn Object.fromEntries(signals.map(getSignalByName));\n};\n\nconst getSignalByName=function({\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard})\n{\nreturn[\nname,\n{name,number,description,supported,action,forced,standard}];\n\n};\n\nexport const signalsByName=getSignalsByName();\n\n\n\n\nconst getSignalsByNumber=function(){\nconst signals=getSignals();\nconst length=SIGRTMAX+1;\nconst signalsA=Array.from({length},(value,number)=>\ngetSignalByNumber(number,signals));\n\nreturn Object.assign({},...signalsA);\n};\n\nconst getSignalByNumber=function(number,signals){\nconst signal=findSignalByNumber(number,signals);\n\nif(signal===undefined){\nreturn{};\n}\n\nconst{name,description,supported,action,forced,standard}=signal;\nreturn{\n[number]:{\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard}};\n\n\n};\n\n\n\nconst findSignalByNumber=function(number,signals){\nconst signal=signals.find(({name})=>constants.signals[name]===number);\n\nif(signal!==undefined){\nreturn signal;\n}\n\nreturn signals.find((signalA)=>signalA.number===number);\n};\n\nexport const signalsByNumber=getSignalsByNumber();\n//# sourceMappingURL=main.js.map", "\nexport const getRealtimeSignals=function(){\nconst length=SIGRTMAX-SIGRTMIN+1;\nreturn Array.from({length},getRealtimeSignal);\n};\n\nconst getRealtimeSignal=function(value,index){\nreturn{\nname:`SIGRT${index+1}`,\nnumber:SIGRTMIN+index,\naction:\"terminate\",\ndescription:\"Application-specific signal (realtime)\",\nstandard:\"posix\"};\n\n};\n\nconst SIGRTMIN=34;\nexport const SIGRTMAX=64;\n//# sourceMappingURL=realtime.js.map", "import{constants}from\"node:os\";\n\nimport{SIGNALS}from\"./core.js\";\nimport{getRealtimeSignals}from\"./realtime.js\";\n\n\n\nexport const getSignals=function(){\nconst realtimeSignals=getRealtimeSignals();\nconst signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal);\nreturn signals;\n};\n\n\n\n\n\n\n\nconst normalizeSignal=function({\nname,\nnumber:defaultNumber,\ndescription,\naction,\nforced=false,\nstandard})\n{\nconst{\nsignals:{[name]:constantSignal}}=\nconstants;\nconst supported=constantSignal!==undefined;\nconst number=supported?constantSignal:defaultNumber;\nreturn{name,number,description,supported,action,forced,standard};\n};\n//# sourceMappingURL=signals.js.map", "\n\nexport const SIGNALS=[\n{\nname:\"SIGHUP\",\nnumber:1,\naction:\"terminate\",\ndescription:\"Terminal closed\",\nstandard:\"posix\"},\n\n{\nname:\"SIGINT\",\nnumber:2,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-C\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGQUIT\",\nnumber:3,\naction:\"core\",\ndescription:\"User interruption with CTRL-\\\\\",\nstandard:\"posix\"},\n\n{\nname:\"SIGILL\",\nnumber:4,\naction:\"core\",\ndescription:\"Invalid machine instruction\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGTRAP\",\nnumber:5,\naction:\"core\",\ndescription:\"Debugger breakpoint\",\nstandard:\"posix\"},\n\n{\nname:\"SIGABRT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGIOT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGBUS\",\nnumber:7,\naction:\"core\",\ndescription:\n\"Bus error due to misaligned, non-existing address or paging error\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGEMT\",\nnumber:7,\naction:\"terminate\",\ndescription:\"Command should be emulated but is not implemented\",\nstandard:\"other\"},\n\n{\nname:\"SIGFPE\",\nnumber:8,\naction:\"core\",\ndescription:\"Floating point arithmetic error\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGKILL\",\nnumber:9,\naction:\"terminate\",\ndescription:\"Forced termination\",\nstandard:\"posix\",\nforced:true},\n\n{\nname:\"SIGUSR1\",\nnumber:10,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"},\n\n{\nname:\"SIGSEGV\",\nnumber:11,\naction:\"core\",\ndescription:\"Segmentation fault\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGUSR2\",\nnumber:12,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"},\n\n{\nname:\"SIGPIPE\",\nnumber:13,\naction:\"terminate\",\ndescription:\"Broken pipe or socket\",\nstandard:\"posix\"},\n\n{\nname:\"SIGALRM\",\nnumber:14,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"posix\"},\n\n{\nname:\"SIGTERM\",\nnumber:15,\naction:\"terminate\",\ndescription:\"Termination\",\nstandard:\"ansi\"},\n\n{\nname:\"SIGSTKFLT\",\nnumber:16,\naction:\"terminate\",\ndescription:\"Stack is empty or overflowed\",\nstandard:\"other\"},\n\n{\nname:\"SIGCHLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"posix\"},\n\n{\nname:\"SIGCLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"other\"},\n\n{\nname:\"SIGCONT\",\nnumber:18,\naction:\"unpause\",\ndescription:\"Unpaused\",\nstandard:\"posix\",\nforced:true},\n\n{\nname:\"SIGSTOP\",\nnumber:19,\naction:\"pause\",\ndescription:\"Paused\",\nstandard:\"posix\",\nforced:true},\n\n{\nname:\"SIGTSTP\",\nnumber:20,\naction:\"pause\",\ndescription:\"Paused using CTRL-Z or \\\"suspend\\\"\",\nstandard:\"posix\"},\n\n{\nname:\"SIGTTIN\",\nnumber:21,\naction:\"pause\",\ndescription:\"Background process cannot read terminal input\",\nstandard:\"posix\"},\n\n{\nname:\"SIGBREAK\",\nnumber:21,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-BREAK\",\nstandard:\"other\"},\n\n{\nname:\"SIGTTOU\",\nnumber:22,\naction:\"pause\",\ndescription:\"Background process cannot write to terminal output\",\nstandard:\"posix\"},\n\n{\nname:\"SIGURG\",\nnumber:23,\naction:\"ignore\",\ndescription:\"Socket received out-of-band data\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGXCPU\",\nnumber:24,\naction:\"core\",\ndescription:\"Process timed out\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGXFSZ\",\nnumber:25,\naction:\"core\",\ndescription:\"File too big\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGVTALRM\",\nnumber:26,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGPROF\",\nnumber:27,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGWINCH\",\nnumber:28,\naction:\"ignore\",\ndescription:\"Terminal window size changed\",\nstandard:\"bsd\"},\n\n{\nname:\"SIGIO\",\nnumber:29,\naction:\"terminate\",\ndescription:\"I/O is available\",\nstandard:\"other\"},\n\n{\nname:\"SIGPOLL\",\nnumber:29,\naction:\"terminate\",\ndescription:\"Watched event\",\nstandard:\"other\"},\n\n{\nname:\"SIGINFO\",\nnumber:29,\naction:\"ignore\",\ndescription:\"Request for process information\",\nstandard:\"other\"},\n\n{\nname:\"SIGPWR\",\nnumber:30,\naction:\"terminate\",\ndescription:\"Device running out of power\",\nstandard:\"systemv\"},\n\n{\nname:\"SIGSYS\",\nnumber:31,\naction:\"core\",\ndescription:\"Invalid system call\",\nstandard:\"other\"},\n\n{\nname:\"SIGUNUSED\",\nnumber:31,\naction:\"terminate\",\ndescription:\"Invalid system call\",\nstandard:\"other\"}];\n//# sourceMappingURL=core.js.map", "import {signalsByName} from 'human-signals';\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nexport const makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}},\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.escapedCommand = escapedCommand;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n", "const aliases = ['stdin', 'stdout', 'stderr'];\n\nconst hasAlias = options => aliases.some(alias => options[alias] !== undefined);\n\nexport const normalizeStdio = options => {\n\tif (!options) {\n\t\treturn;\n\t}\n\n\tconst {stdio} = options;\n\n\tif (stdio === undefined) {\n\t\treturn aliases.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn stdio;\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, aliases.length);\n\treturn Array.from({length}, (value, index) => stdio[index]);\n};\n\n// `ipc` is pushed unless it is already present\nexport const normalizeStdioNode = options => {\n\tconst stdio = normalizeStdio(options);\n\n\tif (stdio === 'ipc') {\n\t\treturn 'ipc';\n\t}\n\n\tif (stdio === undefined || typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio, 'ipc'];\n\t}\n\n\tif (stdio.includes('ipc')) {\n\t\treturn stdio;\n\t}\n\n\treturn [...stdio, 'ipc'];\n};\n", "import os from 'node:os';\nimport onExit from 'signal-exit';\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nexport const spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n\nconst isSigterm = signal => signal === os.constants.signals.SIGTERM\n\t\t|| (typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nexport const spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nexport const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// `cleanup` option handling\nexport const setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n", "export function isStream(stream) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& typeof stream.pipe === 'function';\n}\n\nexport function isWritableStream(stream) {\n\treturn isStream(stream)\n\t\t&& stream.writable !== false\n\t\t&& typeof stream._write === 'function'\n\t\t&& typeof stream._writableState === 'object';\n}\n\nexport function isReadableStream(stream) {\n\treturn isStream(stream)\n\t\t&& stream.readable !== false\n\t\t&& typeof stream._read === 'function'\n\t\t&& typeof stream._readableState === 'object';\n}\n\nexport function isDuplexStream(stream) {\n\treturn isWritableStream(stream)\n\t\t&& isReadableStream(stream);\n}\n\nexport function isTransformStream(stream) {\n\treturn isDuplexStream(stream)\n\t\t&& typeof stream._transform === 'function';\n}\n", "import {isStream} from 'is-stream';\nimport getStream from 'get-stream';\nimport mergeStream from 'merge-stream';\n\n// `input` option\nexport const handleInput = (spawned, input) => {\n\tif (input === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\t// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\n\tif (!stream || streamPromise === undefined) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nexport const getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise),\n\t\t]);\n\t}\n};\n\nexport const validateInputSync = ({input}) => {\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n};\n", "// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nexport const mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function'\n\t\t\t? (...args) => Reflect.apply(descriptor.value, promise(), args)\n\t\t\t: descriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n\n\treturn spawned;\n};\n\n// Use promises instead of `child_process` events\nexport const getSpawnedPromise = spawned => new Promise((resolve, reject) => {\n\tspawned.on('exit', (exitCode, signal) => {\n\t\tresolve({exitCode, signal});\n\t});\n\n\tspawned.on('error', error => {\n\t\treject(error);\n\t});\n\n\tif (spawned.stdin) {\n\t\tspawned.stdin.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\t}\n});\n", "const normalizeArgs = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn [file];\n\t}\n\n\treturn [file, ...args];\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w.-]+$/;\nconst DOUBLE_QUOTES_REGEXP = /\"/g;\n\nconst escapeArg = arg => {\n\tif (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {\n\t\treturn arg;\n\t}\n\n\treturn `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;\n};\n\nexport const joinCommand = (file, args) => normalizeArgs(file, args).join(' ');\n\nexport const getEscapedCommand = (file, args) => normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');\n\nconst SPACES_REGEXP = / +/g;\n\n// Handle `execaCommand()`\nexport const parseCommand = command => {\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens[tokens.length - 1];\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\treturn tokens;\n};\n", "/* Put constants that you feel like they still don't deserve a file of their own here */\n\nimport { Icon, Keyboard } from \"@raycast/api\";\nimport { ItemType } from \"~/types/vault\";\n\nexport const DEFAULT_SERVER_URL = \"https://bitwarden.com\";\n\nexport const SENSITIVE_VALUE_PLACEHOLDER = \"HIDDEN-VALUE\";\n\nexport const LOCAL_STORAGE_KEY = {\n  PASSWORD_OPTIONS: \"bw-generate-password-options\",\n  PASSWORD_ONE_TIME_WARNING: \"bw-generate-password-warning-accepted\",\n  SESSION_TOKEN: \"sessionToken\",\n  REPROMPT_HASH: \"sessionRepromptHash\",\n  SERVER_URL: \"cliServer\",\n  LAST_ACTIVITY_TIME: \"lastActivityTime\",\n  VAULT_LOCK_REASON: \"vaultLockReason\",\n  VAULT_FAVORITE_ORDER: \"vaultFavoriteOrder\",\n  VAULT_LAST_STATUS: \"lastVaultStatus\",\n} as const;\n\nexport const VAULT_LOCK_MESSAGES = {\n  TIMEOUT: \"Vault timed out due to inactivity\",\n  MANUAL: \"Manually locked by the user\",\n  SYSTEM_LOCK: \"Screen was locked\",\n  SYSTEM_SLEEP: \"System went to sleep\",\n  CLI_UPDATED: \"Bitwarden has been updated. Please login again.\",\n} as const;\n\nexport const SHORTCUT_KEY_SEQUENCE: Keyboard.KeyEquivalent[] = [\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"+\",\n  \"-\",\n  \".\",\n  \",\",\n];\n\nexport const FOLDER_OPTIONS = {\n  ALL: \"all\",\n  NO_FOLDER: \"no-folder\",\n} as const;\n\nexport const CACHE_KEYS = {\n  IV: \"iv\",\n  VAULT: \"vault\",\n  CURRENT_FOLDER_ID: \"currentFolderId\",\n  SEND_TYPE_FILTER: \"sendTypeFilter\",\n  CLI_VERSION: \"cliVersion\",\n} as const;\n\nexport const ITEM_TYPE_TO_ICON_MAP: Record<ItemType, Icon> = {\n  [ItemType.LOGIN]: Icon.Globe,\n  [ItemType.CARD]: Icon.CreditCard,\n  [ItemType.IDENTITY]: Icon.Person,\n  [ItemType.NOTE]: Icon.Document,\n  [ItemType.SSH_KEY]: Icon.Key,\n};\n", "import { LocalStorage } from \"@raycast/api\";\nimport { pbkdf2 } from \"crypto\";\nimport { LOCAL_STORAGE_KEY } from \"~/constants/general\";\nimport { DEFAULT_PASSWORD_OPTIONS, REPROMPT_HASH_SALT } from \"~/constants/passwords\";\nimport { PasswordGeneratorOptions } from \"~/types/passwords\";\n\nexport function getPasswordGeneratingArgs(options: PasswordGeneratorOptions): string[] {\n  return Object.entries(options).flatMap(([arg, value]) => (value ? [`--${arg}`, value] : []));\n}\n\nexport function hashMasterPasswordForReprompting(password: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    pbkdf2(password, REPROMPT_HASH_SALT, 100000, 64, \"sha512\", (error, hashed) => {\n      if (error != null) {\n        reject(error);\n        return;\n      }\n\n      resolve(hashed.toString(\"hex\"));\n    });\n  });\n}\n\nexport async function getPasswordGeneratorOptions() {\n  const storedOptions = await LocalStorage.getItem<string>(LOCAL_STORAGE_KEY.PASSWORD_OPTIONS);\n  return {\n    ...DEFAULT_PASSWORD_OPTIONS,\n    ...(storedOptions ? JSON.parse(storedOptions) : {}),\n  } as PasswordGeneratorOptions;\n}\n", "import { PasswordGeneratorOptions } from \"~/types/passwords\";\n\nexport const REPROMPT_HASH_SALT = \"foobarbazzybaz\";\n\nexport const DEFAULT_PASSWORD_OPTIONS: Required<PasswordGeneratorOptions> = {\n  lowercase: true,\n  uppercase: true,\n  number: false,\n  special: false,\n  passphrase: false,\n  length: \"14\",\n  words: \"3\",\n  separator: \"-\",\n  capitalize: false,\n  includeNumber: false,\n  minNumber: \"1\",\n  minSpecial: \"1\",\n};\n", "import { environment, getPreferenceValues } from \"@raycast/api\";\nimport { VAULT_TIMEOUT_MS_TO_LABEL } from \"~/constants/labels\";\nimport { CommandName } from \"~/types/general\";\n\nexport function getServerUrlPreference(): string | undefined {\n  const { serverUrl } = getPreferenceValues<Preferences>();\n  return !serverUrl || serverUrl === \"bitwarden.com\" || serverUrl === \"https://bitwarden.com\" ? undefined : serverUrl;\n}\n\ntype PreferenceKeyOfCommandsWithTransientOptions =\n  | keyof Preferences.Search\n  | keyof Preferences.GeneratePassword\n  | keyof Preferences.GeneratePasswordQuick;\n\ntype TransientOptionsValue =\n  | Preferences.Search[\"transientCopySearch\"]\n  | Preferences.GeneratePassword[\"transientCopyGeneratePassword\"]\n  | Preferences.GeneratePasswordQuick[\"transientCopyGeneratePasswordQuick\"];\n\nconst COMMAND_NAME_TO_PREFERENCE_KEY_MAP: Record<CommandName, PreferenceKeyOfCommandsWithTransientOptions> = {\n  search: \"transientCopySearch\",\n  \"generate-password\": \"transientCopyGeneratePassword\",\n  \"generate-password-quick\": \"transientCopyGeneratePasswordQuick\",\n};\n\ntype Preferences = Preferences.Search & Preferences.GeneratePassword & Preferences.GeneratePasswordQuick;\n\nexport function getTransientCopyPreference(type: \"password\" | \"other\"): boolean {\n  const preferenceKey = COMMAND_NAME_TO_PREFERENCE_KEY_MAP[environment.commandName as CommandName];\n  const transientPreference = getPreferenceValues<Preferences>()[preferenceKey] as TransientOptionsValue;\n  if (transientPreference === \"never\") return false;\n  if (transientPreference === \"always\") return true;\n  if (transientPreference === \"passwords\") return type === \"password\";\n  return true;\n}\n\nexport function getLabelForTimeoutPreference(timeout: string | number): string | undefined {\n  return VAULT_TIMEOUT_MS_TO_LABEL[timeout as keyof typeof VAULT_TIMEOUT_MS_TO_LABEL];\n}\n", "const VAULT_TIMEOUT_OPTIONS = {\n  IMMEDIATELY: \"0\",\n  ONE_MINUTE: \"60000\",\n  FIVE_MINUTES: \"300000\",\n  FIFTEEN_MINUTES: \"900000\",\n  THIRTY_MINUTES: \"1800000\",\n  ONE_HOUR: \"3600000\",\n  FOUR_HOURS: \"14400000\",\n  EIGHT_HOURS: \"28800000\",\n  ONE_DAY: \"86400000\",\n  NEVER: \"-1\",\n  SYSTEM_LOCK: \"-2\",\n  SYSTEM_SLEEP: \"-3\",\n} as const satisfies Record<string, Preferences[\"repromptIgnoreDuration\"]>;\n\nexport const VAULT_TIMEOUT = Object.entries(VAULT_TIMEOUT_OPTIONS).reduce((acc, [key, value]) => {\n  acc[key as keyof typeof VAULT_TIMEOUT_OPTIONS] = parseInt(value);\n  return acc;\n}, {} as Record<keyof typeof VAULT_TIMEOUT_OPTIONS, number>);\n", "import { VAULT_TIMEOUT } from \"~/constants/preferences\";\nimport { Card, Identity, ItemType } from \"~/types/vault\";\n\nexport const VAULT_TIMEOUT_MS_TO_LABEL: Partial<Record<keyof typeof VAULT_TIMEOUT, string>> = {\n  [VAULT_TIMEOUT.IMMEDIATELY]: \"Immediately\",\n  [VAULT_TIMEOUT.ONE_MINUTE]: \"1 Minute\",\n  [VAULT_TIMEOUT.FIVE_MINUTES]: \"5 Minutes\",\n  [VAULT_TIMEOUT.FIFTEEN_MINUTES]: \"15 Minutes\",\n  [VAULT_TIMEOUT.THIRTY_MINUTES]: \"30 Minutes\",\n  [VAULT_TIMEOUT.ONE_HOUR]: \"1 Hour\",\n  [VAULT_TIMEOUT.FOUR_HOURS]: \"4 Hours\",\n  [VAULT_TIMEOUT.EIGHT_HOURS]: \"8 Hours\",\n  [VAULT_TIMEOUT.ONE_DAY]: \"1 Day\",\n};\n\nexport const CARD_KEY_LABEL: Record<keyof Card, string> = {\n  cardholderName: \"Cardholder name\",\n  brand: \"Brand\",\n  number: \"Number\",\n  expMonth: \"Expiration month\",\n  expYear: \"Expiration year\",\n  code: \"Security code (CVV)\",\n};\n\nexport const IDENTITY_KEY_LABEL: Record<keyof Identity, string> = {\n  title: \"Title\",\n  firstName: \"First name\",\n  middleName: \"Middle name\",\n  lastName: \"Last name\",\n  username: \"Username\",\n  company: \"Company\",\n  ssn: \"Social Security number\",\n  passportNumber: \"Passport number\",\n  licenseNumber: \"License number\",\n  email: \"Email\",\n  phone: \"Phone\",\n  address1: \"Address 1\",\n  address2: \"Address 2\",\n  address3: \"Address 3\",\n  city: \"City / Town\",\n  state: \"State / Province\",\n  postalCode: \"Zip / Postal code\",\n  country: \"Country\",\n};\n\nexport const ITEM_TYPE_TO_LABEL: Record<ItemType, string> = {\n  [ItemType.LOGIN]: \"Login\",\n  [ItemType.CARD]: \"Card\",\n  [ItemType.IDENTITY]: \"Identity\",\n  [ItemType.NOTE]: \"Secure Note\",\n  [ItemType.SSH_KEY]: \"SSH Key\",\n};\n", "export class ManuallyThrownError extends Error {\n  constructor(message: string, stack?: string) {\n    super(message);\n    this.stack = stack;\n  }\n}\n\nexport class DisplayableError extends ManuallyThrownError {\n  constructor(message: string, stack?: string) {\n    super(message, stack);\n  }\n}\n\n/* -- specific errors below -- */\n\nexport class CLINotFoundError extends DisplayableError {\n  constructor(message: string, stack?: string) {\n    super(message ?? \"Bitwarden CLI not found\", stack);\n    this.name = \"CLINotFoundError\";\n    this.stack = stack;\n  }\n}\n\nexport class InstalledCLINotFoundError extends DisplayableError {\n  constructor(message: string, stack?: string) {\n    super(message ?? \"Bitwarden CLI not found\", stack);\n    this.name = \"InstalledCLINotFoundError\";\n    this.stack = stack;\n  }\n}\n\nexport class FailedToLoadVaultItemsError extends ManuallyThrownError {\n  constructor(message?: string, stack?: string) {\n    super(message ?? \"Failed to load vault items\", stack);\n    this.name = \"FailedToLoadVaultItemsError\";\n  }\n}\n\nexport class VaultIsLockedError extends DisplayableError {\n  constructor(message?: string, stack?: string) {\n    super(message ?? \"Vault is locked\", stack);\n    this.name = \"VaultIsLockedError\";\n  }\n}\n\nexport class NotLoggedInError extends ManuallyThrownError {\n  constructor(message: string, stack?: string) {\n    super(message ?? \"Not logged in\", stack);\n    this.name = \"NotLoggedInError\";\n  }\n}\n\nexport class EnsureCliBinError extends DisplayableError {\n  constructor(message?: string, stack?: string) {\n    super(message ?? \"Failed do download Bitwarden CLI\", stack);\n    this.name = \"EnsureCliBinError\";\n  }\n}\n\nexport class PremiumFeatureError extends ManuallyThrownError {\n  constructor(message?: string, stack?: string) {\n    super(message ?? \"Premium status is required to use this feature\", stack);\n    this.name = \"PremiumFeatureError\";\n  }\n}\nexport class SendNeedsPasswordError extends ManuallyThrownError {\n  constructor(message?: string, stack?: string) {\n    super(message ?? \"This Send has a is protected by a password\", stack);\n    this.name = \"SendNeedsPasswordError\";\n  }\n}\n\nexport class SendInvalidPasswordError extends ManuallyThrownError {\n  constructor(message?: string, stack?: string) {\n    super(message ?? \"The password you entered is invalid\", stack);\n    this.name = \"SendInvalidPasswordError\";\n  }\n}\n\n/* -- error utils below -- */\n\nexport function tryExec<T>(fn: () => T): T extends void ? T : T | undefined;\nexport function tryExec<T, F>(fn: () => T, fallbackValue: F): T | F;\nexport function tryExec<T, F>(fn: () => T, fallbackValue?: F): T | F | undefined {\n  try {\n    return fn();\n  } catch {\n    return fallbackValue;\n  }\n}\n\nexport function getDisplayableErrorMessage(error: any) {\n  if (error instanceof DisplayableError) return error.message;\n  return undefined;\n}\n\nexport const getErrorString = (error: any): string | undefined => {\n  if (!error) return undefined;\n  if (typeof error === \"string\") return error;\n  if (error instanceof Error) {\n    const { message, name } = error;\n    if (error.stack) return error.stack;\n    return `${name}: ${message}`;\n  }\n  return String(error);\n};\n\nexport type Success<T> = [T, null];\nexport type Failure<E> = [null, E];\nexport type Result<T, E = Error> = Success<T> | Failure<E>;\n\nexport function Ok<T>(data: T): Success<T> {\n  return [data, null];\n}\nexport function Err<E = Error>(error: E): Failure<E> {\n  return [null, error];\n}\n\nexport function tryCatch<T, E = Error>(fn: () => T): Result<T, E>;\nexport function tryCatch<T, E = Error>(promise: Promise<T>): Promise<Result<T, E>>;\n/**\n * Executes a function or a promise safely inside a try/catch and\n * returns a `Result` (`[data, error]`).\n */\nexport function tryCatch<T, E = Error>(fnOrPromise: (() => T) | Promise<T>): MaybePromise<Result<T, E>> {\n  if (typeof fnOrPromise === \"function\") {\n    try {\n      return Ok(fnOrPromise());\n    } catch (error: any) {\n      return Err(error);\n    }\n  }\n  return fnOrPromise.then((data) => Ok(data)).catch((error) => Err(error));\n}\n", "import { existsSync, mkdirSync, statSync, unlinkSync } from \"fs\";\nimport { readdir, unlink } from \"fs/promises\";\nimport { join } from \"path\";\nimport streamZip from \"node-stream-zip\";\nimport { tryExec } from \"~/utils/errors\";\n\nexport function waitForFileAvailable(path: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const interval = setInterval(() => {\n      if (!existsSync(path)) return;\n      const stats = statSync(path);\n      if (stats.isFile()) {\n        clearInterval(interval);\n        resolve();\n      }\n    }, 300);\n\n    setTimeout(() => {\n      clearInterval(interval);\n      reject(new Error(`File ${path} not found.`));\n    }, 5000);\n  });\n}\n\nexport async function decompressFile(filePath: string, targetPath: string) {\n  const zip = new streamZip.async({ file: filePath });\n  if (!existsSync(targetPath)) mkdirSync(targetPath, { recursive: true });\n  await zip.extract(null, targetPath);\n  await zip.close();\n}\n\nexport async function removeFilesThatStartWith(startingWith: string, path: string) {\n  let removedAtLeastOne = false;\n  try {\n    const files = await readdir(path);\n    for await (const file of files) {\n      if (!file.startsWith(startingWith)) continue;\n      await tryExec(async () => {\n        await unlink(join(path, file));\n        removedAtLeastOne = true;\n      });\n    }\n  } catch {\n    return false;\n  }\n  return removedAtLeastOne;\n}\nexport function unlinkAllSync(...paths: string[]) {\n  for (const path of paths) {\n    tryExec(() => unlinkSync(path));\n  }\n}\n", "import { createWriteStream, unlink } from \"fs\";\nimport http from \"http\";\nimport https from \"https\";\nimport { captureException } from \"~/utils/development\";\nimport { getFileSha256 } from \"~/utils/crypto\";\nimport { waitForFileAvailable } from \"~/utils/fs\";\n\ntype DownloadOptions = {\n  onProgress?: (percent: number) => void;\n  sha256?: string;\n};\n\nexport function download(url: string, path: string, options?: DownloadOptions): Promise<void> {\n  const { onProgress, sha256 } = options ?? {};\n\n  return new Promise((resolve, reject) => {\n    const uri = new URL(url);\n    const protocol = uri.protocol === \"https:\" ? https : http;\n\n    let redirectCount = 0;\n    const request = protocol.get(uri.href, (response) => {\n      if (response.statusCode && response.statusCode >= 300 && response.statusCode < 400) {\n        request.destroy();\n        response.destroy();\n\n        const redirectUrl = response.headers.location;\n        if (!redirectUrl) {\n          reject(new Error(`Redirect response without location header`));\n          return;\n        }\n\n        if (++redirectCount >= 10) {\n          reject(new Error(\"Too many redirects\"));\n          return;\n        }\n\n        download(redirectUrl, path, options).then(resolve).catch(reject);\n        return;\n      }\n\n      if (response.statusCode !== 200) {\n        reject(new Error(`Response status ${response.statusCode}: ${response.statusMessage}`));\n        return;\n      }\n\n      const fileSize = parseInt(response.headers[\"content-length\"] || \"0\", 10);\n      if (fileSize === 0) {\n        reject(new Error(\"Invalid file size\"));\n        return;\n      }\n\n      const fileStream = createWriteStream(path, { autoClose: true });\n      let downloadedBytes = 0;\n\n      const cleanup = () => {\n        request.destroy();\n        response.destroy();\n        fileStream.close();\n      };\n\n      const cleanupAndReject = (error?: Error) => {\n        cleanup();\n        reject(error);\n      };\n\n      response.on(\"data\", (chunk) => {\n        downloadedBytes += chunk.length;\n        const percent = Math.floor((downloadedBytes / fileSize) * 100);\n        onProgress?.(percent);\n      });\n\n      fileStream.on(\"finish\", async () => {\n        try {\n          await waitForFileAvailable(path);\n          if (sha256) await waitForHashToMatch(path, sha256);\n          resolve();\n        } catch (error) {\n          reject(error);\n        } finally {\n          cleanup();\n        }\n      });\n\n      fileStream.on(\"error\", (error) => {\n        captureException(`File stream error while downloading ${url}`, error);\n        unlink(path, () => cleanupAndReject(error));\n      });\n\n      response.on(\"error\", (error) => {\n        captureException(`Response error while downloading ${url}`, error);\n        unlink(path, () => cleanupAndReject(error));\n      });\n\n      request.on(\"error\", (error) => {\n        captureException(`Request error while downloading ${url}`, error);\n        unlink(path, () => cleanupAndReject(error));\n      });\n\n      response.pipe(fileStream);\n    });\n  });\n}\n\nfunction waitForHashToMatch(path: string, sha256: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const fileSha = getFileSha256(path);\n    if (!fileSha) return reject(new Error(`Could not generate hash for file ${path}.`));\n    if (fileSha === sha256) return resolve();\n\n    const interval = setInterval(() => {\n      if (getFileSha256(path) === sha256) {\n        clearInterval(interval);\n        resolve();\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      clearInterval(interval);\n      reject(new Error(`Hash did not match, expected ${sha256.substring(0, 7)}, got ${fileSha.substring(0, 7)}.`));\n    }, 5000);\n  });\n}\n", "import { environment } from \"@raycast/api\";\nimport { getErrorString } from \"~/utils/errors\";\nimport { captureException as captureExceptionRaycast } from \"@raycast/api\";\n\ntype Log = {\n  message: string;\n  error: any;\n};\n\nconst _exceptions = {\n  logs: new Map<Date, Log>(),\n  set: (message: string, error?: any): void => {\n    capturedExceptions.logs.set(new Date(), { message, error });\n  },\n  clear: (): void => capturedExceptions.logs.clear(),\n  toString: (): string => {\n    let str = \"\";\n    capturedExceptions.logs.forEach((log, date) => {\n      if (str.length > 0) str += \"\\n\\n\";\n      str += `[${date.toISOString()}] ${log.message}`;\n      if (log.error) str += `: ${getErrorString(log.error)}`;\n    });\n\n    return str;\n  },\n};\n\nexport const capturedExceptions = Object.freeze(_exceptions);\n\ntype CaptureExceptionOptions = {\n  captureToRaycast?: boolean;\n};\n\nexport const captureException = (\n  description: string | Falsy | (string | Falsy)[],\n  error: any,\n  options?: CaptureExceptionOptions\n) => {\n  const { captureToRaycast = false } = options ?? {};\n  const desc = Array.isArray(description) ? description.filter(Boolean).join(\" \") : description || \"Captured exception\";\n  capturedExceptions.set(desc, error);\n  if (environment.isDevelopment) {\n    console.error(desc, error);\n  } else if (captureToRaycast) {\n    captureExceptionRaycast(error);\n  }\n};\n\nexport const debugLog = (...args: any[]) => {\n  if (!environment.isDevelopment) return;\n  console.debug(...args);\n};\n", "import { readFileSync } from \"fs\";\nimport { createHash } from \"crypto\";\n\nexport function getFileSha256(filePath: string): string | null {\n  try {\n    return createHash(\"sha256\").update(readFileSync(filePath)).digest(\"hex\");\n  } catch (error) {\n    return null;\n  }\n}\n", "import { SendCreatePayload } from \"~/types/send\";\n\nexport function prepareSendPayload(template: SendCreatePayload, values: SendCreatePayload): SendCreatePayload {\n  return {\n    ...template,\n    ...values,\n    file: values.file ? { ...template.file, ...values.file } : template.file,\n    text: values.text ? { ...template.text, ...values.text } : template.text,\n  };\n}\n", "import { Cache as RaycastCache } from \"@raycast/api\";\n\nexport const Cache = new RaycastCache({ namespace: \"bw-cache\" });\n", "export const platform = process.platform === \"darwin\" ? \"macos\" : \"windows\";\n", "import { Form } from \"@raycast/api\";\n\nexport const LoadingFallback = () => <Form isLoading />;\n", "import { ActionPanel, Action, Detail, getPreferenceValues, environment } from \"@raycast/api\";\nimport { BugReportCollectDataAction, BugReportOpenAction } from \"~/components/actions\";\nimport { BUG_REPORT_URL } from \"~/components/actions/BugReportOpenAction\";\nimport { EnsureCliBinError, InstalledCLINotFoundError, getErrorString } from \"~/utils/errors\";\nimport { platform } from \"~/utils/platform\";\n\nconst LINE_BREAK = \"\\n\\n\";\nconst CLI_INSTALLATION_HELP_URL = \"https://bitwarden.com/help/cli/#download-and-install\";\n\nconst getCodeBlock = (content: string) => `\\`\\`\\`\\n${content}\\n\\`\\`\\``;\n\ntype Messages = string | number | false | 0 | \"\" | null | undefined;\n\nexport type TroubleshootingGuideProps = {\n  error?: any;\n};\n\nconst TroubleshootingGuide = ({ error }: TroubleshootingGuideProps) => {\n  const errorString = getErrorString(error);\n  const localCliPath = getPreferenceValues<Preferences>().cliPath;\n  const isCliDownloadError = error instanceof EnsureCliBinError;\n  const needsToInstallCli = localCliPath || error instanceof InstalledCLINotFoundError;\n\n  const messages: Messages[] = [];\n\n  if (needsToInstallCli && !isCliDownloadError) {\n    messages.push(\"# \u26A0\uFE0F Bitwarden CLI not found\");\n  } else {\n    messages.push(\"# \uD83D\uDCA5 Whoops! Something went wrong\");\n  }\n\n  if (isCliDownloadError) {\n    messages.push(\n      `We couldn't download the [Bitwarden CLI](${CLI_INSTALLATION_HELP_URL}), you can always install it on your machine.`\n    );\n  } else if (needsToInstallCli) {\n    const cliPathString = localCliPath ? ` (${localCliPath})` : \"\";\n    messages.push(\n      `We couldn't find the [Bitwarden CLI](${CLI_INSTALLATION_HELP_URL}) installed on your machine${cliPathString}.`\n    );\n  } else {\n    messages.push(`The \\`${environment.commandName}\\` command crashed when we were not expecting it to.`);\n  }\n\n  messages.push(\n    \"> Please read the `Setup` section in the [extension's description](https://www.raycast.com/jomifepe/bitwarden) to ensure that everything is properly configured.\"\n  );\n\n  messages.push(\n    `**Try restarting the command. If the issue persists, consider [reporting a bug on GitHub](${BUG_REPORT_URL}) to help us fix it.**`\n  );\n\n  if (errorString) {\n    const isArchError = /incompatible architecture/gi.test(errorString);\n    messages.push(\n      \">## Technical details \uD83E\uDD13\",\n      isArchError &&\n        `\u26A0\uFE0F We suspect that your Bitwarden CLI was installed using a version of NodeJS that's incompatible with your system architecture (e.g. x64 NodeJS on a M1/Apple Silicon Mac). Please make sure your have the correct versions of your software installed (e.g., ${\n          platform === \"macos\" ? \"Homebrew, \" : \"\"\n        }NodeJS, and Bitwarden CLI).`,\n      getCodeBlock(errorString)\n    );\n  }\n\n  return (\n    <Detail\n      markdown={messages.filter(Boolean).join(LINE_BREAK)}\n      actions={\n        <ActionPanel>\n          <ActionPanel.Section title=\"Bug Report\">\n            <BugReportOpenAction />\n            <BugReportCollectDataAction />\n          </ActionPanel.Section>\n          {needsToInstallCli && (\n            <Action.OpenInBrowser title=\"Open Installation Guide\" url={CLI_INSTALLATION_HELP_URL} />\n          )}\n        </ActionPanel>\n      }\n    />\n  );\n};\n\nexport default TroubleshootingGuide;\n", "import { Action } from \"@raycast/api\";\nimport { useSelectedVaultItem } from \"~/components/searchVault/context/vaultItem\";\nimport useReprompt from \"~/utils/hooks/useReprompt\";\n\nexport type ActionWithRepromptProps = Omit<Action.Props, \"onAction\"> & {\n  repromptDescription?: string;\n  onAction: () => void | Promise<void>;\n};\n\nfunction ActionWithReprompt(props: ActionWithRepromptProps) {\n  const { repromptDescription, onAction, ...componentProps } = props;\n  const { reprompt } = useSelectedVaultItem();\n  const repromptAndPerformAction = useReprompt(onAction, { description: repromptDescription });\n\n  return <Action {...componentProps} onAction={reprompt ? repromptAndPerformAction : onAction} />;\n}\n\nexport default ActionWithReprompt;\n", "import { createContext, useContext } from \"react\";\nimport { Item } from \"~/types/vault\";\n\nconst VaultItemContext = createContext<Item | null>(null);\n\nexport const useSelectedVaultItem = () => {\n  const session = useContext(VaultItemContext);\n  if (session == null) {\n    throw new Error(\"useSelectVaultItem must be used within a VaultItemContext.Provider\");\n  }\n\n  return session;\n};\n\nexport default VaultItemContext;\n", "import { showToast, Toast, useNavigation } from \"@raycast/api\";\nimport RepromptForm from \"~/components/RepromptForm\";\nimport { useSession } from \"~/context/session\";\n\nexport type UserRepromptActionProp = { closeForm: () => void };\nexport type UseRepromptAction = (props: UserRepromptActionProp) => boolean | Promise<boolean>;\n\nexport type UseRepromptOptions = {\n  description?: string;\n};\n\n/**\n * Returns a function for an Action that will navigate to the {@link RepromptForm}.\n * The password is not confirm in this hook, only passed down to the action.\n */\nfunction useReprompt(action: () => void | Promise<void>, options?: UseRepromptOptions) {\n  const { description = \"Performing an action that requires the master password\" } = options ?? {};\n  const session = useSession();\n  const { push, pop } = useNavigation();\n\n  async function handleConfirm(password: string) {\n    const isPasswordCorrect = await session.confirmMasterPassword(password);\n    if (!isPasswordCorrect) {\n      await showToast(Toast.Style.Failure, \"Failed to unlock vault\", \"Check your credentials\");\n      return;\n    }\n    pop();\n\n    /* using a setTimeout here fixes a bug where the RepromptForm flashes when you pop back to the previous screen. \n    This comes with the trade-off of a tiny visible delay between the RepromptForm pop and the action pushing a new screen */\n    setTimeout(action, 1);\n  }\n\n  return () => push(<RepromptForm description={description} onConfirm={handleConfirm} />);\n}\n\nexport default useReprompt;\n", "import { Action, ActionPanel, Form } from \"@raycast/api\";\n\nexport type RepromptFormProps = {\n  description: string;\n  onConfirm: (password: string) => void;\n};\n\nconst RepromptForm = (props: RepromptFormProps) => {\n  const { description, onConfirm } = props;\n\n  function onSubmit(values: { password: string }) {\n    onConfirm(values.password);\n  }\n\n  return (\n    <Form\n      navigationTitle=\"Confirmation Required\"\n      actions={\n        <ActionPanel>\n          <Action.SubmitForm title=\"Confirm\" onSubmit={onSubmit} />\n        </ActionPanel>\n      }\n    >\n      <Form.Description title=\"Confirmation Required for\" text={description} />\n      <Form.PasswordField autoFocus id=\"password\" title=\"Master Password\" />\n    </Form>\n  );\n};\n\nexport default RepromptForm;\n", "import { LocalStorage, getPreferenceValues } from \"@raycast/api\";\nimport { createContext, PropsWithChildren, ReactNode, useContext, useMemo, useRef } from \"react\";\nimport UnlockForm from \"~/components/UnlockForm\";\nimport { VaultLoadingFallback } from \"~/components/searchVault/VaultLoadingFallback\";\nimport { LOCAL_STORAGE_KEY, VAULT_LOCK_MESSAGES } from \"~/constants/general\";\nimport { VAULT_TIMEOUT } from \"~/constants/preferences\";\nimport { useBitwarden } from \"~/context/bitwarden\";\nimport { useSessionReducer } from \"~/context/session/reducer\";\nimport {\n  checkSystemLockedSinceLastAccess,\n  checkSystemSleptSinceLastAccess,\n  SessionStorage,\n} from \"~/context/session/utils\";\nimport { SessionState } from \"~/types/session\";\nimport { Cache } from \"~/utils/cache\";\nimport { captureException } from \"~/utils/development\";\nimport useOnceEffect from \"~/utils/hooks/useOnceEffect\";\nimport { hashMasterPasswordForReprompting } from \"~/utils/passwords\";\nimport { platform } from \"~/utils/platform\";\n\nexport type Session = {\n  active: boolean;\n  confirmMasterPassword: (password: string) => Promise<boolean>;\n} & Pick<SessionState, \"token\" | \"isLoading\" | \"isLocked\" | \"isAuthenticated\">;\n\nexport const SessionContext = createContext<Session | null>(null);\n\nexport type SessionProviderProps = PropsWithChildren<{\n  loadingFallback?: ReactNode;\n  unlock?: boolean;\n}>;\n\n/**\n * Component which provides a session via the {@link useSession} hook.\n * @param props.unlock If true, an unlock form will be displayed if the vault is locked or unauthenticated.\n */\nexport function SessionProvider(props: SessionProviderProps) {\n  const { children, loadingFallback = <VaultLoadingFallback />, unlock } = props;\n\n  const bitwarden = useBitwarden();\n  const [state, dispatch] = useSessionReducer();\n  const pendingActionRef = useRef<Promise<any>>(Promise.resolve());\n\n  useOnceEffect(bootstrapSession, bitwarden);\n\n  async function bootstrapSession() {\n    try {\n      bitwarden\n        .setActionListener(\"lock\", handleLock)\n        .setActionListener(\"unlock\", handleUnlock)\n        .setActionListener(\"logout\", handleLogout);\n\n      const [token, passwordHash, lastActivityTimeString, lastVaultStatus] = await SessionStorage.getSavedSession();\n      if (!token || !passwordHash) throw new LockVaultError();\n\n      dispatch({ type: \"loadState\", token, passwordHash });\n      bitwarden.setSessionToken(token);\n\n      if (bitwarden.wasCliUpdated) throw new LogoutVaultError(VAULT_LOCK_MESSAGES.CLI_UPDATED);\n      if (lastVaultStatus === \"locked\") throw new LockVaultError();\n      if (lastVaultStatus === \"unauthenticated\") throw new LogoutVaultError();\n\n      if (lastActivityTimeString) {\n        const lastActivityTime = new Date(lastActivityTimeString);\n\n        const vaultTimeoutMs = +getPreferenceValues<Preferences>().repromptIgnoreDuration;\n        if (platform === \"macos\" && vaultTimeoutMs === VAULT_TIMEOUT.SYSTEM_LOCK) {\n          if (await checkSystemLockedSinceLastAccess(lastActivityTime)) {\n            throw new LockVaultError(VAULT_LOCK_MESSAGES.SYSTEM_LOCK);\n          }\n        } else if (platform === \"macos\" && vaultTimeoutMs === VAULT_TIMEOUT.SYSTEM_SLEEP) {\n          if (await checkSystemSleptSinceLastAccess(lastActivityTime)) {\n            throw new LockVaultError(VAULT_LOCK_MESSAGES.SYSTEM_SLEEP);\n          }\n        } else if (vaultTimeoutMs !== VAULT_TIMEOUT.NEVER) {\n          const timeElapseSinceLastActivity = Date.now() - lastActivityTime.getTime();\n          if (vaultTimeoutMs === VAULT_TIMEOUT.IMMEDIATELY || timeElapseSinceLastActivity >= vaultTimeoutMs) {\n            throw new LockVaultError(VAULT_LOCK_MESSAGES.TIMEOUT);\n          }\n        }\n      }\n\n      dispatch({ type: \"finishLoadingSavedState\" });\n    } catch (error) {\n      if (error instanceof LockVaultError) {\n        pendingActionRef.current = bitwarden.lock({ reason: error.message, immediate: true, checkVaultStatus: true });\n      } else if (error instanceof LogoutVaultError) {\n        pendingActionRef.current = bitwarden.logout({ reason: error.message, immediate: true });\n      } else {\n        pendingActionRef.current = bitwarden.lock({ immediate: true });\n        dispatch({ type: \"failLoadingSavedState\" });\n        captureException(\"Failed to bootstrap session state\", error);\n      }\n    }\n  }\n\n  async function handleUnlock(password: string, token: string) {\n    const passwordHash = await hashMasterPasswordForReprompting(password);\n    await SessionStorage.saveSession(token, passwordHash);\n    await LocalStorage.removeItem(LOCAL_STORAGE_KEY.VAULT_LOCK_REASON);\n    dispatch({ type: \"unlock\", token, passwordHash });\n  }\n\n  async function handleLock(reason?: string) {\n    await SessionStorage.clearSession();\n    if (reason) await LocalStorage.setItem(LOCAL_STORAGE_KEY.VAULT_LOCK_REASON, reason);\n    dispatch({ type: \"lock\" });\n  }\n\n  async function handleLogout(reason?: string) {\n    await SessionStorage.clearSession();\n    Cache.clear();\n    if (reason) await LocalStorage.setItem(LOCAL_STORAGE_KEY.VAULT_LOCK_REASON, reason);\n    dispatch({ type: \"logout\" });\n  }\n\n  async function confirmMasterPassword(password: string): Promise<boolean> {\n    const enteredPasswordHash = await hashMasterPasswordForReprompting(password);\n    return enteredPasswordHash === state.passwordHash;\n  }\n\n  const contextValue: Session = useMemo(\n    () => ({\n      token: state.token,\n      isLoading: state.isLoading,\n      isAuthenticated: state.isAuthenticated,\n      isLocked: state.isLocked,\n      active: !state.isLoading && state.isAuthenticated && !state.isLocked,\n      confirmMasterPassword,\n    }),\n    [state, confirmMasterPassword]\n  );\n\n  if (state.isLoading) return loadingFallback;\n\n  const showUnlockForm = state.isLocked || !state.isAuthenticated;\n  const _children = state.token ? children : null;\n\n  return (\n    <SessionContext.Provider value={contextValue}>\n      {showUnlockForm && unlock ? <UnlockForm pendingAction={pendingActionRef.current} /> : _children}\n    </SessionContext.Provider>\n  );\n}\n\nexport function useSession(): Session {\n  const session = useContext(SessionContext);\n  if (session == null) {\n    throw new Error(\"useSession must be used within a SessionProvider\");\n  }\n\n  return session;\n}\n\nclass LockVaultError extends Error {\n  constructor(lockReason?: string) {\n    super(lockReason);\n  }\n}\n\nclass LogoutVaultError extends Error {\n  constructor(lockReason?: string) {\n    super(lockReason);\n  }\n}\n", "import { Action, ActionPanel, Clipboard, Form, getPreferenceValues, Icon, showToast, Toast } from \"@raycast/api\";\nimport { useState } from \"react\";\nimport { DebuggingBugReportingActionSection } from \"~/components/actions\";\nimport { LOCAL_STORAGE_KEY } from \"~/constants/general\";\nimport { useBitwarden } from \"~/context/bitwarden\";\nimport { treatError } from \"~/utils/debug\";\nimport { captureException } from \"~/utils/development\";\nimport useVaultMessages from \"~/utils/hooks/useVaultMessages\";\nimport { useLocalStorageItem } from \"~/utils/localstorage\";\nimport { platform } from \"~/utils/platform\";\nimport { getLabelForTimeoutPreference } from \"~/utils/preferences\";\n\ntype UnlockFormProps = {\n  pendingAction?: Promise<void>;\n};\n\n/** Form for unlocking or logging in to the Bitwarden vault. */\nconst UnlockForm = ({ pendingAction = Promise.resolve() }: UnlockFormProps) => {\n  const bitwarden = useBitwarden();\n  const { userMessage, serverMessage, shouldShowServer } = useVaultMessages();\n\n  const [isLoading, setLoading] = useState(false);\n  const [unlockError, setUnlockError] = useState<string | undefined>(undefined);\n  const [showPassword, setShowPassword] = useState(false);\n  const [password, setPassword] = useState(\"\");\n  const [lockReason, { remove: clearLockReason }] = useLocalStorageItem(LOCAL_STORAGE_KEY.VAULT_LOCK_REASON);\n\n  async function onSubmit() {\n    if (password.length === 0) return;\n\n    const toast = await showToast(Toast.Style.Animated, \"Unlocking Vault...\", \"Please wait\");\n    try {\n      setLoading(true);\n      setUnlockError(undefined);\n\n      await pendingAction;\n\n      const { error, result: vaultState } = await bitwarden.status();\n      if (error) throw error;\n\n      if (vaultState.status === \"unauthenticated\") {\n        try {\n          const { error } = await bitwarden.login();\n          if (error) throw error;\n        } catch (error) {\n          const {\n            displayableError = `Please check your ${shouldShowServer ? \"Server URL, \" : \"\"}API Key and Secret.`,\n            treatedError,\n          } = getUsefulError(error, password);\n          await showToast(Toast.Style.Failure, \"Failed to log in\", displayableError);\n          setUnlockError(treatedError);\n          captureException(\"Failed to log in\", error);\n          return;\n        }\n      }\n\n      await bitwarden.unlock(password);\n      await clearLockReason();\n      await toast.hide();\n    } catch (error) {\n      const { displayableError = \"Please check your credentials\", treatedError } = getUsefulError(error, password);\n      await showToast(Toast.Style.Failure, \"Failed to unlock vault\", displayableError);\n      setUnlockError(treatedError);\n      captureException(\"Failed to unlock vault\", error);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  const copyUnlockError = async () => {\n    if (!unlockError) return;\n    await Clipboard.copy(unlockError);\n    await showToast(Toast.Style.Success, \"Error copied to clipboard\");\n  };\n\n  let PasswordField = Form.PasswordField;\n  let passwordFieldId = \"password\";\n  if (showPassword) {\n    PasswordField = Form.TextField;\n    passwordFieldId = \"plainPassword\";\n  }\n\n  return (\n    <Form\n      actions={\n        <ActionPanel>\n          {!isLoading && (\n            <>\n              <Action.SubmitForm icon={Icon.LockUnlocked} title=\"Unlock\" onSubmit={onSubmit} />\n              <Action\n                icon={showPassword ? Icon.EyeDisabled : Icon.Eye}\n                title={showPassword ? \"Hide Password\" : \"Show Password\"}\n                onAction={() => setShowPassword((prev) => !prev)}\n                shortcut={{ macOS: { key: \"e\", modifiers: [\"opt\"] }, windows: { key: \"e\", modifiers: [\"alt\"] } }}\n              />\n            </>\n          )}\n          {!!unlockError && (\n            <Action\n              onAction={copyUnlockError}\n              title=\"Copy Last Error\"\n              icon={Icon.Bug}\n              style={Action.Style.Destructive}\n            />\n          )}\n          <DebuggingBugReportingActionSection />\n        </ActionPanel>\n      }\n    >\n      {shouldShowServer && <Form.Description title=\"Server URL\" text={serverMessage} />}\n      <Form.Description title=\"Vault Status\" text={userMessage} />\n      <PasswordField\n        id={passwordFieldId}\n        title=\"Master Password\"\n        value={password}\n        onChange={setPassword}\n        ref={(field) => field?.focus()}\n      />\n      <Form.Description\n        title=\"\"\n        text={`Press ${platform === \"macos\" ? \"\u2325\" : \"Alt\"}+E to ${showPassword ? \"hide\" : \"show\"} password`}\n      />\n      {!!lockReason && (\n        <>\n          <Form.Description title=\"\u2139\uFE0F\" text={lockReason} />\n          <TimeoutInfoDescription />\n        </>\n      )}\n    </Form>\n  );\n};\n\nfunction TimeoutInfoDescription() {\n  const vaultTimeoutMs = getPreferenceValues<AllPreferences>().repromptIgnoreDuration;\n  const timeoutLabel = getLabelForTimeoutPreference(vaultTimeoutMs);\n\n  if (!timeoutLabel) return null;\n  return (\n    <Form.Description\n      title=\"\"\n      text={`Timeout is set to ${timeoutLabel}, this can be configured in the extension settings`}\n    />\n  );\n}\n\nfunction getUsefulError(error: unknown, password: string) {\n  const treatedError = treatError(error, { omitSensitiveValue: password });\n  let displayableError: string | undefined;\n  if (/Invalid master password/i.test(treatedError)) {\n    displayableError = \"Invalid master password\";\n  } else if (/Invalid API Key/i.test(treatedError)) {\n    displayableError = \"Invalid Client ID or Secret\";\n  }\n  return { displayableError, treatedError };\n}\n\nexport default UnlockForm;\n", "export type ObjectEntries<Obj> = { [Key in keyof Obj]: [Key, Obj[Key]] }[keyof Obj][];\n\n/** `Object.entries` with typed keys */\nexport function objectEntries<T extends object>(obj: T) {\n  return Object.entries(obj) as ObjectEntries<T>;\n}\n\nexport function isObject(obj: unknown): obj is object {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\n", "import { ExecaError } from \"execa\";\nimport { isObject } from \"~/utils/objects\";\n\nexport function treatError(error: unknown, options?: { omitSensitiveValue: string }) {\n  try {\n    const execaError = error as ExecaError;\n    let errorString: string | undefined;\n    if (execaError?.stderr) {\n      errorString = execaError.stderr;\n    } else if (error instanceof Error) {\n      errorString = `${error.name}: ${error.message}`;\n    } else if (isObject(error)) {\n      errorString = JSON.stringify(error);\n    } else {\n      errorString = `${error}`;\n    }\n\n    if (!errorString) return \"\";\n    if (!options?.omitSensitiveValue) return errorString;\n\n    return omitSensitiveValueFromString(errorString, options.omitSensitiveValue);\n  } catch {\n    return \"\";\n  }\n}\n\nexport function omitSensitiveValueFromString(value: string, sensitiveValue: string) {\n  return value.replace(new RegExp(sensitiveValue, \"i\"), \"[REDACTED]\");\n}\n", "import { Alert, closeMainWindow, confirmAlert, Icon, popToRoot } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport { useBitwarden } from \"~/context/bitwarden\";\nimport { VaultState } from \"~/types/general\";\nimport { getServerUrlPreference } from \"~/utils/preferences\";\n\nfunction useVaultMessages() {\n  const bitwarden = useBitwarden();\n  const [vaultState, setVaultState] = useState<VaultState | null>(null);\n\n  useEffect(() => {\n    void bitwarden\n      .status()\n      .then(({ error, result }) => {\n        if (!error) setVaultState(result);\n      })\n      .catch(() => {\n        /* ignore */\n      });\n  }, []);\n\n  const shouldShowServer = !!getServerUrlPreference();\n\n  let userMessage = \"...\";\n  let serverMessage = \"...\";\n\n  if (vaultState) {\n    const { status, userEmail, serverUrl } = vaultState;\n    userMessage = status == \"unauthenticated\" ? \"\u274C Logged out\" : `\uD83D\uDD12 Locked (${userEmail})`;\n    if (serverUrl) {\n      serverMessage = serverUrl || \"\";\n    } else if ((!serverUrl && shouldShowServer) || (serverUrl && !shouldShowServer)) {\n      // Hosted state not in sync with CLI (we don't check for equality)\n      void confirmAlert({\n        icon: Icon.ExclamationMark,\n        title: \"Restart Required\",\n        message: \"Bitwarden server URL preference has been changed since the extension was opened.\",\n        primaryAction: {\n          title: \"Close Extension\",\n        },\n        dismissAction: {\n          title: \"Close Raycast\", // Only here to provide the necessary second option\n          style: Alert.ActionStyle.Cancel,\n        },\n      }).then((closeExtension) => {\n        if (closeExtension) {\n          void popToRoot();\n        } else {\n          void closeMainWindow();\n        }\n      });\n    }\n  }\n\n  return { userMessage, serverMessage, shouldShowServer };\n}\n\nexport default useVaultMessages;\n", "import { LocalStorage } from \"@raycast/api\";\nimport { usePromise } from \"@raycast/utils\";\n\ntype LocalStorageItemActions = {\n  isLoading: boolean;\n  set: (value: string) => Promise<void>;\n  remove: () => Promise<void>;\n};\n\n/** Read and manage a single item in LocalStorage. */\nexport function useLocalStorageItem(key: string): [string | undefined, LocalStorageItemActions];\nexport function useLocalStorageItem(key: string, defaultValue: string): [string, LocalStorageItemActions];\nexport function useLocalStorageItem(key: string, defaultValue?: string) {\n  const { data: value, revalidate, isLoading } = usePromise(() => LocalStorage.getItem<string>(key));\n\n  const set = async (value: string) => {\n    await LocalStorage.setItem(key, value);\n    await revalidate();\n  };\n\n  const remove = async () => {\n    await LocalStorage.removeItem(key);\n    await revalidate();\n  };\n\n  return [value ?? defaultValue, { isLoading, set, remove }] as const;\n}\n", "var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n", "/// <reference types=\"node\" />\n\nexport { usePromise } from \"./usePromise\";\nexport { useCachedState } from \"./useCachedState\";\nexport { useCachedPromise } from \"./useCachedPromise\";\nexport { useFetch } from \"./useFetch\";\nexport { useExec } from \"./useExec\";\nexport { useStreamJSON } from \"./useStreamJSON\";\nexport { useSQL } from \"./useSQL\";\nexport { useForm, FormValidation } from \"./useForm\";\nexport { useAI } from \"./useAI\";\nexport { useFrecencySorting } from \"./useFrecencySorting\";\nexport { useLocalStorage } from \"./useLocalStorage\";\n\nexport { getAvatarIcon, getFavicon, getProgressIcon } from \"./icon\";\n\nexport { OAuthService, withAccessToken, getAccessToken } from \"./oauth\";\n\nexport { createDeeplink, createExtensionDeeplink, createScriptCommandDeeplink, DeeplinkType } from \"./createDeeplink\";\nexport { executeSQL } from \"./executeSQL\";\nexport { runAppleScript } from \"./run-applescript\";\nexport { runPowerShellScript } from \"./run-powershell-script\";\nexport { showFailureToast } from \"./showFailureToast\";\nexport { withCache } from \"./cache\";\n\nexport type { PromiseOptions } from \"./usePromise\";\nexport type { CachedPromiseOptions } from \"./useCachedPromise\";\nexport type {\n  OAuthServiceOptions,\n  OnAuthorizeParams,\n  WithAccessTokenComponentOrFn,\n  ProviderWithDefaultClientOptions,\n  ProviderOptions,\n} from \"./oauth\";\nexport type { AsyncState, MutatePromise } from \"./types\";\n", "import { useEffect, useCallback, RefObject, useRef, useState } from \"react\";\nimport { environment, LaunchType, Toast } from \"@raycast/api\";\nimport { useDeepMemo } from \"./useDeepMemo\";\nimport {\n  FunctionReturningPromise,\n  MutatePromise,\n  UsePromiseReturnType,\n  AsyncState,\n  FunctionReturningPaginatedPromise,\n  UnwrapReturn,\n  PaginationOptions,\n} from \"./types\";\nimport { useLatest } from \"./useLatest\";\nimport { showFailureToast } from \"./showFailureToast\";\n\nexport type PromiseOptions<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise> = {\n  /**\n   * A reference to an `AbortController` to cancel a previous call when triggering a new one\n   */\n  abortable?: RefObject<AbortController | null | undefined>;\n  /**\n   * Whether to actually execute the function or not.\n   * This is useful for cases where one of the function's arguments depends on something that\n   * might not be available right away (for example, depends on some user inputs). Because React requires\n   * every hooks to be defined on the render, this flag enables you to define the hook right away but\n   * wait util you have all the arguments ready to execute the function.\n   */\n  execute?: boolean;\n  /**\n   * Options for the generic failure toast.\n   * It allows you to customize the title, message, and primary action of the failure toast.\n   */\n  failureToastOptions?: Partial<Pick<Toast.Options, \"title\" | \"primaryAction\" | \"message\">>;\n  /**\n   * Called when an execution fails. By default it will log the error and show\n   * a generic failure toast.\n   */\n  onError?: (error: Error) => void | Promise<void>;\n  /**\n   * Called when an execution succeeds.\n   */\n  onData?: (data: UnwrapReturn<T>, pagination?: PaginationOptions<UnwrapReturn<T>>) => void | Promise<void>;\n  /**\n   * Called when an execution will start\n   */\n  onWillExecute?: (parameters: Parameters<T>) => void;\n};\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise in another function, and returns the {@link AsyncState} corresponding to the execution of the function.\n *\n * @remark This overload should be used when working with paginated data sources.\n *\n * @example\n * ```\n * import { setTimeout } from \"node:timers/promises\";\n * import { useState } from \"react\";\n * import { List } from \"@raycast/api\";\n * import { usePromise } from \"@raycast/utils\";\n *\n * export default function Command() {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const { isLoading, data, pagination } = usePromise(\n *     (searchText: string) => async (options: { page: number }) => {\n *       await setTimeout(200);\n *       const newData = Array.from({ length: 25 }, (_v, index) => ({\n *         index,\n *         page: options.page,\n *         text: searchText,\n *       }));\n *       return { data: newData, hasMore: options.page < 10 };\n *     },\n *     [searchText]\n *   );\n *\n *   return (\n *     <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>\n *       {data?.map((item) => (\n *         <List.Item\n *           key={`${item.page} ${item.index} ${item.text}`}\n *           title={`Page ${item.page} Item ${item.index}`}\n *           subtitle={item.text}\n *         />\n *       ))}\n *     </List>\n *   );\n * };\n * ```\n */\nexport function usePromise<T extends FunctionReturningPaginatedPromise<[]>>(\n  fn: T,\n): UsePromiseReturnType<UnwrapReturn<T>>;\nexport function usePromise<T extends FunctionReturningPaginatedPromise>(\n  fn: T,\n  args: Parameters<T>,\n  options?: PromiseOptions<T>,\n): UsePromiseReturnType<UnwrapReturn<T>>;\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function.\n *\n * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).\n *\n * @example\n * ```\n * import { usePromise } from '@raycast/utils';\n *\n * export default function Command() {\n *   const abortable = useRef<AbortController>();\n *   const { isLoading, data, revalidate } = usePromise(async (url: string) => {\n *     const response = await fetch(url, { signal: abortable.current?.signal });\n *     const result = await response.text();\n *     return result\n *   },\n *   ['https://api.example'],\n *   {\n *     abortable\n *   });\n *\n *   return (\n *     <Detail\n *       isLoading={isLoading}\n *       markdown={data}\n *       actions={\n *         <ActionPanel>\n *           <Action title=\"Reload\" onAction={() => revalidate()} />\n *         </ActionPanel>\n *       }\n *     />\n *   );\n * };\n * ```\n */\nexport function usePromise<T extends FunctionReturningPromise<[]>>(fn: T): UsePromiseReturnType<UnwrapReturn<T>>;\nexport function usePromise<T extends FunctionReturningPromise>(\n  fn: T,\n  args: Parameters<T>,\n  options?: PromiseOptions<T>,\n): UsePromiseReturnType<UnwrapReturn<T>>;\n\nexport function usePromise<T extends FunctionReturningPromise | FunctionReturningPaginatedPromise>(\n  fn: T,\n  args?: Parameters<T>,\n  options?: PromiseOptions<T>,\n): UsePromiseReturnType<any> {\n  const lastCallId = useRef(0);\n  const [state, set] = useState<AsyncState<UnwrapReturn<T>>>({ isLoading: true });\n\n  const fnRef = useLatest(fn);\n  const latestAbortable = useLatest(options?.abortable);\n  const latestArgs = useLatest(args || []);\n  const latestOnError = useLatest(options?.onError);\n  const latestOnData = useLatest(options?.onData);\n  const latestOnWillExecute = useLatest(options?.onWillExecute);\n  const latestFailureToast = useLatest(options?.failureToastOptions);\n  const latestValue = useLatest(state.data);\n  const latestCallback = useRef<(...args: Parameters<T>) => Promise<UnwrapReturn<T>>>(null);\n\n  const paginationArgsRef = useRef<PaginationOptions>({ page: 0 });\n  const usePaginationRef = useRef(false);\n  const hasMoreRef = useRef(true);\n  const pageSizeRef = useRef(50);\n\n  const abort = useCallback(() => {\n    if (latestAbortable.current) {\n      latestAbortable.current.current?.abort();\n      latestAbortable.current.current = new AbortController();\n    }\n    return ++lastCallId.current;\n  }, [latestAbortable]);\n\n  const callback = useCallback(\n    (...args: Parameters<T>): Promise<UnwrapReturn<T>> => {\n      const callId = abort();\n\n      latestOnWillExecute.current?.(args);\n\n      set((prevState) => ({ ...prevState, isLoading: true }));\n\n      const promiseOrPaginatedPromise = bindPromiseIfNeeded(fnRef.current)(...args);\n\n      function handleError(error: any) {\n        if (error.name == \"AbortError\") {\n          return error;\n        }\n\n        if (callId === lastCallId.current) {\n          // handle errors\n          if (latestOnError.current) {\n            latestOnError.current(error);\n          } else {\n            if (environment.launchType !== LaunchType.Background) {\n              showFailureToast(error, {\n                title: \"Failed to fetch latest data\",\n                primaryAction: {\n                  title: \"Retry\",\n                  onAction(toast) {\n                    toast.hide();\n                    latestCallback.current?.(...((latestArgs.current || []) as Parameters<T>));\n                  },\n                },\n                ...latestFailureToast.current,\n              });\n            }\n          }\n          set({ error, isLoading: false });\n        }\n\n        return error;\n      }\n\n      if (typeof promiseOrPaginatedPromise === \"function\") {\n        usePaginationRef.current = true;\n        return promiseOrPaginatedPromise(paginationArgsRef.current).then(\n          // @ts-expect-error too complicated for TS\n          ({ data, hasMore, cursor }: { data: UnwrapReturn<T>; hasMore: boolean; cursor?: any }) => {\n            if (callId === lastCallId.current) {\n              if (paginationArgsRef.current) {\n                paginationArgsRef.current.cursor = cursor;\n                paginationArgsRef.current.lastItem = data?.[data.length - 1];\n              }\n\n              if (latestOnData.current) {\n                latestOnData.current(data, paginationArgsRef.current);\n              }\n\n              if (hasMore) {\n                pageSizeRef.current = data.length;\n              }\n              hasMoreRef.current = hasMore;\n\n              set((previousData) => {\n                if (paginationArgsRef.current.page === 0) {\n                  return { data, isLoading: false };\n                }\n                // @ts-expect-error we know it's an array here\n                return { data: (previousData.data || [])?.concat(data), isLoading: false };\n              });\n            }\n\n            return data;\n          },\n          (error: unknown) => {\n            hasMoreRef.current = false;\n            return handleError(error);\n          },\n        ) as Promise<UnwrapReturn<T>>;\n      }\n\n      usePaginationRef.current = false;\n      return promiseOrPaginatedPromise.then((data: UnwrapReturn<T>) => {\n        if (callId === lastCallId.current) {\n          if (latestOnData.current) {\n            latestOnData.current(data);\n          }\n          set({ data, isLoading: false });\n        }\n\n        return data;\n      }, handleError) as Promise<UnwrapReturn<T>>;\n    },\n    [\n      latestOnData,\n      latestOnError,\n      latestArgs,\n      fnRef,\n      set,\n      latestCallback,\n      latestOnWillExecute,\n      paginationArgsRef,\n      latestFailureToast,\n      abort,\n    ],\n  );\n\n  latestCallback.current = callback;\n\n  const revalidate = useCallback(() => {\n    // reset the pagination\n    paginationArgsRef.current = { page: 0 };\n\n    const args = (latestArgs.current || []) as Parameters<T>;\n    return callback(...args);\n  }, [callback, latestArgs]);\n\n  const mutate = useCallback<MutatePromise<Awaited<ReturnType<T>>, undefined>>(\n    async (asyncUpdate, options) => {\n      let dataBeforeOptimisticUpdate: Awaited<ReturnType<T>> | undefined;\n      try {\n        if (options?.optimisticUpdate) {\n          // cancel the in-flight request to make sure it won't overwrite the optimistic update\n          abort();\n\n          if (typeof options?.rollbackOnError !== \"function\" && options?.rollbackOnError !== false) {\n            // keep track of the data before the optimistic update,\n            // but only if we need it (eg. only when we want to automatically rollback after)\n            dataBeforeOptimisticUpdate = structuredClone(latestValue.current?.value);\n          }\n          const update = options.optimisticUpdate;\n          set((prevState) => ({ ...prevState, data: update(prevState.data) }));\n        }\n        return await asyncUpdate;\n      } catch (err) {\n        if (typeof options?.rollbackOnError === \"function\") {\n          const update = options.rollbackOnError;\n          set((prevState) => ({ ...prevState, data: update(prevState.data) }));\n        } else if (options?.optimisticUpdate && options?.rollbackOnError !== false) {\n          set((prevState) => ({ ...prevState, data: dataBeforeOptimisticUpdate }));\n        }\n        throw err;\n      } finally {\n        if (options?.shouldRevalidateAfter !== false) {\n          if (environment.launchType === LaunchType.Background || environment.commandMode === \"menu-bar\") {\n            // when in the background or in a menu bar, we are going to await the revalidation\n            // to make sure we get the right data at the end of the mutation\n            await revalidate();\n          } else {\n            revalidate();\n          }\n        }\n      }\n    },\n    [revalidate, latestValue, set, abort],\n  );\n\n  const onLoadMore = useCallback(() => {\n    paginationArgsRef.current.page += 1;\n    const args = (latestArgs.current || []) as Parameters<T>;\n    callback(...args);\n  }, [paginationArgsRef, latestArgs, callback]);\n\n  // revalidate when the args change\n  useEffect(() => {\n    // reset the pagination\n    paginationArgsRef.current = { page: 0 };\n\n    if (options?.execute !== false) {\n      callback(...((args || []) as Parameters<T>));\n    } else {\n      // cancel the previous request if we don't want to execute anymore\n      abort();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [useDeepMemo([args, options?.execute, callback]), latestAbortable, paginationArgsRef]);\n\n  // abort request when unmounting\n  useEffect(() => {\n    return () => {\n      abort();\n    };\n  }, [abort]);\n\n  // we only want to show the loading indicator if the promise is executing\n  const isLoading = options?.execute !== false ? state.isLoading : false;\n\n  // @ts-expect-error loading is has some fixed value in the enum which\n  const stateWithLoadingFixed: AsyncState<Awaited<ReturnType<T>>> = { ...state, isLoading };\n\n  const pagination = usePaginationRef.current\n    ? {\n        pageSize: pageSizeRef.current,\n        hasMore: hasMoreRef.current,\n        onLoadMore,\n      }\n    : undefined;\n\n  return { ...stateWithLoadingFixed, revalidate, mutate, pagination };\n}\n\n/** Bind the fn if it's a Promise method */\nfunction bindPromiseIfNeeded<T>(fn: T): T {\n  if (fn === (Promise.all as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise);\n  }\n  if (fn === (Promise.race as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise);\n  }\n  if (fn === (Promise.resolve as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise as any);\n  }\n  if (fn === (Promise.reject as any)) {\n    // @ts-expect-error this is fine\n    return fn.bind(Promise);\n  }\n  return fn;\n}\n", "import { useRef, useMemo } from \"react\";\nimport { dequal } from \"dequal/lite\";\n\n/**\n * @param value the value to be memoized (usually a dependency list)\n * @returns a memoized version of the value as long as it remains deeply equal\n */\nexport function useDeepMemo<T>(value: T) {\n  const ref = useRef<T>(value);\n  const signalRef = useRef<number>(0);\n\n  if (!dequal(value, ref.current)) {\n    ref.current = value;\n    signalRef.current += 1;\n  }\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return useMemo(() => ref.current, [signalRef.current]);\n}\n", "import { useRef } from \"react\";\n\n/**\n * Returns the latest state.\n *\n * This is mostly useful to get access to the latest value of some props or state inside an asynchronous callback, instead of that value at the time the callback was created from.\n */\nexport function useLatest<T>(value: T): { readonly current: T } {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n}\n", "import * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport { Clipboard, environment, open, Toast, showToast } from \"@raycast/api\";\n\n/**\n * Shows a failure Toast for a given Error.\n *\n * @example\n * ```typescript\n * import { showHUD } from \"@raycast/api\";\n * import { runAppleScript, showFailureToast } from \"@raycast/utils\";\n *\n * export default async function () {\n *   try {\n *     const res = await runAppleScript(\n *       `\n *       on run argv\n *         return \"hello, \" & item 1 of argv & \".\"\n *       end run\n *       `,\n *       [\"world\"]\n *     );\n *     await showHUD(res);\n *   } catch (error) {\n *     showFailureToast(error, { title: \"Could not run AppleScript\" });\n *   }\n * }\n * ```\n */\nexport function showFailureToast(\n  error: unknown,\n  options?: Partial<Pick<Toast.Options, \"title\" | \"primaryAction\" | \"message\">>,\n) {\n  const message = error instanceof Error ? error.message : String(error);\n  return showToast({\n    style: Toast.Style.Failure,\n    title: options?.title ?? \"Something went wrong\",\n    message: options?.message ?? message,\n    primaryAction: options?.primaryAction ?? handleErrorToastAction(error),\n    secondaryAction: options?.primaryAction ? handleErrorToastAction(error) : undefined,\n  });\n}\n\nconst handleErrorToastAction = (error: unknown): Toast.ActionOptions => {\n  let privateExtension = true;\n  let title = \"[Extension Name]...\";\n  let extensionURL = \"\";\n  try {\n    const packageJSON = JSON.parse(fs.readFileSync(path.join(environment.assetsPath, \"..\", \"package.json\"), \"utf8\"));\n    title = `[${packageJSON.title}]...`;\n    extensionURL = `https://raycast.com/${packageJSON.owner || packageJSON.author}/${packageJSON.name}`;\n    if (!packageJSON.owner || packageJSON.access === \"public\") {\n      privateExtension = false;\n    }\n  } catch (err) {\n    // no-op\n  }\n\n  // if it's a private extension, we can't construct the URL to report the error\n  // so we fallback to copying the error to the clipboard\n  const fallback = environment.isDevelopment || privateExtension;\n\n  const stack = error instanceof Error ? error?.stack || error?.message || \"\" : String(error);\n\n  return {\n    title: fallback ? \"Copy Logs\" : \"Report Error\",\n    onAction(toast) {\n      toast.hide();\n      if (fallback) {\n        Clipboard.copy(stack);\n      } else {\n        open(\n          `https://github.com/raycast/extensions/issues/new?&labels=extension%2Cbug&template=extension_bug_report.yml&title=${encodeURIComponent(\n            title,\n          )}&extension-url=${encodeURI(extensionURL)}&description=${encodeURIComponent(\n            `#### Error:\n\\`\\`\\`\n${stack}\n\\`\\`\\`\n`,\n          )}`,\n        );\n      }\n    },\n  };\n};\n", "import { useCallback, Dispatch, SetStateAction, useSyncExternalStore, useMemo } from \"react\";\nimport { Cache } from \"@raycast/api\";\nimport { useLatest } from \"./useLatest\";\nimport { replacer, reviver } from \"./helpers\";\n\nconst rootCache = /* #__PURE__ */ Symbol(\"cache without namespace\");\nconst cacheMap = /* #__PURE__ */ new Map<string | symbol, Cache>();\n\n/**\n * Returns a stateful value, and a function to update it. The value will be kept between command runs.\n *\n * @remark The value needs to be JSON serializable.\n *\n * @param key - The unique identifier of the state. This can be used to share the state across components and/or commands.\n * @param initialState - The initial value of the state if there aren't any in the Cache yet.\n */\nexport function useCachedState<T>(\n  key: string,\n  initialState: T,\n  config?: { cacheNamespace?: string },\n): [T, Dispatch<SetStateAction<T>>];\nexport function useCachedState<T = undefined>(key: string): [T | undefined, Dispatch<SetStateAction<T | undefined>>];\nexport function useCachedState<T>(\n  key: string,\n  initialState?: T,\n  config?: { cacheNamespace?: string },\n): [T, Dispatch<SetStateAction<T>>] {\n  const cacheKey = config?.cacheNamespace || rootCache;\n  const cache =\n    cacheMap.get(cacheKey) || cacheMap.set(cacheKey, new Cache({ namespace: config?.cacheNamespace })).get(cacheKey);\n\n  if (!cache) {\n    throw new Error(\"Missing cache\");\n  }\n\n  const keyRef = useLatest(key);\n  const initialValueRef = useLatest(initialState);\n\n  const cachedState = useSyncExternalStore(cache.subscribe, () => {\n    try {\n      return cache.get(keyRef.current);\n    } catch (error) {\n      console.error(\"Could not get Cache data:\", error);\n      return undefined;\n    }\n  });\n\n  const state = useMemo(() => {\n    if (typeof cachedState !== \"undefined\") {\n      if (cachedState === \"undefined\") {\n        return undefined;\n      }\n      try {\n        return JSON.parse(cachedState, reviver);\n      } catch (err) {\n        // the data got corrupted somehow\n        console.warn(\"The cached data is corrupted\", err);\n        return initialValueRef.current;\n      }\n    } else {\n      return initialValueRef.current;\n    }\n  }, [cachedState, initialValueRef]);\n\n  const stateRef = useLatest(state);\n\n  const setStateAndCache = useCallback(\n    (updater: SetStateAction<T>) => {\n      // @ts-expect-error TS struggles to infer the types as T could potentially be a function\n      const newValue = typeof updater === \"function\" ? updater(stateRef.current) : updater;\n      if (typeof newValue === \"undefined\") {\n        cache.set(keyRef.current, \"undefined\");\n      } else {\n        const stringifiedValue = JSON.stringify(newValue, replacer);\n        cache.set(keyRef.current, stringifiedValue);\n      }\n      return newValue;\n    },\n    [cache, keyRef, stateRef],\n  );\n\n  return [state, setStateAndCache];\n}\n", "import crypto from \"node:crypto\";\nimport { typeHasher } from \"./vendors/type-hasher\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function replacer(this: any, key: string, _value: unknown) {\n  const value = this[key];\n  if (value instanceof Date) {\n    return `__raycast_cached_date__${value.toISOString()}`;\n  }\n  if (Buffer.isBuffer(value)) {\n    return `__raycast_cached_buffer__${value.toString(\"base64\")}`;\n  }\n  return _value;\n}\n\nexport function reviver(_key: string, value: unknown) {\n  if (typeof value === \"string\" && value.startsWith(\"__raycast_cached_date__\")) {\n    return new Date(value.replace(\"__raycast_cached_date__\", \"\"));\n  }\n  if (typeof value === \"string\" && value.startsWith(\"__raycast_cached_buffer__\")) {\n    return Buffer.from(value.replace(\"__raycast_cached_buffer__\", \"\"), \"base64\");\n  }\n  return value;\n}\n\nexport function hash(object: any) {\n  const hashingStream = crypto.createHash(\"sha1\");\n  const hasher = typeHasher(hashingStream);\n  hasher.dispatch(object);\n\n  return hashingStream.digest(\"hex\");\n}\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport crypto from \"node:crypto\";\n\n/** Check if the given function is a native function */\nfunction isNativeFunction(f: any) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  const exp = /^function\\s+\\w*\\s*\\(\\s*\\)\\s*{\\s+\\[native code\\]\\s+}$/i;\n  return exp.exec(Function.prototype.toString.call(f)) !== null;\n}\n\nfunction hashReplacer(value: any): string {\n  if (value instanceof URLSearchParams) {\n    return value.toString();\n  }\n  return value;\n}\n\nexport function typeHasher(\n  writeTo:\n    | crypto.Hash\n    | {\n        buf: string;\n        write: (b: any) => void;\n        end: (b: any) => void;\n        read: () => string;\n      },\n  context: any[] = [],\n) {\n  function write(str: string) {\n    if (\"update\" in writeTo) {\n      return writeTo.update(str, \"utf8\");\n    } else {\n      return writeTo.write(str);\n    }\n  }\n\n  return {\n    dispatch: function (value: any) {\n      value = hashReplacer(value);\n\n      const type = typeof value;\n      if (value === null) {\n        this[\"_null\"]();\n      } else {\n        // @ts-ignore\n        this[\"_\" + type](value);\n      }\n    },\n    _object: function (object: any) {\n      const pattern = /\\[object (.*)\\]/i;\n      const objString = Object.prototype.toString.call(object);\n      let objType = pattern.exec(objString)?.[1] ?? \"unknown:[\" + objString + \"]\";\n      objType = objType.toLowerCase();\n\n      let objectNumber = null as any;\n\n      if ((objectNumber = context.indexOf(object)) >= 0) {\n        this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n        return;\n      } else {\n        context.push(object);\n      }\n\n      if (Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        // @ts-ignore\n        if (this[\"_\" + objType]) {\n          // @ts-ignore\n          this[\"_\" + objType](object);\n        } else {\n          throw new Error('Unknown object type \"' + objType + '\"');\n        }\n      } else {\n        let keys = Object.keys(object);\n        keys = keys.sort();\n        // Make sure to incorporate special properties, so\n        // Types with different prototypes will produce\n        // a different hash and objects derived from\n        // different functions (`new Foo`, `new Bar`) will\n        // produce different hashes.\n        // We never do this for native functions since some\n        // seem to break because of that.\n        if (!isNativeFunction(object)) {\n          keys.splice(0, 0, \"prototype\", \"__proto__\", \"constructor\");\n        }\n\n        write(\"object:\" + keys.length + \":\");\n        const self = this;\n        return keys.forEach(function (key) {\n          self.dispatch(key);\n          write(\":\");\n          self.dispatch(object[key]);\n          write(\",\");\n        });\n      }\n    },\n    _array: function (arr: any[], unordered: boolean) {\n      unordered = typeof unordered !== \"undefined\" ? unordered : false; // default to options.unorderedArrays\n\n      const self = this;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        arr.forEach(function (entry: any) {\n          self.dispatch(entry);\n        });\n        return;\n      }\n\n      // the unordered case is a little more complicated:\n      // since there is no canonical ordering on objects,\n      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,\n      // we first serialize each entry using a PassThrough stream\n      // before sorting.\n      // also: we cant use the same context array for all entries\n      // since the order of hashing should *not* matter. instead,\n      // we keep track of the additions to a copy of the context array\n      // and add all of them to the global context array when were done\n      let contextAdditions: any[] = [];\n      const entries = arr.map(function (entry: any) {\n        const strm = PassThrough();\n        const localContext = context.slice(); // make copy\n        const hasher = typeHasher(strm, localContext);\n        hasher.dispatch(entry);\n        // take only what was added to localContext and append it to contextAdditions\n        contextAdditions = contextAdditions.concat(localContext.slice(context.length));\n        return strm.read().toString();\n      });\n      context = context.concat(contextAdditions);\n      entries.sort();\n      this._array(entries, false);\n    },\n    _date: function (date: Date) {\n      write(\"date:\" + date.toJSON());\n    },\n    _symbol: function (sym: symbol) {\n      write(\"symbol:\" + sym.toString());\n    },\n    _error: function (err: Error) {\n      write(\"error:\" + err.toString());\n    },\n    _boolean: function (bool: boolean) {\n      write(\"bool:\" + bool.toString());\n    },\n    _string: function (string: string) {\n      write(\"string:\" + string.length + \":\");\n      write(string.toString());\n    },\n    _function: function (fn: any) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n\n      // Make sure we can still distinguish native functions\n      // by their name, otherwise String and Function will\n      // have the same hash\n      this.dispatch(\"function-name:\" + String(fn.name));\n\n      this._object(fn);\n    },\n    _number: function (number: number) {\n      write(\"number:\" + number.toString());\n    },\n    _xml: function (xml: any) {\n      write(\"xml:\" + xml.toString());\n    },\n    _null: function () {\n      write(\"Null\");\n    },\n    _undefined: function () {\n      write(\"Undefined\");\n    },\n    _regexp: function (regex: RegExp) {\n      write(\"regex:\" + regex.toString());\n    },\n    _uint8array: function (arr: Uint8Array) {\n      write(\"uint8array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint8clampedarray: function (arr: Uint8ClampedArray) {\n      write(\"uint8clampedarray:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int8array: function (arr: Int8Array) {\n      write(\"int8array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint16array: function (arr: Uint16Array) {\n      write(\"uint16array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int16array: function (arr: Int16Array) {\n      write(\"int16array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _uint32array: function (arr: Uint32Array) {\n      write(\"uint32array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _int32array: function (arr: Int32Array) {\n      write(\"int32array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float32array: function (arr: Float32Array) {\n      write(\"float32array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _float64array: function (arr: Float64Array) {\n      write(\"float64array:\");\n      this.dispatch(Array.prototype.slice.call(arr));\n    },\n    _arraybuffer: function (arr: ArrayBuffer) {\n      write(\"arraybuffer:\");\n      this.dispatch(new Uint8Array(arr));\n    },\n    _url: function (url: URL) {\n      write(\"url:\" + url.toString());\n    },\n    _map: function (map: Map<any, any>) {\n      write(\"map:\");\n      const arr = Array.from(map);\n      this._array(arr, true);\n    },\n    _set: function (set: Set<any>) {\n      write(\"set:\");\n      const arr = Array.from(set);\n      this._array(arr, true);\n    },\n    _file: function (file: any) {\n      write(\"file:\");\n      this.dispatch([file.name, file.size, file.type, file.lastModified]);\n    },\n    _blob: function () {\n      throw Error(\n        \"Hashing Blob objects is currently not supported\\n\" +\n          \"(see https://github.com/puleos/object-hash/issues/26)\\n\" +\n          'Use \"options.replacer\" or \"options.ignoreUnknown\"\\n',\n      );\n    },\n    _domwindow: function () {\n      write(\"domwindow\");\n    },\n    _bigint: function (number: bigint) {\n      write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    _process: function () {\n      write(\"process\");\n    },\n    _timer: function () {\n      write(\"timer\");\n    },\n    _pipe: function () {\n      write(\"pipe\");\n    },\n    _tcp: function () {\n      write(\"tcp\");\n    },\n    _udp: function () {\n      write(\"udp\");\n    },\n    _tty: function () {\n      write(\"tty\");\n    },\n    _statwatcher: function () {\n      write(\"statwatcher\");\n    },\n    _securecontext: function () {\n      write(\"securecontext\");\n    },\n    _connection: function () {\n      write(\"connection\");\n    },\n    _zlib: function () {\n      write(\"zlib\");\n    },\n    _context: function () {\n      write(\"context\");\n    },\n    _nodescript: function () {\n      write(\"nodescript\");\n    },\n    _httpparser: function () {\n      write(\"httpparser\");\n    },\n    _dataview: function () {\n      write(\"dataview\");\n    },\n    _signal: function () {\n      write(\"signal\");\n    },\n    _fsevent: function () {\n      write(\"fsevent\");\n    },\n    _tlswrap: function () {\n      write(\"tlswrap\");\n    },\n  };\n}\n\n// Mini-implementation of stream.PassThrough\n// We are far from having need for the full implementation, and we can\n// make assumptions like \"many writes, then only one final read\"\n// and we can ignore encoding specifics\nfunction PassThrough() {\n  return {\n    buf: \"\",\n\n    write: function (b: string) {\n      this.buf += b;\n    },\n\n    end: function (b: string) {\n      this.buf += b;\n    },\n\n    read: function () {\n      return this.buf;\n    },\n  };\n}\n", "import { useEffect, useRef, useCallback } from \"react\";\nimport {\n  FunctionReturningPromise,\n  UseCachedPromiseReturnType,\n  MutatePromise,\n  FunctionReturningPaginatedPromise,\n  UnwrapReturn,\n  PaginationOptions,\n} from \"./types\";\nimport { useCachedState } from \"./useCachedState\";\nimport { usePromise, PromiseOptions } from \"./usePromise\";\nimport { useLatest } from \"./useLatest\";\nimport { hash } from \"./helpers\";\n\n// Symbol to differentiate an empty cache from `undefined`\nconst emptyCache = /* #__PURE__ */ Symbol();\n\nexport type CachedPromiseOptions<\n  T extends FunctionReturningPromise | FunctionReturningPaginatedPromise,\n  U,\n> = PromiseOptions<T> & {\n  /**\n   * The initial data if there aren't any in the Cache yet.\n   */\n  initialData?: U;\n  /**\n   * Tells the hook to keep the previous results instead of returning the initial value\n   * if there aren't any in the cache for the new arguments.\n   * This is particularly useful when used for data for a List to avoid flickering.\n   */\n  keepPreviousData?: boolean;\n};\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise in another function, and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.\n *\n * @remark This overload should be used when working with paginated data sources.\n * @remark When paginating, only the first page will be cached.\n *\n * @example\n * ```\n * import { setTimeout } from \"node:timers/promises\";\n * import { useState } from \"react\";\n * import { List } from \"@raycast/api\";\n * import { useCachedPromise } from \"@raycast/utils\";\n *\n * export default function Command() {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const { isLoading, data, pagination } = useCachedPromise(\n *     (searchText: string) => async (options: { page: number }) => {\n *       await setTimeout(200);\n *       const newData = Array.from({ length: 25 }, (_v, index) => ({\n *         index,\n *         page: options.page,\n *         text: searchText,\n *       }));\n *       return { data: newData, hasMore: options.page < 10 };\n *     },\n *     [searchText],\n *   );\n *\n *   return (\n *     <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>\n *       {data?.map((item) => (\n *         <List.Item\n *           key={`${item.page} ${item.index} ${item.text}`}\n *           title={`Page ${item.page} Item ${item.index}`}\n *           subtitle={item.text}\n *         />\n *       ))}\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useCachedPromise<T extends FunctionReturningPaginatedPromise<[]>>(\n  fn: T,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, undefined>;\nexport function useCachedPromise<T extends FunctionReturningPaginatedPromise, U extends any[] = any[]>(\n  fn: T,\n  args: Parameters<T>,\n  options?: CachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, U>;\n\n/**\n * Wraps an asynchronous function or a function that returns a Promise and returns the {@link AsyncState} corresponding to the execution of the function. The last value will be kept between command runs.\n *\n * @remark The value needs to be JSON serializable.\n * @remark The function is assumed to be constant (eg. changing it won't trigger a revalidation).\n *\n * @example\n * ```\n * import { useCachedPromise } from '@raycast/utils';\n *\n * export default function Command() {\n *   const abortable = useRef<AbortController>();\n *   const { isLoading, data, revalidate } = useCachedPromise(async (url: string) => {\n *     const response = await fetch(url, { signal: abortable.current?.signal });\n *     const result = await response.text();\n *     return result\n *   },\n *   ['https://api.example'],\n *   {\n *     abortable\n *   });\n *\n *   return (\n *     <Detail\n *       isLoading={isLoading}\n *       markdown={data}\n *       actions={\n *         <ActionPanel>\n *           <Action title=\"Reload\" onAction={() => revalidate()} />\n *         </ActionPanel>\n *       }\n *     />\n *   );\n * };\n * ```\n */\nexport function useCachedPromise<T extends FunctionReturningPromise<[]>>(\n  fn: T,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, undefined>;\nexport function useCachedPromise<T extends FunctionReturningPromise, U = undefined>(\n  fn: T,\n  args: Parameters<T>,\n  options?: CachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<UnwrapReturn<T>, U>;\n\nexport function useCachedPromise<\n  T extends FunctionReturningPromise | FunctionReturningPaginatedPromise,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  U extends any[] | undefined = undefined,\n>(fn: T, args?: Parameters<T>, options?: CachedPromiseOptions<T, U>) {\n  /**\n   * The hook generates a cache key from the promise it receives & its arguments.\n   * Sometimes that's not enough to guarantee uniqueness, so hooks that build on top of `useCachedPromise` can\n   * use an `internal_cacheKeySuffix` to help it.\n   *\n   * @remark For internal use only.\n   */\n  const {\n    initialData,\n    keepPreviousData,\n    internal_cacheKeySuffix,\n    ...usePromiseOptions\n  }: CachedPromiseOptions<T, U> & { internal_cacheKeySuffix?: string } = options || {};\n  const lastUpdateFrom = useRef<\"cache\" | \"promise\">(null);\n\n  const [cachedData, mutateCache] = useCachedState<typeof emptyCache | (UnwrapReturn<T> | U)>(\n    hash(args || []) + internal_cacheKeySuffix,\n    emptyCache,\n    {\n      cacheNamespace: hash(fn),\n    },\n  );\n\n  // Use a ref to store previous returned data. Use the inital data as its inital value from the cache.\n  const laggyDataRef = useRef<Awaited<ReturnType<T>> | U>(cachedData !== emptyCache ? cachedData : (initialData as U));\n  const paginationArgsRef = useRef<PaginationOptions<UnwrapReturn<T> | U> | undefined>(undefined);\n\n  const {\n    mutate: _mutate,\n    revalidate,\n    ...state\n    // @ts-expect-error fn has the same signature in both usePromise and useCachedPromise\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } = usePromise(fn, args || ([] as any as Parameters<T>), {\n    ...usePromiseOptions,\n    onData(data, pagination) {\n      paginationArgsRef.current = pagination;\n      if (usePromiseOptions.onData) {\n        usePromiseOptions.onData(data, pagination);\n      }\n      if (pagination && pagination.page > 0) {\n        // don't cache beyond the first page\n        return;\n      }\n      lastUpdateFrom.current = \"promise\";\n      laggyDataRef.current = data;\n      mutateCache(data);\n    },\n  });\n\n  let returnedData: U | Awaited<ReturnType<T>> | UnwrapReturn<T>;\n  const pagination = state.pagination;\n  // when paginating, only the first page gets cached, so we return the data we get from `usePromise`, because\n  // it will be accumulated.\n  if (paginationArgsRef.current && paginationArgsRef.current.page > 0 && state.data) {\n    returnedData = state.data as UnwrapReturn<T>;\n    // if the latest update if from the Promise, we keep it\n  } else if (lastUpdateFrom.current === \"promise\") {\n    returnedData = laggyDataRef.current;\n  } else if (keepPreviousData && cachedData !== emptyCache) {\n    // if we want to keep the latest data, we pick the cache but only if it's not empty\n    returnedData = cachedData;\n    if (pagination) {\n      pagination.hasMore = true;\n      pagination.pageSize = cachedData.length;\n    }\n  } else if (keepPreviousData && cachedData === emptyCache) {\n    // if the cache is empty, we will return the previous data\n    returnedData = laggyDataRef.current;\n    // there are no special cases, so either return the cache or initial data\n  } else if (cachedData !== emptyCache) {\n    returnedData = cachedData;\n    if (pagination) {\n      pagination.hasMore = true;\n      pagination.pageSize = cachedData.length;\n    }\n  } else {\n    returnedData = initialData as U;\n  }\n\n  const latestData = useLatest(returnedData);\n\n  // we rewrite the mutate function to update the cache instead\n  const mutate = useCallback<MutatePromise<Awaited<ReturnType<T>> | U>>(\n    async (asyncUpdate, options) => {\n      let dataBeforeOptimisticUpdate;\n      try {\n        if (options?.optimisticUpdate) {\n          if (typeof options?.rollbackOnError !== \"function\" && options?.rollbackOnError !== false) {\n            // keep track of the data before the optimistic update,\n            // but only if we need it (eg. only when we want to automatically rollback after)\n            dataBeforeOptimisticUpdate = structuredClone(latestData.current);\n          }\n          const data = options.optimisticUpdate(latestData.current);\n          lastUpdateFrom.current = \"cache\";\n          laggyDataRef.current = data;\n          mutateCache(data);\n        }\n        return await _mutate(asyncUpdate, { shouldRevalidateAfter: options?.shouldRevalidateAfter });\n      } catch (err) {\n        if (typeof options?.rollbackOnError === \"function\") {\n          const data = options.rollbackOnError(latestData.current);\n          lastUpdateFrom.current = \"cache\";\n          laggyDataRef.current = data;\n          mutateCache(data);\n        } else if (options?.optimisticUpdate && options?.rollbackOnError !== false) {\n          lastUpdateFrom.current = \"cache\";\n          // @ts-expect-error when undefined, it's expected\n          laggyDataRef.current = dataBeforeOptimisticUpdate;\n          // @ts-expect-error when undefined, it's expected\n          mutateCache(dataBeforeOptimisticUpdate);\n        }\n        throw err;\n      }\n    },\n    [mutateCache, _mutate, latestData, laggyDataRef, lastUpdateFrom],\n  );\n\n  useEffect(() => {\n    if (cachedData !== emptyCache) {\n      lastUpdateFrom.current = \"cache\";\n      laggyDataRef.current = cachedData;\n    }\n  }, [cachedData]);\n\n  return {\n    data: returnedData,\n    isLoading: state.isLoading,\n    error: state.error,\n    mutate: paginationArgsRef.current && paginationArgsRef.current.page > 0 ? _mutate : mutate,\n    pagination,\n    revalidate,\n  };\n}\n", "import { useCallback, useMemo, useRef } from \"react\";\nimport { useCachedPromise, CachedPromiseOptions } from \"./useCachedPromise\";\nimport { useLatest } from \"./useLatest\";\nimport { FunctionReturningPaginatedPromise, FunctionReturningPromise, UseCachedPromiseReturnType } from \"./types\";\nimport { isJSON } from \"./fetch-utils\";\nimport { hash } from \"./helpers\";\n\nasync function defaultParsing(response: Response) {\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n\n  const contentTypeHeader = response.headers.get(\"content-type\");\n\n  if (contentTypeHeader && isJSON(contentTypeHeader)) {\n    return await response.json();\n  }\n  return await response.text();\n}\n\nfunction defaultMapping<V, T extends unknown[]>(result: V): { data: T; hasMore?: boolean; cursor?: any } {\n  return { data: result as unknown as T, hasMore: false };\n}\n\ntype RequestInfo = string | URL | globalThis.Request;\ntype PaginatedRequestInfo = (pagination: { page: number; lastItem?: any; cursor?: any }) => RequestInfo;\n\n/**\n * Fetches the paginatedURL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.\n *\n * @remark This overload should be used when working with paginated data sources.\n * @remark When paginating, only the first page will be cached.\n *\n * @example\n * ```\n * import { Icon, Image, List } from \"@raycast/api\";\n * import { useFetch } from \"@raycast/utils\";\n * import { useState } from \"react\";\n *\n * type SearchResult = { companies: Company[]; page: number; totalPages: number };\n * type Company = { id: number; name: string; smallLogoUrl?: string };\n * export default function Command() {\n *   const [searchText, setSearchText] = useState(\"\");\n *   const { isLoading, data, pagination } = useFetch(\n *     (options) =>\n *       \"https://api.ycombinator.com/v0.1/companies?\" +\n *       new URLSearchParams({ page: String(options.page + 1), q: searchText }).toString(),\n *     {\n *       mapResult(result: SearchResult) {\n *         return {\n *           data: result.companies,\n *           hasMore: result.page < result.totalPages,\n *         };\n *       },\n *       keepPreviousData: true,\n *       initialData: [],\n *     },\n *   );\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>\n *       {data.map((company) => (\n *         <List.Item\n *           key={company.id}\n *           icon={{ source: company.smallLogoUrl ?? Icon.MinusCircle, mask: Image.Mask.RoundedRectangle }}\n *           title={company.name}\n *         />\n *       ))}\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useFetch<V = unknown, U = undefined, T extends unknown[] = unknown[]>(\n  url: PaginatedRequestInfo,\n  options: RequestInit & {\n    mapResult: (result: V) => { data: T; hasMore?: boolean; cursor?: any };\n    parseResponse?: (response: Response) => Promise<V>;\n  } & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T, U>;\n/**\n * Fetch the URL and returns the {@link AsyncState} corresponding to the execution of the fetch. The last value will be kept between command runs.\n *\n * @example\n * ```\n * import { useFetch } from '@raycast/utils';\n *\n * export default function Command() {\n *   const { isLoading, data, revalidate } = useFetch('https://api.example');\n *\n *   return (\n *     <Detail\n *       isLoading={isLoading}\n *       markdown={data}\n *       actions={\n *         <ActionPanel>\n *           <Action title=\"Reload\" onAction={() => revalidate()} />\n *         </ActionPanel>\n *       }\n *     />\n *   );\n * };\n * ```\n */\nexport function useFetch<V = unknown, U = undefined, T = V>(\n  url: RequestInfo,\n  options?: RequestInit & {\n    mapResult?: (result: V) => { data: T; hasMore?: boolean; cursor?: any };\n    parseResponse?: (response: Response) => Promise<V>;\n  } & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T, U> & { pagination: undefined };\n\nexport function useFetch<V = unknown, U = undefined, T extends unknown[] = unknown[]>(\n  url: RequestInfo | PaginatedRequestInfo,\n  options?: RequestInit & {\n    mapResult?: (result: V) => { data: T; hasMore?: boolean; cursor?: any };\n    parseResponse?: (response: Response) => Promise<V>;\n  } & Omit<CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T, U> {\n  const {\n    parseResponse,\n    mapResult,\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n    ...fetchOptions\n  } = options || {};\n\n  const useCachedPromiseOptions: CachedPromiseOptions<(url: RequestInfo, options?: RequestInit) => Promise<T>, U> = {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n  };\n\n  const parseResponseRef = useLatest(parseResponse || defaultParsing);\n  const mapResultRef = useLatest(mapResult || defaultMapping);\n  const urlRef = useRef<RequestInfo | PaginatedRequestInfo>(null);\n  const firstPageUrlRef = useRef<RequestInfo | undefined>(null);\n  const firstPageUrl = typeof url === \"function\" ? url({ page: 0 }) : undefined;\n  /**\n   * When paginating, `url` is a `PaginatedRequestInfo`, so we only want to update the ref when the `firstPageUrl` changes.\n   * When not paginating, `url` is a `RequestInfo`, so we want to update the ref whenever `url` changes.\n   */\n  if (!urlRef.current || typeof firstPageUrlRef.current === \"undefined\" || firstPageUrlRef.current !== firstPageUrl) {\n    urlRef.current = url;\n  }\n  firstPageUrlRef.current = firstPageUrl;\n  const abortable = useRef<AbortController>(null);\n\n  const paginatedFn: FunctionReturningPaginatedPromise<[PaginatedRequestInfo, typeof fetchOptions], T> = useCallback(\n    (url: PaginatedRequestInfo, options?: RequestInit) => async (pagination: { page: number }) => {\n      const res = await fetch(url(pagination), { signal: abortable.current?.signal, ...options });\n      const parsed = (await parseResponseRef.current(res)) as V;\n      return mapResultRef.current?.(parsed);\n    },\n    [parseResponseRef, mapResultRef],\n  );\n  const fn: FunctionReturningPromise<[RequestInfo, RequestInit?], T> = useCallback(\n    async (url: RequestInfo, options?: RequestInit) => {\n      const res = await fetch(url, { signal: abortable.current?.signal, ...options });\n      const parsed = (await parseResponseRef.current(res)) as V;\n      const mapped = mapResultRef.current(parsed);\n      return mapped?.data as unknown as T;\n    },\n    [parseResponseRef, mapResultRef],\n  );\n\n  const promise = useMemo(() => {\n    if (firstPageUrlRef.current) {\n      return paginatedFn;\n    }\n    return fn;\n  }, [firstPageUrlRef, fn, paginatedFn]);\n\n  // @ts-expect-error lastItem can't be inferred properly\n  return useCachedPromise(promise, [urlRef.current as PaginatedRequestInfo, fetchOptions], {\n    ...useCachedPromiseOptions,\n    internal_cacheKeySuffix: firstPageUrlRef.current + hash(mapResultRef.current) + hash(parseResponseRef.current),\n    abortable,\n  });\n}\n", "export function isJSON(contentTypeHeader: string | null | undefined): boolean {\n  if (contentTypeHeader) {\n    const mediaType = parseContentType(contentTypeHeader);\n\n    if (!mediaType) {\n      return false;\n    }\n\n    if (mediaType.subtype === \"json\") {\n      return true;\n    }\n\n    if (mediaType.suffix === \"json\") {\n      return true;\n    }\n\n    if (mediaType.suffix && /\\bjson\\b/i.test(mediaType.suffix)) {\n      return true;\n    }\n\n    if (mediaType.subtype && /\\bjson\\b/i.test(mediaType.subtype)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * RegExp to match type in RFC 6838 with an optional trailing `;` because some Apple APIs returns one...\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */\nconst MEDIA_TYPE_REGEXP = /^([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126});?$/;\n\nfunction parseContentType(header: string) {\n  const headerDelimitationindex = header.indexOf(\";\");\n  const contentType = headerDelimitationindex !== -1 ? header.slice(0, headerDelimitationindex).trim() : header.trim();\n\n  const match = MEDIA_TYPE_REGEXP.exec(contentType.toLowerCase().toLowerCase());\n\n  if (!match) {\n    return;\n  }\n\n  const type = match[1];\n  let subtype = match[2];\n  let suffix;\n\n  // suffix after last +\n  const index = subtype.lastIndexOf(\"+\");\n  if (index !== -1) {\n    suffix = subtype.substring(index + 1);\n    subtype = subtype.substring(0, index);\n  }\n\n  return { type, subtype, suffix };\n}\n", "/*\n * Inspired by Execa\n */\n\nimport childProcess from \"node:child_process\";\nimport { useCallback, useRef } from \"react\";\n\nimport { useCachedPromise, CachedPromiseOptions } from \"./useCachedPromise\";\nimport { useLatest } from \"./useLatest\";\nimport { UseCachedPromiseReturnType } from \"./types\";\nimport {\n  getSpawnedPromise,\n  getSpawnedResult,\n  handleOutput,\n  defaultParsing,\n  ParseExecOutputHandler,\n} from \"./exec-utils\";\n\ntype ExecOptions = {\n  /**\n   * If `true`, runs the command inside of a shell. Uses `/bin/sh`. A different shell can be specified as a string. The shell should understand the `-c` switch.\n   *\n   * We recommend against using this option since it is:\n   * - not cross-platform, encouraging shell-specific syntax.\n   * - slower, because of the additional shell interpretation.\n   * - unsafe, potentially allowing command injection.\n   *\n   * @default false\n   */\n  shell?: boolean | string;\n  /**\n   * Strip the final newline character from the output.\n   * @default true\n   */\n  stripFinalNewline?: boolean;\n  /**\n   * Current working directory of the child process.\n   * @default process.cwd()\n   */\n  cwd?: string;\n  /**\n   * Environment key-value pairs. Extends automatically from `process.env`.\n   * @default process.env\n   */\n  env?: NodeJS.ProcessEnv;\n  /**\n   * Specify the character encoding used to decode the stdout and stderr output. If set to `\"buffer\"`, then stdout and stderr will be a Buffer instead of a string.\n   *\n   * @default \"utf8\"\n   */\n  encoding?: BufferEncoding | \"buffer\";\n  /**\n   * Write some input to the `stdin` of your binary.\n   */\n  input?: string | Buffer;\n  /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.\n   *\n   * @default 10000\n   */\n  timeout?: number;\n};\n\nconst SPACES_REGEXP = / +/g;\nfunction parseCommand(command: string, args?: string[]) {\n  if (args) {\n    return [command, ...args];\n  }\n  const tokens: string[] = [];\n  for (const token of command.trim().split(SPACES_REGEXP)) {\n    // Allow spaces to be escaped by a backslash if not meant as a delimiter\n    const previousToken = tokens[tokens.length - 1];\n    if (previousToken && previousToken.endsWith(\"\\\\\")) {\n      // Merge previous token with current one\n      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n    } else {\n      tokens.push(token);\n    }\n  }\n\n  return tokens;\n}\n\ntype ExecCachedPromiseOptions<T, U> = Omit<\n  CachedPromiseOptions<\n    (_command: string, _args: string[], _options?: ExecOptions, input?: string | Buffer) => Promise<T>,\n    U\n  >,\n  \"abortable\"\n>;\n\n/**\n * Executes a command and returns the {@link AsyncState} corresponding to the execution of the command. The last value will be kept between command runs.\n *\n * @remark When specifying the arguments via the `command` string, if the file or an argument of the command contains spaces, they must be escaped with backslashes. This matters especially if `command` is not a constant but a variable, for example with `__dirname` or `process.cwd()`. Except for spaces, no escaping/quoting is needed.\n *\n * The `shell` option must be used if the command uses shell-specific features (for example, `&&` or `||`), as opposed to being a simple file followed by its arguments.\n *\n * @example\n * ```\n * import { useExec } from '@raycast/utils';\n *\n * export default function Command() {\n *   const { isLoading, data, revalidate } = useExec(\"brew\", [\"info\", \"--json=v2\", \"--installed\"]);\n *   const results = useMemo<{}[]>(() => JSON.parse(data || \"[]\"), [data]);\n *\n *   return (\n *     <List isLoading={isLoading}>\n *      {(data || []).map((item) => (\n *        <List.Item key={item.id} title={item.name} />\n *      ))}\n *    </List>\n *   );\n * };\n * ```\n */\nexport function useExec<T = Buffer, U = undefined>(\n  command: string,\n  options: {\n    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions>;\n  } & ExecOptions & {\n      encoding: \"buffer\";\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T = string, U = undefined>(\n  command: string,\n  options?: {\n    parseOutput?: ParseExecOutputHandler<T, string, ExecOptions>;\n  } & ExecOptions & {\n      encoding?: BufferEncoding;\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T = Buffer, U = undefined>(\n  file: string,\n  /**\n   * The arguments to pass to the file. No escaping/quoting is needed.\n   *\n   * If defined, the commands needs to be a file to execute. If undefined, the arguments will be parsed from the command.\n   */\n  args: string[],\n  options: {\n    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions>;\n  } & ExecOptions & {\n      encoding: \"buffer\";\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T = string, U = undefined>(\n  file: string,\n  /**\n   * The arguments to pass to the file. No escaping/quoting is needed.\n   *\n   * If defined, the commands needs to be a file to execute. If undefined, the arguments will be parsed from the command.\n   */\n  args: string[],\n  options?: {\n    parseOutput?: ParseExecOutputHandler<T, string, ExecOptions>;\n  } & ExecOptions & {\n      encoding?: BufferEncoding;\n    } & ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U>;\nexport function useExec<T, U = undefined>(\n  command: string,\n  optionsOrArgs?:\n    | string[]\n    | ({\n        parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions> | ParseExecOutputHandler<T, string, ExecOptions>;\n      } & ExecOptions &\n        ExecCachedPromiseOptions<T, U>),\n  options?: {\n    parseOutput?: ParseExecOutputHandler<T, Buffer, ExecOptions> | ParseExecOutputHandler<T, string, ExecOptions>;\n  } & ExecOptions &\n    ExecCachedPromiseOptions<T, U>,\n): UseCachedPromiseReturnType<T, U> {\n  const {\n    parseOutput,\n    input,\n    onData,\n    onWillExecute,\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    failureToastOptions,\n    ...execOptions\n  } = Array.isArray(optionsOrArgs) ? options || {} : optionsOrArgs || {};\n\n  const useCachedPromiseOptions: ExecCachedPromiseOptions<T, U> = {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n  };\n\n  const abortable = useRef<AbortController>(null);\n  const parseOutputRef = useLatest(parseOutput || defaultParsing);\n\n  const fn = useCallback(\n    async (_command: string, _args: string[], _options?: ExecOptions, input?: string | Buffer) => {\n      const [file, ...args] = parseCommand(_command, _args);\n      const command = [file, ...args].join(\" \");\n\n      const options = {\n        stripFinalNewline: true,\n        ..._options,\n        timeout: _options?.timeout || 10000,\n        signal: abortable.current?.signal,\n        encoding: _options?.encoding === null ? \"buffer\" : _options?.encoding || \"utf8\",\n        env: { PATH: \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\", ...process.env, ..._options?.env },\n      };\n\n      const spawned = childProcess.spawn(file, args, options);\n      const spawnedPromise = getSpawnedPromise(spawned, options);\n\n      if (input) {\n        spawned.stdin.end(input);\n      }\n\n      const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult(\n        spawned,\n        options,\n        spawnedPromise,\n      );\n      const stdout = handleOutput(options, stdoutResult);\n      const stderr = handleOutput(options, stderrResult);\n\n      return parseOutputRef.current({\n        // @ts-expect-error too many generics, I give up\n        stdout,\n        // @ts-expect-error too many generics, I give up\n        stderr,\n        error,\n        exitCode,\n        signal,\n        timedOut,\n        command,\n        options,\n        parentError: new Error(),\n      }) as T;\n    },\n    [parseOutputRef],\n  );\n\n  // @ts-expect-error T can't be a Promise so it's actually the same\n  return useCachedPromise(fn, [command, Array.isArray(optionsOrArgs) ? optionsOrArgs : [], execOptions, input], {\n    ...useCachedPromiseOptions,\n    abortable,\n  });\n}\n", "import childProcess from \"node:child_process\";\nimport { constants as BufferConstants } from \"node:buffer\";\nimport Stream from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport { onExit } from \"./vendors/signal-exit\";\n\nexport type SpawnedPromise = Promise<{\n  exitCode: number | null;\n  error?: Error;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n}>;\n\nexport function getSpawnedPromise(\n  spawned: childProcess.ChildProcessWithoutNullStreams,\n  { timeout }: { timeout?: number } = {},\n): SpawnedPromise {\n  const spawnedPromise: SpawnedPromise = new Promise((resolve, reject) => {\n    spawned.on(\"exit\", (exitCode, signal) => {\n      resolve({ exitCode, signal, timedOut: false });\n    });\n\n    spawned.on(\"error\", (error) => {\n      reject(error);\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on(\"error\", (error) => {\n        reject(error);\n      });\n    }\n  });\n\n  const removeExitHandler = onExit(() => {\n    spawned.kill();\n  });\n\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise.finally(() => removeExitHandler());\n  }\n\n  let timeoutId: NodeJS.Timeout;\n  const timeoutPromise: SpawnedPromise = new Promise((_resolve, reject) => {\n    timeoutId = setTimeout(() => {\n      spawned.kill(\"SIGTERM\");\n      reject(Object.assign(new Error(\"Timed out\"), { timedOut: true, signal: \"SIGTERM\" }));\n    }, timeout);\n  });\n\n  const safeSpawnedPromise = spawnedPromise.finally(() => {\n    clearTimeout(timeoutId);\n  });\n\n  return Promise.race([timeoutPromise, safeSpawnedPromise]).finally(() => removeExitHandler());\n}\n\nclass MaxBufferError extends Error {\n  constructor() {\n    super(\"The output is too big\");\n    this.name = \"MaxBufferError\";\n  }\n}\n\nfunction bufferStream<T extends string | Buffer>(options: { encoding: BufferEncoding | \"buffer\" }) {\n  const { encoding } = options;\n  const isBuffer = encoding === \"buffer\";\n\n  // @ts-expect-error missing the methods we are adding below\n  const stream: Stream.PassThrough & { getBufferedValue: () => T; getBufferedLength: () => number } =\n    new Stream.PassThrough({ objectMode: false });\n\n  if (encoding && encoding !== \"buffer\") {\n    stream.setEncoding(encoding);\n  }\n\n  let length = 0;\n  const chunks: any[] = [];\n\n  stream.on(\"data\", (chunk) => {\n    chunks.push(chunk);\n\n    length += chunk.length;\n  });\n\n  stream.getBufferedValue = () => {\n    return (isBuffer ? Buffer.concat(chunks, length) : chunks.join(\"\")) as T;\n  };\n\n  stream.getBufferedLength = () => length;\n\n  return stream;\n}\n\nasync function getStream<T extends string | Buffer>(\n  inputStream: Stream.Readable,\n  options: { encoding: BufferEncoding | \"buffer\" },\n) {\n  const stream = bufferStream<T>(options);\n\n  await new Promise<void>((resolve, reject) => {\n    const rejectPromise = (error: Error & { bufferedData?: T }) => {\n      // Don't retrieve an oversized buffer.\n      if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n        error.bufferedData = stream.getBufferedValue();\n      }\n\n      reject(error);\n    };\n\n    (async () => {\n      try {\n        await promisify(Stream.pipeline)(inputStream, stream);\n        resolve();\n      } catch (error) {\n        rejectPromise(error as any);\n      }\n    })();\n\n    stream.on(\"data\", () => {\n      // 80mb\n      if (stream.getBufferedLength() > 1000 * 1000 * 80) {\n        rejectPromise(new MaxBufferError());\n      }\n    });\n  });\n\n  return stream.getBufferedValue();\n}\n\n// On failure, `result.stdout|stderr` should contain the currently buffered stream\nasync function getBufferedData<T extends string | Buffer>(stream: Stream.Readable, streamPromise: Promise<T>) {\n  stream.destroy();\n\n  try {\n    return await streamPromise;\n  } catch (error) {\n    return (error as any as { bufferedData: T }).bufferedData;\n  }\n}\n\nexport async function getSpawnedResult<T extends string | Buffer>(\n  { stdout, stderr }: childProcess.ChildProcessWithoutNullStreams,\n  { encoding }: { encoding: BufferEncoding | \"buffer\" },\n  processDone: SpawnedPromise,\n) {\n  const stdoutPromise = getStream<T>(stdout, { encoding });\n  const stderrPromise = getStream<T>(stderr, { encoding });\n\n  try {\n    return await Promise.all([processDone, stdoutPromise, stderrPromise]);\n  } catch (error: any) {\n    return Promise.all([\n      {\n        error: error as Error,\n        exitCode: null,\n        signal: error.signal as NodeJS.Signals | null,\n        timedOut: (error.timedOut as boolean) || false,\n      },\n      getBufferedData(stdout, stdoutPromise),\n      getBufferedData(stderr, stderrPromise),\n    ]);\n  }\n}\n\nfunction stripFinalNewline<T extends string | Buffer>(input: T) {\n  const LF = typeof input === \"string\" ? \"\\n\" : \"\\n\".charCodeAt(0);\n  const CR = typeof input === \"string\" ? \"\\r\" : \"\\r\".charCodeAt(0);\n\n  if (input[input.length - 1] === LF) {\n    // @ts-expect-error we are doing some nasty stuff here\n    input = input.slice(0, -1);\n  }\n\n  if (input[input.length - 1] === CR) {\n    // @ts-expect-error we are doing some nasty stuff here\n    input = input.slice(0, -1);\n  }\n\n  return input;\n}\n\nexport function handleOutput<T extends string | Buffer>(options: { stripFinalNewline?: boolean }, value: T) {\n  if (options.stripFinalNewline) {\n    return stripFinalNewline(value);\n  }\n\n  return value;\n}\n\nfunction getErrorPrefix({\n  timedOut,\n  timeout,\n  signal,\n  exitCode,\n}: {\n  exitCode: number | null;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n  timeout?: number;\n}) {\n  if (timedOut) {\n    return `timed out after ${timeout} milliseconds`;\n  }\n\n  if (signal !== undefined && signal !== null) {\n    return `was killed with ${signal}`;\n  }\n\n  if (exitCode !== undefined && exitCode !== null) {\n    return `failed with exit code ${exitCode}`;\n  }\n\n  return \"failed\";\n}\n\nfunction makeError({\n  stdout,\n  stderr,\n  error,\n  signal,\n  exitCode,\n  command,\n  timedOut,\n  options,\n  parentError,\n}: {\n  stdout: string | Buffer;\n  stderr: string | Buffer;\n  error?: Error;\n  exitCode: number | null;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n  command: string;\n  options?: { timeout?: number };\n  parentError: Error;\n}) {\n  const prefix = getErrorPrefix({ timedOut, timeout: options?.timeout, signal, exitCode });\n  const execaMessage = `Command ${prefix}: ${command}`;\n  const shortMessage = error ? `${execaMessage}\\n${error.message}` : execaMessage;\n  const message = [shortMessage, stderr, stdout].filter(Boolean).join(\"\\n\");\n\n  if (error) {\n    // @ts-expect-error not on Error\n    error.originalMessage = error.message;\n  } else {\n    error = parentError;\n  }\n\n  error.message = message;\n\n  // @ts-expect-error not on Error\n  error.shortMessage = shortMessage;\n  // @ts-expect-error not on Error\n  error.command = command;\n  // @ts-expect-error not on Error\n  error.exitCode = exitCode;\n  // @ts-expect-error not on Error\n  error.signal = signal;\n  // @ts-expect-error not on Error\n  error.stdout = stdout;\n  // @ts-expect-error not on Error\n  error.stderr = stderr;\n\n  if (\"bufferedData\" in error) {\n    delete error[\"bufferedData\"];\n  }\n\n  return error;\n}\n\nexport type ParseExecOutputHandler<\n  T,\n  DecodedOutput extends string | Buffer = string | Buffer,\n  Options = unknown,\n> = (args: {\n  /** The output of the process on stdout. */\n  stdout: DecodedOutput;\n  /** The output of the process on stderr. */\n  stderr: DecodedOutput;\n  error?: Error;\n  /** The numeric exit code of the process that was run. */\n  exitCode: number | null;\n  /**\n   * The name of the signal that was used to terminate the process. For example, SIGFPE.\n   *\n   * If a signal terminated the process, this property is defined. Otherwise it is null.\n   */\n  signal: NodeJS.Signals | null;\n  /** Whether the process timed out. */\n  timedOut: boolean;\n  /** The command that was run, for logging purposes. */\n  command: string;\n  options?: Options;\n}) => T;\n\nexport function defaultParsing<T extends string | Buffer>({\n  stdout,\n  stderr,\n  error,\n  exitCode,\n  signal,\n  timedOut,\n  command,\n  options,\n  parentError,\n}: {\n  stdout: T;\n  stderr: T;\n  error?: Error;\n  exitCode: number | null;\n  signal: NodeJS.Signals | null;\n  timedOut: boolean;\n  command: string;\n  options?: { timeout?: number };\n  parentError: Error;\n}) {\n  if (error || exitCode !== 0 || signal !== null) {\n    const returnedError = makeError({\n      error,\n      exitCode,\n      signal,\n      stdout,\n      stderr,\n      command,\n      timedOut,\n      options,\n      parentError,\n    });\n\n    throw returnedError;\n  }\n\n  return stdout;\n}\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\n\nconst processOk = (process: any) =>\n  !!process &&\n  typeof process === \"object\" &&\n  typeof process.removeListener === \"function\" &&\n  typeof process.emit === \"function\" &&\n  typeof process.reallyExit === \"function\" &&\n  typeof process.listeners === \"function\" &&\n  typeof process.kill === \"function\" &&\n  typeof process.pid === \"number\" &&\n  typeof process.on === \"function\";\nconst kExitEmitter = /* #__PURE__ */ Symbol.for(\"signal-exit emitter\");\n// teeny special purpose ee\nclass Emitter {\n  emitted = {\n    afterExit: false,\n    exit: false,\n  };\n  listeners = {\n    afterExit: [],\n    exit: [],\n  };\n  count = 0;\n  id = Math.random();\n  constructor() {\n    // @ts-ignore\n    if (global[kExitEmitter]) {\n      // @ts-ignore\n      return global[kExitEmitter];\n    }\n    Object.defineProperty(global, kExitEmitter, {\n      value: this,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n  }\n  on(ev: any, fn: any) {\n    // @ts-ignore\n    this.listeners[ev].push(fn);\n  }\n  removeListener(ev: any, fn: any) {\n    // @ts-ignore\n    const list = this.listeners[ev];\n    const i = list.indexOf(fn);\n    /* c8 ignore start */\n    if (i === -1) {\n      return;\n    }\n    /* c8 ignore stop */\n    if (i === 0 && list.length === 1) {\n      list.length = 0;\n    } else {\n      list.splice(i, 1);\n    }\n  }\n  emit(ev: any, code: any, signal: any): any {\n    // @ts-ignore\n    if (this.emitted[ev]) {\n      return false;\n    }\n    // @ts-ignore\n    this.emitted[ev] = true;\n    let ret = false;\n    // @ts-ignore\n    for (const fn of this.listeners[ev]) {\n      ret = fn(code, signal) === true || ret;\n    }\n    if (ev === \"exit\") {\n      ret = this.emit(\"afterExit\", code, signal) || ret;\n    }\n    return ret;\n  }\n}\n\nclass SignalExitFallback {\n  onExit() {\n    return () => {};\n  }\n  load() {}\n  unload() {}\n}\nclass SignalExit {\n  // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n  // so use a supported signal instead\n  /* c8 ignore start */\n  // @ts-ignore\n  #hupSig = process.platform === \"win32\" ? \"SIGINT\" : \"SIGHUP\";\n  /* c8 ignore stop */\n  #emitter = new Emitter();\n  #process: any;\n  #originalProcessEmit: any;\n  #originalProcessReallyExit: any;\n  #sigListeners = {};\n  #loaded = false;\n  #signals: string[] = [];\n  constructor(process: any) {\n    /**\n     * This is not the set of all possible signals.\n     *\n     * It IS, however, the set of all signals that trigger\n     * an exit on either Linux or BSD systems.  Linux is a\n     * superset of the signal names supported on BSD, and\n     * the unknown signals just fail to register, so we can\n     * catch that easily enough.\n     *\n     * Windows signals are a different set, since there are\n     * signals that terminate Windows processes, but don't\n     * terminate (or don't even exist) on Posix systems.\n     *\n     * Don't bother with SIGKILL.  It's uncatchable, which\n     * means that we can't fire any callbacks anyway.\n     *\n     * If a user does happen to register a handler on a non-\n     * fatal signal like SIGWINCH or something, and then\n     * exit, it'll end up firing `process.emit('exit')`, so\n     * the handler will be fired anyway.\n     *\n     * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n     * artificially, inherently leave the process in a\n     * state from which it is not safe to try and enter JS\n     * listeners.\n     */\n    this.#signals.push(\"SIGHUP\", \"SIGINT\", \"SIGTERM\");\n    if (globalThis.process.platform !== \"win32\") {\n      this.#signals.push(\n        \"SIGALRM\",\n        \"SIGABRT\",\n        \"SIGVTALRM\",\n        \"SIGXCPU\",\n        \"SIGXFSZ\",\n        \"SIGUSR2\",\n        \"SIGTRAP\",\n        \"SIGSYS\",\n        \"SIGQUIT\",\n        \"SIGIOT\",\n        // should detect profiler and enable/disable accordingly.\n        // see #21\n        // 'SIGPROF'\n      );\n    }\n    if (globalThis.process.platform === \"linux\") {\n      this.#signals.push(\"SIGIO\", \"SIGPOLL\", \"SIGPWR\", \"SIGSTKFLT\");\n    }\n    this.#process = process;\n    // { <signal>: <listener fn>, ... }\n    this.#sigListeners = {};\n    for (const sig of this.#signals) {\n      // @ts-ignore\n      this.#sigListeners[sig] = () => {\n        // If there are no other listeners, an exit is coming!\n        // Simplest way: remove us and then re-send the signal.\n        // We know that this will kill the process, so we can\n        // safely emit now.\n        const listeners = this.#process.listeners(sig);\n        let { count } = this.#emitter;\n        // This is a workaround for the fact that signal-exit v3 and signal\n        // exit v4 are not aware of each other, and each will attempt to let\n        // the other handle it, so neither of them do. To correct this, we\n        // detect if we're the only handler *except* for previous versions\n        // of signal-exit, and increment by the count of listeners it has\n        // created.\n        /* c8 ignore start */\n        const p = process;\n        if (typeof p.__signal_exit_emitter__ === \"object\" && typeof p.__signal_exit_emitter__.count === \"number\") {\n          count += p.__signal_exit_emitter__.count;\n        }\n        /* c8 ignore stop */\n        if (listeners.length === count) {\n          this.unload();\n          const ret = this.#emitter.emit(\"exit\", null, sig);\n          /* c8 ignore start */\n          const s = sig === \"SIGHUP\" ? this.#hupSig : sig;\n          if (!ret) process.kill(process.pid, s);\n          /* c8 ignore stop */\n        }\n      };\n    }\n    this.#originalProcessReallyExit = process.reallyExit;\n    this.#originalProcessEmit = process.emit;\n  }\n  onExit(cb: any, opts: any) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return () => {};\n    }\n    /* c8 ignore stop */\n    if (this.#loaded === false) {\n      this.load();\n    }\n    const ev = opts?.alwaysLast ? \"afterExit\" : \"exit\";\n    this.#emitter.on(ev, cb);\n    return () => {\n      this.#emitter.removeListener(ev, cb);\n      if (this.#emitter.listeners[\"exit\"].length === 0 && this.#emitter.listeners[\"afterExit\"].length === 0) {\n        this.unload();\n      }\n    };\n  }\n  load() {\n    if (this.#loaded) {\n      return;\n    }\n    this.#loaded = true;\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    this.#emitter.count += 1;\n    for (const sig of this.#signals) {\n      try {\n        // @ts-ignore\n        const fn = this.#sigListeners[sig];\n        if (fn) this.#process.on(sig, fn);\n      } catch (_) {\n        // no-op\n      }\n    }\n    this.#process.emit = (ev: any, ...a: any) => {\n      return this.#processEmit(ev, ...a);\n    };\n    this.#process.reallyExit = (code: any) => {\n      return this.#processReallyExit(code);\n    };\n  }\n  unload() {\n    if (!this.#loaded) {\n      return;\n    }\n    this.#loaded = false;\n    this.#signals.forEach((sig) => {\n      // @ts-ignore\n      const listener = this.#sigListeners[sig];\n      /* c8 ignore start */\n      if (!listener) {\n        throw new Error(\"Listener not defined for signal: \" + sig);\n      }\n      /* c8 ignore stop */\n      try {\n        this.#process.removeListener(sig, listener);\n        /* c8 ignore start */\n      } catch (_) {\n        // no-op\n      }\n      /* c8 ignore stop */\n    });\n    this.#process.emit = this.#originalProcessEmit;\n    this.#process.reallyExit = this.#originalProcessReallyExit;\n    this.#emitter.count -= 1;\n  }\n  #processReallyExit(code: any) {\n    /* c8 ignore start */\n    if (!processOk(this.#process)) {\n      return 0;\n    }\n    this.#process.exitCode = code || 0;\n    /* c8 ignore stop */\n    this.#emitter.emit(\"exit\", this.#process.exitCode, null);\n    return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);\n  }\n  #processEmit(ev: any, ...args: any) {\n    const og = this.#originalProcessEmit;\n    if (ev === \"exit\" && processOk(this.#process)) {\n      if (typeof args[0] === \"number\") {\n        this.#process.exitCode = args[0];\n        /* c8 ignore start */\n      }\n      /* c8 ignore start */\n      const ret = og.call(this.#process, ev, ...args);\n      /* c8 ignore start */\n      this.#emitter.emit(\"exit\", this.#process.exitCode, null);\n      /* c8 ignore stop */\n      return ret;\n    } else {\n      return og.call(this.#process, ev, ...args);\n    }\n  }\n}\n\nlet signalExit: SignalExit | SignalExitFallback | null = null;\n\nexport const onExit = (\n  cb: any,\n  opts?: {\n    alwaysLast?: boolean | undefined;\n  },\n) => {\n  if (!signalExit) {\n    signalExit = processOk(process) ? new SignalExit(process) : new SignalExitFallback();\n  }\n  return signalExit.onExit(cb, opts);\n};\n", "import { environment } from \"@raycast/api\";\nimport { createReadStream, createWriteStream, mkdirSync, Stats } from \"node:fs\";\nimport { stat } from \"node:fs/promises\";\nimport { join, normalize } from \"node:path\";\nimport { pipeline } from \"node:stream/promises\";\nimport { useRef } from \"react\";\nimport Chain from \"./vendors/stream-chain\";\nimport { parser, PickParser, StreamArray } from \"./vendors/stream-json\";\nimport { isJSON } from \"./fetch-utils\";\nimport { Flatten, FunctionReturningPaginatedPromise, UseCachedPromiseReturnType } from \"./types\";\nimport { CachedPromiseOptions, useCachedPromise } from \"./useCachedPromise\";\nimport { hash } from \"./helpers\";\n\ntype RequestInfo = string | URL | globalThis.Request;\n\nasync function cache(url: RequestInfo, destination: string, fetchOptions?: RequestInit) {\n  if (typeof url === \"object\" || url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return await cacheURL(url, destination, fetchOptions);\n  } else if (url.startsWith(\"file://\")) {\n    return await cacheFile(\n      normalize(decodeURIComponent(new URL(url).pathname)),\n      destination,\n      fetchOptions?.signal ? fetchOptions.signal : undefined,\n    );\n  } else {\n    throw new Error(\"Only HTTP(S) or file URLs are supported\");\n  }\n}\n\nasync function cacheURL(url: RequestInfo, destination: string, fetchOptions?: RequestInit) {\n  const response = await fetch(url, fetchOptions);\n\n  if (!response.ok) {\n    throw new Error(\"Failed to fetch URL\");\n  }\n\n  if (!isJSON(response.headers.get(\"content-type\"))) {\n    throw new Error(\"URL does not return JSON\");\n  }\n  if (!response.body) {\n    throw new Error(\"Failed to retrieve expected JSON content: Response body is missing or inaccessible.\");\n  }\n  await pipeline(\n    response.body as unknown as NodeJS.ReadableStream,\n    createWriteStream(destination),\n    fetchOptions?.signal ? { signal: fetchOptions.signal } : undefined,\n  );\n}\n\nasync function cacheFile(source: string, destination: string, abortSignal?: AbortSignal) {\n  await pipeline(\n    createReadStream(source),\n    createWriteStream(destination),\n    abortSignal ? { signal: abortSignal } : undefined,\n  );\n}\n\nasync function cacheURLIfNecessary(\n  url: RequestInfo,\n  folder: string,\n  fileName: string,\n  forceUpdate: boolean,\n  fetchOptions?: RequestInit,\n) {\n  const destination = join(folder, fileName);\n\n  try {\n    await stat(folder);\n  } catch (e) {\n    mkdirSync(folder, { recursive: true });\n    await cache(url, destination, fetchOptions);\n    return;\n  }\n  if (forceUpdate) {\n    await cache(url, destination, fetchOptions);\n    return;\n  }\n\n  let stats: Stats | undefined = undefined;\n  try {\n    stats = await stat(destination);\n  } catch (e) {\n    await cache(url, destination, fetchOptions);\n    return;\n  }\n\n  if (typeof url === \"object\" || url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    const headResponse = await fetch(url, { ...fetchOptions, method: \"HEAD\" });\n    if (!headResponse.ok) {\n      throw new Error(\"Could not fetch URL\");\n    }\n\n    if (!isJSON(headResponse.headers.get(\"content-type\"))) {\n      throw new Error(\"URL does not return JSON\");\n    }\n\n    const lastModified = Date.parse(headResponse.headers.get(\"last-modified\") ?? \"\");\n    if (stats.size === 0 || Number.isNaN(lastModified) || lastModified > stats.mtimeMs) {\n      await cache(url, destination, fetchOptions);\n      return;\n    }\n  } else if (url.startsWith(\"file://\")) {\n    try {\n      const sourceStats = await stat(normalize(decodeURIComponent(new URL(url).pathname)));\n      if (sourceStats.mtimeMs > stats.mtimeMs) {\n        await cache(url, destination, fetchOptions);\n      }\n    } catch (e) {\n      throw new Error(\"Source file could not be read\");\n    }\n  } else {\n    throw new Error(\"Only HTTP(S) or file URLs are supported\");\n  }\n}\n\nasync function* streamJsonFile<T>(\n  filePath: string,\n  pageSize: number,\n  abortSignal?: AbortSignal,\n  dataPath?: string | RegExp,\n  filterFn?: (item: Flatten<T>) => boolean,\n  transformFn?: (item: any) => T,\n): AsyncGenerator<T extends unknown[] ? T : T[]> {\n  let page: T extends unknown[] ? T : T[] = [] as T extends unknown[] ? T : T[];\n\n  const pipeline = Chain([\n    createReadStream(filePath),\n    dataPath ? PickParser({ filter: dataPath }) : parser(),\n    StreamArray(),\n    (data: any) => transformFn?.(data.value) ?? data.value,\n  ]);\n\n  abortSignal?.addEventListener(\"abort\", () => {\n    pipeline.destroy();\n  });\n\n  try {\n    for await (const data of pipeline) {\n      if (abortSignal?.aborted) {\n        return [];\n      }\n      if (!filterFn || filterFn(data)) {\n        page.push(data);\n      }\n      if (page.length >= pageSize) {\n        yield page;\n        page = [] as T extends unknown[] ? T : T[];\n      }\n    }\n  } catch (e) {\n    pipeline.destroy();\n    throw e;\n  }\n\n  if (page.length > 0) {\n    yield page;\n  }\n\n  return [];\n}\n\ntype Options<T> = {\n  /**\n   * The hook expects to iterate through an array of data, so by default, it assumes the JSON it receives itself represents an array. However, sometimes the array of data is wrapped in an object,\n   * i.e. `{ \"success\": true, \"data\": [] }`, or even `{ \"success\": true, \"results\": { \"data\": [] } }`. In those cases, you can use `dataPath` to specify where the data array can be found.\n   *\n   * @remark If your JSON object has multiple arrays that you want to stream data from, you can pass a regular expression to stream through all of them.\n   *\n   * @example For `{ \"success\": true, \"data\": [] }`, dataPath would be `data`\n   * @example For `{ \"success\": true, \"results\": { \"data\": [] } }`, dataPath would be `results.data`\n   * @example For `{ \"success\": true, \"results\": { \"first_list\": [], \"second_list\": [], \"third_list\": [] } }`, dataPath would be `/^results\\.(first_list|second_list|third_list)$\n/`.\n   */\n  dataPath?: string | RegExp;\n  /**\n   * A function to decide whether a particular item should be kept or not.\n   * Defaults to `undefined`, keeping any encountered item.\n   *\n   * @remark The hook will revalidate every time the filter function changes, so you need to use [useCallback](https://react.dev/reference/react/useCallback) to make sure it only changes when it needs to.\n   */\n  filter?: (item: Flatten<T>) => boolean;\n  /**\n   * A function to apply to each item as it is encountered. Useful for a couple of things:\n   * 1. ensuring that all items have the expected properties, and, as on optimization, for getting rid of the properties that you don't care about.\n   * 2. when top-level objects actually represent nested data, which should be flattened. In this case, `transform` can return an array of items, and the hook will stream through each one of those items,\n   * passing them to `filter` etc.\n   *\n   * Defaults to a passthrough function if not provided.\n   *\n   * @remark The hook will revalidate every time the transform function changes, so it is important to use [useCallback](https://react.dev/reference/react/useCallback) to ensure it only changes when necessary to prevent unnecessary re-renders or computations.\n   *\n   * @example\n   * ```\n   * // For data: `{ \"data\": [ { \"type\": \"folder\", \"name\": \"item 1\", \"children\": [ { \"type\": \"item\", \"name\": \"item 2\" }, { \"type\": \"item\", \"name\": \"item 3\" } ] }, { \"type\": \"folder\", \"name\": \"item 4\", children: [] } ] }`\n   *\n   * type Item = {\n   *  type: \"item\";\n   *  name: string;\n   * };\n   *\n   * type Folder = {\n   *   type: \"folder\";\n   *   name: string;\n   *   children: (Item | Folder)[];\n   * };\n   *\n   * function flatten(item: Item | Folder): { name: string }[] {\n   *   const flattened: { name: string }[] = [];\n   *   if (item.type === \"folder\") {\n   *     flattened.push(...item.children.map(flatten).flat());\n   *   }\n   *   if (item.type === \"item\") {\n   *     flattened.push({ name: item.name });\n   *   }\n   *   return flattened;\n   * }\n   *\n   * const transform = useCallback(flatten, []);\n   * const filter = useCallback((item: { name: string }) => {\n   *   \n   * })\n   * ```\n   */\n  transform?: (item: any) => T;\n  /**\n   * The amount of items to return for each page.\n   * Defaults to `20`.\n   */\n  pageSize?: number;\n};\n\n/**\n * Takes a `http://`, `https://` or `file:///` URL pointing to a JSON resource, caches it to the command's support\n * folder, and streams through its content. Useful when dealing with large JSON arrays which would be too big to fit\n * in the command's memory.\n *\n * @remark The JSON resource needs to consist of an array of objects\n *\n * @example\n * ```\n * import { List } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const { data, isLoading, pagination } = useStreamJSON<Formula>(\"https://formulae.brew.sh/api/formula.json\");\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination}>\n *       <List.Section title=\"Formulae\">\n *         {data?.map((d) => <List.Item key={d.name} title={d.name} subtitle={d.desc} />)}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ```\n *\n * @example\n * ```\n * import { List } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n * import { homedir } from \"os\";\n * import { join } from \"path\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const { data, isLoading, pagination } = useStreamJSON<Formula>(`file:///${join(homedir(), \"Downloads\", \"formulae.json\")}`);\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination}>\n *       <List.Section title=\"Formulae\">\n *         {data?.map((d) => <List.Item key={d.name} title={d.name} subtitle={d.desc} />)}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useStreamJSON<T, U = unknown>(url: RequestInfo): UseCachedPromiseReturnType<T, U>;\n\n/**\n * Takes a `http://`, `https://` or `file:///` URL pointing to a JSON resource, caches it to the command's support\n * folder, and streams through its content. Useful when dealing with large JSON arrays which would be too big to fit\n * in the command's memory.\n *\n * @remark The JSON resource needs to consist of an array of objects\n *\n * @example\n * ```\n * import { List, environment } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n * import { join } from 'path';\n * import { useCallback, useState } from \"react\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const formulaFilter = useCallback(\n *     (item: Formula) => {\n *       if (!searchText) return true;\n *       return item.name.toLocaleLowerCase().includes(searchText);\n *     },\n *     [searchText],\n *   );\n *\n *   const formulaTransform = useCallback((item: any): Formula => {\n *     return { name: item.name, desc: item.desc };\n *   }, []);\n *\n *   const { data, isLoading, pagination } = useStreamJSON(\"https://formulae.brew.sh/api/formula.json\", {\n *     initialData: [] as Formula[],\n *     pageSize: 20,\n *     filter: formulaFilter,\n *     transform: formulaTransform,\n *   });\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>\n *       <List.Section title=\"Formulae\">\n *         {data.map((d) => (\n *           <List.Item key={d.name} title={d.name} subtitle={d.desc} />\n *         ))}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ``` support folder, and streams through its content.\n *\n * @example\n * ```\n * import { List, environment } from \"@raycast/api\";\n * import { useStreamJSON } from \"@raycast/utils\";\n * import { join } from \"path\";\n * import { homedir } from \"os\";\n * import { useCallback, useState } from \"react\";\n *\n * type Formula = { name: string; desc?: string };\n *\n * export default function Main(): React.JSX.Element {\n *   const [searchText, setSearchText] = useState(\"\");\n *\n *   const formulaFilter = useCallback(\n *     (item: Formula) => {\n *       if (!searchText) return true;\n *       return item.name.toLocaleLowerCase().includes(searchText);\n *     },\n *     [searchText],\n *   );\n *\n *   const formulaTransform = useCallback((item: any): Formula => {\n *     return { name: item.name, desc: item.desc };\n *   }, []);\n *\n *   const { data, isLoading, pagination } = useStreamJSON(`file:///${join(homedir(), \"Downloads\", \"formulae.json\")}`, {\n *     initialData: [] as Formula[],\n *     pageSize: 20,\n *     filter: formulaFilter,\n *     transform: formulaTransform,\n *   });\n *\n *   return (\n *     <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>\n *       <List.Section title=\"Formulae\">\n *         {data.map((d) => (\n *           <List.Item key={d.name} title={d.name} subtitle={d.desc} />\n *         ))}\n *       </List.Section>\n *     </List>\n *   );\n * }\n * ```\n */\nexport function useStreamJSON<T, U extends any[] = any[]>(\n  url: RequestInfo,\n  options: Options<T> & RequestInit & Omit<CachedPromiseOptions<FunctionReturningPaginatedPromise, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T extends unknown[] ? T : T[], U>;\n\nexport function useStreamJSON<T, U extends any[] = any[]>(\n  url: RequestInfo,\n  options?: Options<T> & RequestInit & Omit<CachedPromiseOptions<FunctionReturningPaginatedPromise, U>, \"abortable\">,\n): UseCachedPromiseReturnType<T extends unknown[] ? T : T[], U> {\n  const {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n    dataPath,\n    filter,\n    transform,\n    pageSize = 20,\n    ...fetchOptions\n  } = options ?? {};\n  const previousUrl = useRef<RequestInfo>(null);\n  const previousDestination = useRef<string>(null);\n\n  const useCachedPromiseOptions: CachedPromiseOptions<FunctionReturningPaginatedPromise, U> = {\n    initialData,\n    execute,\n    keepPreviousData,\n    onError,\n    onData,\n    onWillExecute,\n    failureToastOptions,\n  };\n\n  const generatorRef = useRef<AsyncGenerator<T extends unknown[] ? T : T[]> | null>(null);\n  const controllerRef = useRef<AbortController | null>(null);\n  const hasMoreRef = useRef(false);\n\n  return useCachedPromise(\n    (\n      url: RequestInfo,\n      pageSize: number,\n      fetchOptions: RequestInit | undefined,\n      dataPath: string | RegExp | undefined,\n      filter: ((item: Flatten<T>) => boolean) | undefined,\n      transform: ((item: unknown) => T) | undefined,\n    ) =>\n      async ({ page }) => {\n        const fileName = hash(url) + \".json\";\n        const folder = environment.supportPath;\n        if (page === 0) {\n          controllerRef.current?.abort();\n          controllerRef.current = new AbortController();\n          const destination = join(folder, fileName);\n          /**\n           * Force update the cache when the URL changes but the cache destination does not.\n           */\n          const forceCacheUpdate = Boolean(\n            previousUrl.current &&\n              previousUrl.current !== url &&\n              previousDestination.current &&\n              previousDestination.current === destination,\n          );\n          previousUrl.current = url;\n          previousDestination.current = destination;\n          await cacheURLIfNecessary(url, folder, fileName, forceCacheUpdate, {\n            ...fetchOptions,\n            signal: controllerRef.current?.signal,\n          });\n          generatorRef.current = streamJsonFile(\n            destination,\n            pageSize,\n            controllerRef.current?.signal,\n            dataPath,\n            filter,\n            transform,\n          );\n        }\n        if (!generatorRef.current) {\n          return { hasMore: hasMoreRef.current, data: [] as T extends unknown[] ? T : T[] };\n        }\n        const { value: newData, done } = await generatorRef.current.next();\n        hasMoreRef.current = !done;\n        return { hasMore: hasMoreRef.current, data: (newData ?? []) as T extends unknown[] ? T : T[] };\n      },\n    [url, pageSize, fetchOptions, dataPath, filter, transform],\n    useCachedPromiseOptions,\n  );\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { Readable, Writable, Duplex } from \"node:stream\";\n\nexport const none = /* #__PURE__ */ Symbol.for(\"object-stream.none\");\nconst stop = /* #__PURE__ */ Symbol.for(\"object-stream.stop\");\n\nconst finalSymbol = /* #__PURE__ */ Symbol.for(\"object-stream.final\");\nconst manySymbol = /* #__PURE__ */ Symbol.for(\"object-stream.many\");\nconst flushSymbol = /* #__PURE__ */ Symbol.for(\"object-stream.flush\");\nconst fListSymbol = /* #__PURE__ */ Symbol.for(\"object-stream.fList\");\n\nconst finalValue = (value: any) => ({ [finalSymbol]: 1, value });\nexport const many = (values: any) => ({ [manySymbol]: 1, values });\n\nconst isFinalValue = (o: any) => o && o[finalSymbol] === 1;\nconst isMany = (o: any) => o && o[manySymbol] === 1;\nconst isFlushable = (o: any) => o && o[flushSymbol] === 1;\nconst isFunctionList = (o: any) => o && o[fListSymbol] === 1;\n\nconst getFinalValue = (o: any) => o.value;\nconst getManyValues = (o: any) => o.values;\nconst getFunctionList = (o: any) => o.fList;\n\nexport const combineManyMut = (a: any, b: any) => {\n  const values = a === none ? [] : a?.[manySymbol] === 1 ? a.values : [a];\n  if (b === none) {\n    // do nothing\n  } else if (b?.[manySymbol] === 1) {\n    values.push(...b.values);\n  } else {\n    values.push(b);\n  }\n  return many(values);\n};\n\nexport const flushable = (write: (value: any) => any, final = null) => {\n  const fn = final ? (value: any) => (value === none ? finalValue(undefined) : write(value)) : write;\n  // @ts-ignore\n  fn[flushSymbol] = 1;\n  return fn;\n};\n\nconst setFunctionList = (o: any, fns: any) => {\n  o.fList = fns;\n  o[fListSymbol] = 1;\n  return o;\n};\n\n// is*NodeStream functions taken from https://github.com/nodejs/node/blob/master/lib/internal/streams/utils.js\nconst isReadableNodeStream = (obj: any) =>\n  obj &&\n  typeof obj.pipe === \"function\" &&\n  typeof obj.on === \"function\" &&\n  (!obj._writableState || (typeof obj._readableState === \"object\" ? obj._readableState.readable : null) !== false) && // Duplex\n  (!obj._writableState || obj._readableState); // Writable has .pipe.\n\nconst isWritableNodeStream = (obj: any) =>\n  obj &&\n  typeof obj.write === \"function\" &&\n  typeof obj.on === \"function\" &&\n  (!obj._readableState || (typeof obj._writableState === \"object\" ? obj._writableState.writable : null) !== false); // Duplex\n\nconst isDuplexNodeStream = (obj: any) =>\n  obj &&\n  typeof obj.pipe === \"function\" &&\n  obj._readableState &&\n  typeof obj.on === \"function\" &&\n  typeof obj.write === \"function\";\n\nconst isReadableWebStream = (obj: any) => obj && globalThis.ReadableStream && obj instanceof globalThis.ReadableStream;\n\nconst isWritableWebStream = (obj: any) => obj && globalThis.WritableStream && obj instanceof globalThis.WritableStream;\n\nconst isDuplexWebStream = (obj: any) =>\n  obj &&\n  globalThis.ReadableStream &&\n  obj.readable instanceof globalThis.ReadableStream &&\n  globalThis.WritableStream &&\n  obj.writable instanceof globalThis.WritableStream;\n\nconst groupFunctions = (output: any, fn: any, index: any, fns: any) => {\n  if (\n    isDuplexNodeStream(fn) ||\n    (!index && isReadableNodeStream(fn)) ||\n    (index === fns.length - 1 && isWritableNodeStream(fn))\n  ) {\n    output.push(fn);\n    return output;\n  }\n  if (isDuplexWebStream(fn)) {\n    output.push(Duplex.fromWeb(fn, { objectMode: true }));\n    return output;\n  }\n  if (!index && isReadableWebStream(fn)) {\n    output.push(Readable.fromWeb(fn, { objectMode: true }));\n    return output;\n  }\n  if (index === fns.length - 1 && isWritableWebStream(fn)) {\n    output.push(Writable.fromWeb(fn, { objectMode: true }));\n    return output;\n  }\n  if (typeof fn != \"function\") throw TypeError(\"Item #\" + index + \" is not a proper stream, nor a function.\");\n  if (!output.length) output.push([]);\n  const last = output[output.length - 1];\n  if (Array.isArray(last)) {\n    last.push(fn);\n  } else {\n    output.push([fn]);\n  }\n  return output;\n};\n\nclass Stop extends Error {}\n\nexport const asStream = (fn: any) => {\n  if (typeof fn != \"function\") throw TypeError(\"Only a function is accepted as the first argument\");\n\n  // pump variables\n  let paused = Promise.resolve();\n  let resolvePaused: ((value: void | PromiseLike<void>) => void) | null = null;\n  const queue: any[] = [];\n\n  // pause/resume\n  const resume: any = () => {\n    if (!resolvePaused) return;\n    resolvePaused();\n    resolvePaused = null;\n    paused = Promise.resolve();\n  };\n  const pause: any = () => {\n    if (resolvePaused) return;\n    paused = new Promise((resolve) => (resolvePaused = resolve));\n  };\n\n  // eslint-disable-next-line prefer-const\n  let stream: Duplex; // will be assigned later\n\n  // data processing\n  const pushResults: any = (values: any) => {\n    if (values && typeof values.next == \"function\") {\n      // generator\n      queue.push(values);\n      return;\n    }\n    // array\n    queue.push(values[Symbol.iterator]());\n  };\n  const pump: any = async () => {\n    while (queue.length) {\n      await paused;\n      const gen = queue[queue.length - 1];\n      let result = gen.next();\n      if (result && typeof result.then == \"function\") {\n        result = await result;\n      }\n      if (result.done) {\n        queue.pop();\n        continue;\n      }\n      let value = result.value;\n      if (value && typeof value.then == \"function\") {\n        value = await value;\n      }\n      await sanitize(value);\n    }\n  };\n  const sanitize: any = async (value: any) => {\n    if (value === undefined || value === null || value === none) return;\n    if (value === stop) throw new Stop();\n\n    if (isMany(value)) {\n      pushResults(getManyValues(value));\n      return pump();\n    }\n\n    if (isFinalValue(value)) {\n      // a final value is not supported, it is treated as a regular value\n      value = getFinalValue(value);\n      return processValue(value);\n    }\n\n    if (!stream.push(value)) {\n      pause();\n    }\n  };\n  const processChunk: any = async (chunk: any, encoding: any) => {\n    try {\n      const value = fn(chunk, encoding);\n      await processValue(value);\n    } catch (error) {\n      if (error instanceof Stop) {\n        stream.push(null);\n        stream.destroy();\n        return;\n      }\n      throw error;\n    }\n  };\n  const processValue: any = async (value: any) => {\n    if (value && typeof value.then == \"function\") {\n      // thenable\n      return value.then((value: any) => processValue(value));\n    }\n    if (value && typeof value.next == \"function\") {\n      // generator\n      pushResults(value);\n      return pump();\n    }\n    return sanitize(value);\n  };\n\n  stream = new Duplex(\n    Object.assign({ writableObjectMode: true, readableObjectMode: true }, undefined, {\n      write(chunk: any, encoding: any, callback: any) {\n        processChunk(chunk, encoding).then(\n          () => callback(null),\n          (error: any) => callback(error),\n        );\n      },\n      final(callback: any) {\n        if (!isFlushable(fn)) {\n          stream.push(null);\n          callback(null);\n          return;\n        }\n        processChunk(none, null).then(\n          () => (stream.push(null), callback(null)),\n          (error: any) => callback(error),\n        );\n      },\n      read() {\n        resume();\n      },\n    }),\n  );\n\n  return stream;\n};\n\nconst produceStreams = (item: any) => {\n  if (Array.isArray(item)) {\n    if (!item.length) return null;\n    if (item.length == 1) return item[0] && asStream(item[0]);\n    return asStream(gen(...item));\n  }\n  return item;\n};\n\nconst next: any = async function* (value: any, fns: any, index: any) {\n  for (let i = index; i <= fns.length; ++i) {\n    if (value && typeof value.then == \"function\") {\n      // thenable\n      value = await value;\n    }\n    if (value === none) break;\n    if (value === stop) throw new Stop();\n    if (isFinalValue(value)) {\n      yield getFinalValue(value);\n      break;\n    }\n    if (isMany(value)) {\n      const values = getManyValues(value);\n      if (i == fns.length) {\n        yield* values;\n      } else {\n        for (let j = 0; j < values.length; ++j) {\n          yield* next(values[j], fns, i);\n        }\n      }\n      break;\n    }\n    if (value && typeof value.next == \"function\") {\n      // generator\n      for (;;) {\n        let data = value.next();\n        if (data && typeof data.then == \"function\") {\n          data = await data;\n        }\n        if (data.done) break;\n        if (i == fns.length) {\n          yield data.value;\n        } else {\n          yield* next(data.value, fns, i);\n        }\n      }\n      break;\n    }\n    if (i == fns.length) {\n      yield value;\n      break;\n    }\n    const f = fns[i];\n    value = f(value);\n  }\n};\n\nexport const gen = (...fns: any) => {\n  fns = fns\n    .filter((fn: any) => fn)\n    .flat(Infinity)\n    .map((fn: any) => (isFunctionList(fn) ? getFunctionList(fn) : fn))\n    .flat(Infinity);\n  if (!fns.length) {\n    fns = [(x: any) => x];\n  }\n  let flushed = false;\n  let g = async function* (value: any) {\n    if (flushed) throw Error(\"Call to a flushed pipe.\");\n    if (value !== none) {\n      yield* next(value, fns, 0);\n    } else {\n      flushed = true;\n      for (let i = 0; i < fns.length; ++i) {\n        const f = fns[i];\n        if (isFlushable(f)) {\n          yield* next(f(none), fns, i + 1);\n        }\n      }\n    }\n  };\n  const needToFlush = fns.some((fn: any) => isFlushable(fn));\n  if (needToFlush) g = flushable(g);\n  return setFunctionList(g, fns);\n};\n\nconst write = (input: any, chunk: any, encoding: any, callback: any) => {\n  let error: any = null;\n  try {\n    input.write(chunk, encoding, (e: any) => callback(e || error));\n  } catch (e) {\n    error = e;\n  }\n};\n\nconst final = (input: any, callback: any) => {\n  let error: any = null;\n  try {\n    input.end(null, null, (e: any) => callback(e || error));\n  } catch (e) {\n    error = e;\n  }\n};\n\nconst read = (output: any) => {\n  output.resume();\n};\n\nexport default function chain(fns: any) {\n  fns = fns.flat(Infinity).filter((fn: any) => fn);\n\n  const streams = fns\n      .map((fn: any) => (isFunctionList(fn) ? getFunctionList(fn) : fn))\n      .flat(Infinity)\n      .reduce(groupFunctions, [])\n      .map(produceStreams)\n      .filter((s: any) => s),\n    input = streams[0],\n    output = streams.reduce((output: any, item: any) => (output && output.pipe(item)) || item);\n\n  // eslint-disable-next-line prefer-const\n  let stream: Duplex; // will be assigned later\n\n  let writeMethod = (chunk: any, encoding: any, callback: any) => write(input, chunk, encoding, callback),\n    finalMethod = (callback: any) => final(input, callback),\n    readMethod = () => read(output);\n\n  if (!isWritableNodeStream(input)) {\n    writeMethod = (_1, _2, callback) => callback(null);\n    finalMethod = (callback) => callback(null);\n    input.on(\"end\", () => stream.end());\n  }\n\n  if (isReadableNodeStream(output)) {\n    output.on(\"data\", (chunk: any) => !stream.push(chunk) && output.pause());\n    output.on(\"end\", () => stream.push(null));\n  } else {\n    readMethod = () => {}; // nop\n    output.on(\"finish\", () => stream.push(null));\n  }\n\n  stream = new Duplex(\n    Object.assign(\n      { writableObjectMode: true, readableObjectMode: true },\n      {\n        readable: isReadableNodeStream(output),\n        writable: isWritableNodeStream(input),\n        write: writeMethod,\n        final: finalMethod,\n        read: readMethod,\n      },\n    ),\n  );\n  // @ts-ignore\n  stream.streams = streams;\n  // @ts-ignore\n  stream.input = input;\n  // @ts-ignore\n  stream.output = output;\n\n  if (!isReadableNodeStream(output)) {\n    stream.resume();\n  }\n\n  // connect events\n  streams.forEach((item: any) => item.on(\"error\", (error: any) => stream.emit(\"error\", error)));\n\n  return stream;\n}\n", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-control-regex */\n/* eslint-disable no-useless-escape */\nimport { flushable, gen, many, none, combineManyMut } from \"./stream-chain\";\nimport { StringDecoder } from \"node:string_decoder\";\nimport EventEmitter from \"node:events\";\n\nconst fixUtf8Stream = () => {\n  const stringDecoder = new StringDecoder();\n  let input = \"\";\n  return flushable((chunk: any) => {\n    if (chunk === none) {\n      const result = input + stringDecoder.end();\n      input = \"\";\n      return result;\n    }\n    if (typeof chunk == \"string\") {\n      if (!input) return chunk;\n      const result = input + chunk;\n      input = \"\";\n      return result;\n    }\n    if (chunk instanceof Buffer) {\n      const result = input + stringDecoder.write(chunk);\n      input = \"\";\n      return result;\n    }\n    throw new TypeError(\"Expected a string or a Buffer\");\n  });\n};\n\nconst patterns = {\n  value1: /[\\\"\\{\\[\\]\\-\\d]|true\\b|false\\b|null\\b|\\s{1,256}/y,\n  string: /[^\\x00-\\x1f\\\"\\\\]{1,256}|\\\\[bfnrt\\\"\\\\\\/]|\\\\u[\\da-fA-F]{4}|\\\"/y,\n  key1: /[\\\"\\}]|\\s{1,256}/y,\n  colon: /\\:|\\s{1,256}/y,\n  comma: /[\\,\\]\\}]|\\s{1,256}/y,\n  ws: /\\s{1,256}/y,\n  numberStart: /\\d/y,\n  numberDigit: /\\d{0,256}/y,\n  numberFraction: /[\\.eE]/y,\n  numberExponent: /[eE]/y,\n  numberExpSign: /[-+]/y,\n};\nconst MAX_PATTERN_SIZE = 16;\n\nconst values: { [key: string]: any } = { true: true, false: false, null: null },\n  expected: { [key: string]: string } = { object: \"objectStop\", array: \"arrayStop\", \"\": \"done\" };\n\n// long hexadecimal codes: \\uXXXX\nconst fromHex = (s: string) => String.fromCharCode(parseInt(s.slice(2), 16));\n\n// short codes: \\b \\f \\n \\r \\t \\\" \\\\ \\/\nconst codes: { [key: string]: string } = {\n  b: \"\\b\",\n  f: \"\\f\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\\t\",\n  '\"': '\"',\n  \"\\\\\": \"\\\\\",\n  \"/\": \"/\",\n};\n\nconst jsonParser = (options?: any) => {\n  let packKeys = true,\n    packStrings = true,\n    packNumbers = true,\n    streamKeys = true,\n    streamStrings = true,\n    streamNumbers = true,\n    jsonStreaming = false;\n\n  if (options) {\n    \"packValues\" in options && (packKeys = packStrings = packNumbers = options.packValues);\n    \"packKeys\" in options && (packKeys = options.packKeys);\n    \"packStrings\" in options && (packStrings = options.packStrings);\n    \"packNumbers\" in options && (packNumbers = options.packNumbers);\n    \"streamValues\" in options && (streamKeys = streamStrings = streamNumbers = options.streamValues);\n    \"streamKeys\" in options && (streamKeys = options.streamKeys);\n    \"streamStrings\" in options && (streamStrings = options.streamStrings);\n    \"streamNumbers\" in options && (streamNumbers = options.streamNumbers);\n    jsonStreaming = options.jsonStreaming;\n  }\n\n  !packKeys && (streamKeys = true);\n  !packStrings && (streamStrings = true);\n  !packNumbers && (streamNumbers = true);\n\n  let done = false,\n    expect = jsonStreaming ? \"done\" : \"value\",\n    parent = \"\",\n    openNumber = false,\n    accumulator = \"\",\n    buffer = \"\";\n\n  const stack: any[] = [];\n\n  return flushable((buf: any) => {\n    const tokens: any[] = [];\n\n    if (buf === none) {\n      done = true;\n    } else {\n      buffer += buf;\n    }\n\n    let match: any;\n    let value: any;\n    let index = 0;\n\n    main: for (;;) {\n      switch (expect) {\n        case \"value1\":\n        case \"value\":\n          patterns.value1.lastIndex = index;\n          match = patterns.value1.exec(buffer);\n          if (!match) {\n            if (done || index + MAX_PATTERN_SIZE < buffer.length) {\n              if (index < buffer.length) throw new Error(\"Parser cannot parse input: expected a value\");\n              throw new Error(\"Parser has expected a value\");\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          switch (value) {\n            case '\"':\n              if (streamStrings) tokens.push({ name: \"startString\" });\n              expect = \"string\";\n              break;\n            case \"{\":\n              tokens.push({ name: \"startObject\" });\n              stack.push(parent);\n              parent = \"object\";\n              expect = \"key1\";\n              break;\n            case \"[\":\n              tokens.push({ name: \"startArray\" });\n              stack.push(parent);\n              parent = \"array\";\n              expect = \"value1\";\n              break;\n            case \"]\":\n              if (expect !== \"value1\") throw new Error(\"Parser cannot parse input: unexpected token ']'\");\n              if (openNumber) {\n                if (streamNumbers) tokens.push({ name: \"endNumber\" });\n                openNumber = false;\n                if (packNumbers) {\n                  tokens.push({ name: \"numberValue\", value: accumulator });\n                  accumulator = \"\";\n                }\n              }\n              tokens.push({ name: \"endArray\" });\n              parent = stack.pop();\n              expect = expected[parent];\n              break;\n            case \"-\":\n              openNumber = true;\n              if (streamNumbers) {\n                tokens.push({ name: \"startNumber\" }, { name: \"numberChunk\", value: \"-\" });\n              }\n              packNumbers && (accumulator = \"-\");\n              expect = \"numberStart\";\n              break;\n            case \"0\":\n              openNumber = true;\n              if (streamNumbers) {\n                tokens.push({ name: \"startNumber\" }, { name: \"numberChunk\", value: \"0\" });\n              }\n              packNumbers && (accumulator = \"0\");\n              expect = \"numberFraction\";\n              break;\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n              openNumber = true;\n              if (streamNumbers) {\n                tokens.push({ name: \"startNumber\" }, { name: \"numberChunk\", value: value });\n              }\n              packNumbers && (accumulator = value);\n              expect = \"numberDigit\";\n              break;\n            case \"true\":\n            case \"false\":\n            case \"null\":\n              if (buffer.length - index === value.length && !done) break main; // wait for more input\n              tokens.push({ name: value + \"Value\", value: values[value] });\n              expect = expected[parent];\n              break;\n            // default: // ws\n          }\n          index += value.length;\n          break;\n        case \"keyVal\":\n        case \"string\":\n          patterns.string.lastIndex = index;\n          match = patterns.string.exec(buffer);\n          if (!match) {\n            if (index < buffer.length && (done || buffer.length - index >= 6))\n              throw new Error(\"Parser cannot parse input: escaped characters\");\n            if (done) throw new Error(\"Parser has expected a string value\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (expect === \"keyVal\") {\n              if (streamKeys) tokens.push({ name: \"endKey\" });\n              if (packKeys) {\n                tokens.push({ name: \"keyValue\", value: accumulator });\n                accumulator = \"\";\n              }\n              expect = \"colon\";\n            } else {\n              if (streamStrings) tokens.push({ name: \"endString\" });\n              if (packStrings) {\n                tokens.push({ name: \"stringValue\", value: accumulator });\n                accumulator = \"\";\n              }\n              expect = expected[parent];\n            }\n          } else if (value.length > 1 && value.charAt(0) === \"\\\\\") {\n            const t = value.length == 2 ? codes[value.charAt(1)] : fromHex(value);\n            if (expect === \"keyVal\" ? streamKeys : streamStrings) {\n              tokens.push({ name: \"stringChunk\", value: t });\n            }\n            if (expect === \"keyVal\" ? packKeys : packStrings) {\n              accumulator += t;\n            }\n          } else {\n            if (expect === \"keyVal\" ? streamKeys : streamStrings) {\n              tokens.push({ name: \"stringChunk\", value: value });\n            }\n            if (expect === \"keyVal\" ? packKeys : packStrings) {\n              accumulator += value;\n            }\n          }\n          index += value.length;\n          break;\n        case \"key1\":\n        case \"key\":\n          patterns.key1.lastIndex = index;\n          match = patterns.key1.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected an object key\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value === '\"') {\n            if (streamKeys) tokens.push({ name: \"startKey\" });\n            expect = \"keyVal\";\n          } else if (value === \"}\") {\n            if (expect !== \"key1\") throw new Error(\"Parser cannot parse input: unexpected token '}'\");\n            tokens.push({ name: \"endObject\" });\n            parent = stack.pop();\n            expect = expected[parent];\n          }\n          index += value.length;\n          break;\n        case \"colon\":\n          patterns.colon.lastIndex = index;\n          match = patterns.colon.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected ':'\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          value === \":\" && (expect = \"value\");\n          index += value.length;\n          break;\n        case \"arrayStop\":\n        case \"objectStop\":\n          patterns.comma.lastIndex = index;\n          match = patterns.comma.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected ','\");\n            break main; // wait for more input\n          }\n          if (openNumber) {\n            if (streamNumbers) tokens.push({ name: \"endNumber\" });\n            openNumber = false;\n            if (packNumbers) {\n              tokens.push({ name: \"numberValue\", value: accumulator });\n              accumulator = \"\";\n            }\n          }\n          value = match[0];\n          if (value === \",\") {\n            expect = expect === \"arrayStop\" ? \"value\" : \"key\";\n          } else if (value === \"}\" || value === \"]\") {\n            if (value === \"}\" ? expect === \"arrayStop\" : expect !== \"arrayStop\") {\n              throw new Error(\"Parser cannot parse input: expected '\" + (expect === \"arrayStop\" ? \"]\" : \"}\") + \"'\");\n            }\n            tokens.push({ name: value === \"}\" ? \"endObject\" : \"endArray\" });\n            parent = stack.pop();\n            expect = expected[parent];\n          }\n          index += value.length;\n          break;\n        // number chunks\n        case \"numberStart\": // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected a starting digit\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = value === \"0\" ? \"numberFraction\" : \"numberDigit\";\n          index += value.length;\n          break;\n        case \"numberDigit\": // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) throw new Error(\"Parser cannot parse input: expected a digit\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (value) {\n            if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n            packNumbers && (accumulator += value);\n            index += value.length;\n          } else {\n            if (index < buffer.length) {\n              expect = \"numberFraction\";\n              break;\n            }\n            if (done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case \"numberFraction\": // [\\.eE]?\n          patterns.numberFraction.lastIndex = index;\n          match = patterns.numberFraction.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = value === \".\" ? \"numberFracStart\" : \"numberExpSign\";\n          index += value.length;\n          break;\n        case \"numberFracStart\": // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done)\n              throw new Error(\"Parser cannot parse input: expected a fractional part of a number\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberFracDigit\";\n          index += value.length;\n          break;\n        case \"numberFracDigit\": // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(buffer);\n          value = match[0];\n          if (value) {\n            if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n            packNumbers && (accumulator += value);\n            index += value.length;\n          } else {\n            if (index < buffer.length) {\n              expect = \"numberExponent\";\n              break;\n            }\n            if (done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case \"numberExponent\": // [eE]?\n          patterns.numberExponent.lastIndex = index;\n          match = patterns.numberExponent.exec(buffer);\n          if (!match) {\n            if (index < buffer.length) {\n              expect = expected[parent];\n              break;\n            }\n            if (done) {\n              expect = \"done\";\n              break;\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberExpSign\";\n          index += value.length;\n          break;\n        case \"numberExpSign\": // [-+]?\n          patterns.numberExpSign.lastIndex = index;\n          match = patterns.numberExpSign.exec(buffer);\n          if (!match) {\n            if (index < buffer.length) {\n              expect = \"numberExpStart\";\n              break;\n            }\n            if (done) throw new Error(\"Parser has expected an exponent value of a number\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberExpStart\";\n          index += value.length;\n          break;\n        case \"numberExpStart\": // [0-9]\n          patterns.numberStart.lastIndex = index;\n          match = patterns.numberStart.exec(buffer);\n          if (!match) {\n            if (index < buffer.length || done)\n              throw new Error(\"Parser cannot parse input: expected an exponent part of a number\");\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n          packNumbers && (accumulator += value);\n          expect = \"numberExpDigit\";\n          index += value.length;\n          break;\n        case \"numberExpDigit\": // [0-9]*\n          patterns.numberDigit.lastIndex = index;\n          match = patterns.numberDigit.exec(buffer);\n          value = match[0];\n          if (value) {\n            if (streamNumbers) tokens.push({ name: \"numberChunk\", value: value });\n            packNumbers && (accumulator += value);\n            index += value.length;\n          } else {\n            if (index < buffer.length || done) {\n              expect = expected[parent];\n              break;\n            }\n            break main; // wait for more input\n          }\n          break;\n        case \"done\":\n          patterns.ws.lastIndex = index;\n          match = patterns.ws.exec(buffer);\n          if (!match) {\n            if (index < buffer.length) {\n              if (jsonStreaming) {\n                expect = \"value\";\n                break;\n              }\n              throw new Error(\"Parser cannot parse input: unexpected characters\");\n            }\n            break main; // wait for more input\n          }\n          value = match[0];\n          if (openNumber) {\n            if (streamNumbers) tokens.push({ name: \"endNumber\" });\n            openNumber = false;\n            if (packNumbers) {\n              tokens.push({ name: \"numberValue\", value: accumulator });\n              accumulator = \"\";\n            }\n          }\n          index += value.length;\n          break;\n      }\n    }\n    if (done && openNumber) {\n      if (streamNumbers) tokens.push({ name: \"endNumber\" });\n      openNumber = false;\n      if (packNumbers) {\n        tokens.push({ name: \"numberValue\", value: accumulator });\n        accumulator = \"\";\n      }\n    }\n    buffer = buffer.slice(index);\n    return tokens.length ? many(tokens) : none;\n  });\n};\n\nexport const parser = (options?: any) => gen(fixUtf8Stream(), jsonParser(options));\n\nconst withParser = (fn: any, options?: any) => gen(parser(options), fn(options));\n\nconst checkableTokens = {\n    startObject: 1,\n    startArray: 1,\n    startString: 1,\n    startNumber: 1,\n    nullValue: 1,\n    trueValue: 1,\n    falseValue: 1,\n    stringValue: 1,\n    numberValue: 1,\n  },\n  stopTokens = {\n    startObject: \"endObject\",\n    startArray: \"endArray\",\n    startString: \"endString\",\n    startNumber: \"endNumber\",\n  },\n  optionalTokens = { endString: \"stringValue\", endNumber: \"numberValue\" };\n\nconst defaultFilter = (_stack: string[], _a: any) => true;\n\nconst stringFilter = (string: string, separator: string) => {\n  const stringWithSeparator = string + separator;\n  return (stack: string[], _a: any) => {\n    const path = stack.join(separator);\n    return path === string || path.startsWith(stringWithSeparator);\n  };\n};\n\nconst regExpFilter = (regExp: RegExp, separator: string) => {\n  return (stack: string[], _a: any) => regExp.test(stack.join(separator));\n};\n\nconst filterBase =\n  ({\n    specialAction = \"accept\",\n    defaultAction = \"ignore\",\n    nonCheckableAction = \"process-key\",\n    transition = undefined as any,\n  } = {}) =>\n  (options: any) => {\n    const once = options?.once,\n      separator = options?.pathSeparator || \".\";\n    let filter = defaultFilter,\n      streamKeys = true;\n    if (options) {\n      if (typeof options.filter == \"function\") {\n        filter = options.filter;\n      } else if (typeof options.filter == \"string\") {\n        filter = stringFilter(options.filter, separator);\n      } else if (options.filter instanceof RegExp) {\n        filter = regExpFilter(options.filter, separator);\n      }\n      if (\"streamValues\" in options) streamKeys = options.streamValues;\n      if (\"streamKeys\" in options) streamKeys = options.streamKeys;\n    }\n    const sanitizedOptions = Object.assign({}, options, { filter, streamKeys, separator });\n    let state = \"check\";\n    const stack: any[] = [];\n    let depth = 0,\n      previousToken = \"\",\n      endToken = \"\",\n      optionalToken = \"\",\n      startTransition = false;\n    return flushable((chunk) => {\n      // the flush\n      if (chunk === none) return transition ? transition([], null, \"flush\", sanitizedOptions) : none;\n\n      // process the optional value token (unfinished)\n      if (optionalToken) {\n        if (optionalToken === chunk.name) {\n          let returnToken = none;\n          switch (state) {\n            case \"process-key\":\n              stack[stack.length - 1] = chunk.value;\n              state = \"check\";\n              break;\n            case \"accept-value\":\n              returnToken = chunk;\n              state = once ? \"pass\" : \"check\";\n              break;\n            default:\n              state = once ? \"all\" : \"check\";\n              break;\n          }\n          optionalToken = \"\";\n          return returnToken;\n        }\n        optionalToken = \"\";\n        state = once && state !== \"process-key\" ? \"pass\" : \"check\";\n      }\n\n      let returnToken: any = none;\n\n      recheck: for (;;) {\n        // accept/reject tokens\n        switch (state) {\n          case \"process-key\":\n            if (chunk.name === \"endKey\") optionalToken = \"keyValue\";\n            return none;\n          case \"pass\":\n            return none;\n          case \"all\":\n            return chunk;\n          case \"accept\":\n          case \"reject\":\n            if (startTransition) {\n              startTransition = false;\n              returnToken = transition(stack, chunk, state, sanitizedOptions) || none;\n            }\n            switch (chunk.name) {\n              case \"startObject\":\n              case \"startArray\":\n                ++depth;\n                break;\n              case \"endObject\":\n              case \"endArray\":\n                --depth;\n                break;\n            }\n            if (state === \"accept\") {\n              returnToken = combineManyMut(returnToken, chunk);\n            }\n            if (!depth) {\n              if (once) {\n                state = state === \"accept\" ? \"pass\" : \"all\";\n              } else {\n                state = \"check\";\n              }\n            }\n            return returnToken;\n          case \"accept-value\":\n          case \"reject-value\":\n            if (startTransition) {\n              startTransition = false;\n              returnToken = transition(stack, chunk, state, sanitizedOptions) || none;\n            }\n            if (state === \"accept-value\") {\n              returnToken = combineManyMut(returnToken, chunk);\n            }\n            if (chunk.name === endToken) {\n              // @ts-ignore\n              optionalToken = optionalTokens[endToken] || \"\";\n              endToken = \"\";\n              if (!optionalToken) {\n                if (once) {\n                  state = state === \"accept-value\" ? \"pass\" : \"all\";\n                } else {\n                  state = \"check\";\n                }\n              }\n            }\n            return returnToken;\n        }\n\n        // update the last index in the stack\n        if (typeof stack[stack.length - 1] == \"number\") {\n          // array\n          switch (chunk.name) {\n            case \"startObject\":\n            case \"startArray\":\n            case \"startString\":\n            case \"startNumber\":\n            case \"nullValue\":\n            case \"trueValue\":\n            case \"falseValue\":\n              ++stack[stack.length - 1];\n              break;\n            case \"numberValue\":\n              if (previousToken !== \"endNumber\") ++stack[stack.length - 1];\n              break;\n            case \"stringValue\":\n              if (previousToken !== \"endString\") ++stack[stack.length - 1];\n              break;\n          }\n        } else {\n          if (chunk.name === \"keyValue\") stack[stack.length - 1] = chunk.value;\n        }\n        previousToken = chunk.name;\n\n        // check the token\n        const action =\n          // @ts-ignore\n          checkableTokens[chunk.name] !== 1 ? nonCheckableAction : filter(stack, chunk) ? specialAction : defaultAction;\n\n        // @ts-ignore\n        endToken = stopTokens[chunk.name] || \"\";\n        switch (action) {\n          case \"process-key\":\n            if (chunk.name === \"startKey\") {\n              state = \"process-key\";\n              continue recheck;\n            }\n            break;\n          case \"accept-token\":\n            // @ts-ignore\n            if (endToken && optionalTokens[endToken]) {\n              state = \"accept-value\";\n              startTransition = !!transition;\n              continue recheck;\n            }\n            if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);\n            returnToken = combineManyMut(returnToken, chunk);\n            break;\n          case \"accept\":\n            if (endToken) {\n              // @ts-ignore\n              state = optionalTokens[endToken] ? \"accept-value\" : \"accept\";\n              startTransition = !!transition;\n              continue recheck;\n            }\n            if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);\n            returnToken = combineManyMut(returnToken, chunk);\n            break;\n          case \"reject\":\n            if (endToken) {\n              // @ts-ignore\n              state = optionalTokens[endToken] ? \"reject-value\" : \"reject\";\n              startTransition = !!transition;\n              continue recheck;\n            }\n            if (transition) returnToken = transition(stack, chunk, action, sanitizedOptions);\n            break;\n          case \"pass\":\n            state = \"pass\";\n            continue recheck;\n        }\n\n        break;\n      }\n\n      // update the stack\n      switch (chunk.name) {\n        case \"startObject\":\n          stack.push(null);\n          break;\n        case \"startArray\":\n          stack.push(-1);\n          break;\n        case \"endObject\":\n        case \"endArray\":\n          stack.pop();\n          break;\n      }\n\n      return returnToken;\n    });\n  };\n\nexport const PickParser = (options?: any) => withParser(filterBase(), Object.assign({ packKeys: true }, options));\n\nclass Counter {\n  depth: number;\n  constructor(initialDepth: number) {\n    this.depth = initialDepth;\n  }\n  startObject() {\n    ++this.depth;\n  }\n  endObject() {\n    --this.depth;\n  }\n  startArray() {\n    ++this.depth;\n  }\n  endArray() {\n    --this.depth;\n  }\n}\n\nclass Assembler extends EventEmitter {\n  static connectTo(stream: any, options: any) {\n    return new Assembler(options).connectTo(stream);\n  }\n\n  stack: any;\n  current: any;\n  key: any;\n  done: boolean;\n  reviver: any;\n  // @ts-ignore\n  stringValue: (value: string) => void;\n  tapChain: (chunk: any) => any;\n\n  constructor(options: any) {\n    super();\n    this.stack = [];\n    this.current = this.key = null;\n    this.done = true;\n    if (options) {\n      this.reviver = typeof options.reviver == \"function\" && options.reviver;\n      if (this.reviver) {\n        this.stringValue = this._saveValue = this._saveValueWithReviver;\n      }\n      if (options.numberAsString) {\n        // @ts-ignore\n        this.numberValue = this.stringValue;\n      }\n    }\n\n    this.tapChain = (chunk) => {\n      // @ts-ignore\n      if (this[chunk.name]) {\n        // @ts-ignore\n        this[chunk.name](chunk.value);\n        if (this.done) return this.current;\n      }\n      return none;\n    };\n\n    this.stringValue = this._saveValue;\n  }\n\n  connectTo(stream: any) {\n    stream.on(\"data\", (chunk: any) => {\n      // @ts-ignore\n      if (this[chunk.name]) {\n        // @ts-ignore\n        this[chunk.name](chunk.value);\n        // @ts-ignore\n        if (this.done) this.emit(\"done\", this);\n      }\n    });\n    return this;\n  }\n\n  get depth() {\n    return (this.stack.length >> 1) + (this.done ? 0 : 1);\n  }\n\n  get path() {\n    const path: any[] = [];\n    for (let i = 0; i < this.stack.length; i += 2) {\n      const key = this.stack[i + 1];\n      path.push(key === null ? this.stack[i].length : key);\n    }\n    return path;\n  }\n\n  dropToLevel(level: any) {\n    if (level < this.depth) {\n      if (level > 0) {\n        const index = (level - 1) << 1;\n        this.current = this.stack[index];\n        this.key = this.stack[index + 1];\n        this.stack.splice(index);\n      } else {\n        this.stack = [];\n        this.current = this.key = null;\n        this.done = true;\n      }\n    }\n    return this;\n  }\n\n  consume(chunk: any) {\n    // @ts-ignore\n    this[chunk.name] && this[chunk.name](chunk.value);\n    return this;\n  }\n\n  keyValue(value: any) {\n    this.key = value;\n  }\n\n  //stringValue() - aliased below to _saveValue()\n\n  numberValue(value: any) {\n    this._saveValue(parseFloat(value));\n  }\n  nullValue() {\n    this._saveValue(null);\n  }\n  trueValue() {\n    this._saveValue(true);\n  }\n  falseValue() {\n    this._saveValue(false);\n  }\n\n  startObject() {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = new Object();\n    this.key = null;\n  }\n\n  endObject() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  startArray() {\n    if (this.done) {\n      this.done = false;\n    } else {\n      this.stack.push(this.current, this.key);\n    }\n    this.current = [];\n    this.key = null;\n  }\n\n  endArray() {\n    if (this.stack.length) {\n      const value = this.current;\n      this.key = this.stack.pop();\n      this.current = this.stack.pop();\n      this._saveValue(value);\n    } else {\n      this.done = true;\n    }\n  }\n\n  _saveValue(value: any) {\n    if (this.done) {\n      this.current = value;\n    } else {\n      if (this.current instanceof Array) {\n        this.current.push(value);\n      } else {\n        this.current[this.key] = value;\n        this.key = null;\n      }\n    }\n  }\n  _saveValueWithReviver(value: any) {\n    if (this.done) {\n      this.current = this.reviver(\"\", value);\n    } else {\n      if (this.current instanceof Array) {\n        value = this.reviver(\"\" + this.current.length, value);\n        this.current.push(value);\n        if (value === undefined) {\n          delete this.current[this.current.length - 1];\n        }\n      } else {\n        value = this.reviver(this.key, value);\n        if (value !== undefined) {\n          this.current[this.key] = value;\n        }\n        this.key = null;\n      }\n    }\n  }\n}\n\nconst streamBase =\n  ({ push, first, level }: any) =>\n  (options = {} as any) => {\n    const { objectFilter, includeUndecided } = options;\n    let asm = new Assembler(options) as any,\n      state = first ? \"first\" : \"check\",\n      savedAsm = null as any;\n\n    if (typeof objectFilter != \"function\") {\n      // no object filter + no first check\n      if (state === \"check\")\n        return (chunk: any) => {\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            if (asm.depth === level) {\n              return push(asm);\n            }\n          }\n          return none;\n        };\n      // no object filter\n      return (chunk: any) => {\n        switch (state) {\n          case \"first\":\n            first(chunk);\n            state = \"accept\";\n          // fall through\n          case \"accept\":\n            if (asm[chunk.name]) {\n              asm[chunk.name](chunk.value);\n              if (asm.depth === level) {\n                return push(asm);\n              }\n            }\n            break;\n        }\n        return none;\n      };\n    }\n\n    // object filter + a possible first check\n    return (chunk: any) => {\n      switch (state) {\n        case \"first\":\n          first(chunk);\n          state = \"check\";\n        // fall through\n        case \"check\":\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            const result = objectFilter(asm);\n            if (result) {\n              state = \"accept\";\n              if (asm.depth === level) return push(asm);\n            } else if (result === false) {\n              if (asm.depth === level) return push(asm, true);\n              state = \"reject\";\n              savedAsm = asm;\n              asm = new Counter(savedAsm.depth);\n              savedAsm.dropToLevel(level);\n            } else {\n              if (asm.depth === level) return push(asm, !includeUndecided);\n            }\n          }\n          break;\n        case \"accept\":\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            if (asm.depth === level) {\n              state = \"check\";\n              return push(asm);\n            }\n          }\n          break;\n        case \"reject\":\n          if (asm[chunk.name]) {\n            asm[chunk.name](chunk.value);\n            if (asm.depth === level) {\n              state = \"check\";\n              asm = savedAsm;\n              savedAsm = null;\n              return push(asm, true);\n            }\n          }\n          break;\n      }\n      return none;\n    };\n  };\n\nexport const StreamArray = (options?: any) => {\n  let key = 0;\n  return streamBase({\n    level: 1,\n\n    first(chunk: any) {\n      if (chunk.name !== \"startArray\") throw new Error(\"Top-level object should be an array.\");\n    },\n\n    push(asm: any, discard: any) {\n      if (asm.current.length) {\n        if (discard) {\n          ++key;\n          asm.current.pop();\n        } else {\n          return { key: key++, value: asm.current.pop() };\n        }\n      }\n      return none;\n    },\n  })(options);\n};\n", "import { List, MenuBarExtra, Icon, open, LaunchType, environment, ActionPanel, Action } from \"@raycast/api\";\nimport { existsSync } from \"node:fs\";\nimport os from \"node:os\";\nimport { useRef, useState, useCallback, useMemo } from \"react\";\nimport { usePromise, PromiseOptions } from \"./usePromise\";\nimport { useLatest } from \"./useLatest\";\nimport { showFailureToast } from \"./showFailureToast\";\nimport { baseExecuteSQL, PermissionError, isPermissionError } from \"./sql-utils\";\n\n/**\n * Executes a query on a local SQL database and returns the {@link AsyncState} corresponding to the query of the command. The last value will be kept between command runs.\n *\n * @example\n * ```\n * import { useSQL } from \"@raycast/utils\";\n * import { resolve } from \"path\";\n * import { homedir } from \"os\";\n *\n * const NOTES_DB = resolve(homedir(), \"Library/Group Containers/group.com.apple.notes/NoteStore.sqlite\");\n * const notesQuery = `SELECT id, title FROM ...`;\n * type NoteItem = {\n *   id: string;\n *   title: string;\n * };\n *\n * export default function Command() {\n *   const { isLoading, data, permissionView } = useSQL<NoteItem>(NOTES_DB, notesQuery);\n *\n *   if (permissionView) {\n *     return permissionView;\n *   }\n *\n *   return (\n *     <List isLoading={isLoading}>\n *       {(data || []).map((item) => (\n *         <List.Item key={item.id} title={item.title} />\n *       ))}\n *     </List>\n *  );\n * };\n * ```\n */\nexport function useSQL<T = unknown>(\n  databasePath: string,\n  query: string,\n  options?: {\n    /** A string explaining why the extension needs full disk access. For example, the Apple Notes extension uses `\"This is required to search your Apple Notes.\"`. While it is optional, we recommend setting it to help users understand. */\n    permissionPriming?: string;\n  } & Omit<PromiseOptions<(database: string, query: string) => Promise<T[]>>, \"abortable\">,\n) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { permissionPriming, ...usePromiseOptions } = options || {};\n\n  const [permissionView, setPermissionView] = useState<React.JSX.Element | null>(null);\n  const latestOptions = useLatest(options || {});\n  const abortable = useRef<AbortController>(null);\n\n  const handleError = useCallback(\n    (_error: Error) => {\n      console.error(_error);\n      const error =\n        _error instanceof Error && _error.message.includes(\"authorization denied\")\n          ? new PermissionError(\"You do not have permission to access the database.\")\n          : (_error as Error);\n\n      if (isPermissionError(error)) {\n        setPermissionView(<PermissionErrorScreen priming={latestOptions.current.permissionPriming} />);\n      } else {\n        if (latestOptions.current.onError) {\n          latestOptions.current.onError(error);\n        } else {\n          if (environment.launchType !== LaunchType.Background) {\n            showFailureToast(error, {\n              title: \"Cannot query the data\",\n            });\n          }\n        }\n      }\n    },\n    [latestOptions],\n  );\n\n  const fn = useMemo(() => {\n    if (!existsSync(databasePath)) {\n      throw new Error(\"The database does not exist\");\n    }\n\n    return async (databasePath: string, query: string) => {\n      const abortSignal = abortable.current?.signal;\n      return baseExecuteSQL<T>(databasePath, query, { signal: abortSignal });\n    };\n  }, [databasePath]);\n\n  return {\n    ...usePromise(fn, [databasePath, query], { ...usePromiseOptions, onError: handleError }),\n    permissionView,\n  };\n}\n\nfunction PermissionErrorScreen(props: { priming?: string }) {\n  const macosVenturaAndLater = parseInt(os.release().split(\".\")[0]) >= 22;\n  const preferencesString = macosVenturaAndLater ? \"Settings\" : \"Preferences\";\n\n  const action = macosVenturaAndLater\n    ? {\n        title: \"Open System Settings -> Privacy\",\n        target: \"x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles\",\n      }\n    : {\n        title: \"Open System Preferences -> Security\",\n        target: \"x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles\",\n      };\n\n  if (environment.commandMode === \"menu-bar\") {\n    return (\n      <MenuBarExtra icon={Icon.Warning} title={environment.commandName}>\n        <MenuBarExtra.Item\n          title=\"Raycast needs full disk access\"\n          tooltip={`You can revert this access in ${preferencesString} whenever you want`}\n        />\n        {props.priming ? (\n          <MenuBarExtra.Item\n            title={props.priming}\n            tooltip={`You can revert this access in ${preferencesString} whenever you want`}\n          />\n        ) : null}\n        <MenuBarExtra.Separator />\n        <MenuBarExtra.Item title={action.title} onAction={() => open(action.target)} />\n      </MenuBarExtra>\n    );\n  }\n\n  return (\n    <List>\n      <List.EmptyView\n        icon={{\n          source: {\n            light: \"https://raycast.com/uploads/extensions-utils-security-permissions-light.png\",\n            dark: \"https://raycast.com/uploads/extensions-utils-security-permissions-dark.png\",\n          },\n        }}\n        title=\"Raycast needs full disk access.\"\n        description={`${\n          props.priming ? props.priming + \"\\n\" : \"\"\n        }You can revert this access in ${preferencesString} whenever you want.`}\n        actions={\n          <ActionPanel>\n            <Action.Open {...action} />\n          </ActionPanel>\n        }\n      />\n    </List>\n  );\n}\n", "import { existsSync } from \"node:fs\";\nimport { copyFile, mkdir, writeFile } from \"node:fs/promises\";\nimport os from \"node:os\";\nimport childProcess from \"node:child_process\";\nimport path from \"node:path\";\nimport { getSpawnedPromise, getSpawnedResult } from \"./exec-utils\";\nimport { hash } from \"./helpers\";\n\nexport class PermissionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PermissionError\";\n  }\n}\n\nexport function isPermissionError(error: unknown): error is PermissionError {\n  return error instanceof Error && error.name === \"PermissionError\";\n}\n\nexport async function baseExecuteSQL<T = unknown>(\n  databasePath: string,\n  query: string,\n  options?: {\n    signal?: AbortSignal;\n  },\n): Promise<T[]> {\n  if (!existsSync(databasePath)) {\n    throw new Error(\"The database does not exist\");\n  }\n\n  let sqlite3: typeof import(\"node:sqlite\");\n  try {\n    // this is a bit ugly but we can't directly import \"node:sqlite\" here because parcel will hoist it anyway and it will break when it's not available\n    const dynamicImport = (module: string) => import(module);\n    sqlite3 = await dynamicImport(\"node:sqlite\");\n  } catch (error) {\n    // If sqlite3 is not available, we fallback to using the sqlite3 CLI (available on macOS and Linux by default).\n    return sqliteFallback<T>(databasePath, query, options);\n  }\n\n  let db = new sqlite3.DatabaseSync(databasePath, { open: false, readOnly: true });\n\n  const abortSignal = options?.signal;\n\n  try {\n    db.open();\n  } catch (error: any) {\n    console.log(error);\n    if (error.message.match(\"(5)\") || error.message.match(\"(14)\")) {\n      // That means that the DB is busy because of another app is locking it\n      // This happens when Chrome or Arc is opened: they lock the History db.\n      // As an ugly workaround, we duplicate the file and read that instead\n      // (with vfs unix - none to just not care about locks)\n      let workaroundCopiedDb: string | undefined;\n      if (!workaroundCopiedDb) {\n        const tempFolder = path.join(os.tmpdir(), \"useSQL\", hash(databasePath));\n        await mkdir(tempFolder, { recursive: true });\n        checkAborted(abortSignal);\n\n        workaroundCopiedDb = path.join(tempFolder, \"db.db\");\n        await copyFile(databasePath, workaroundCopiedDb);\n\n        await writeFile(workaroundCopiedDb + \"-shm\", \"\");\n        await writeFile(workaroundCopiedDb + \"-wal\", \"\");\n\n        checkAborted(abortSignal);\n      }\n\n      db = new sqlite3.DatabaseSync(workaroundCopiedDb, { open: false, readOnly: true });\n      db.open();\n      checkAborted(abortSignal);\n    }\n  }\n\n  const statement = db.prepare(query);\n  checkAborted(abortSignal);\n\n  const result = statement.all();\n\n  db.close();\n\n  return result as T[];\n}\n\nasync function sqliteFallback<T = unknown>(\n  databasePath: string,\n  query: string,\n  options?: {\n    signal?: AbortSignal;\n  },\n): Promise<T[]> {\n  const abortSignal = options?.signal;\n\n  let spawned = childProcess.spawn(\"sqlite3\", [\"--json\", \"--readonly\", databasePath, query], { signal: abortSignal });\n  let spawnedPromise = getSpawnedPromise(spawned);\n  let [{ error, exitCode, signal }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n    spawned,\n    { encoding: \"utf-8\" },\n    spawnedPromise,\n  );\n  checkAborted(abortSignal);\n\n  if (stderrResult.match(\"(5)\") || stderrResult.match(\"(14)\")) {\n    // That means that the DB is busy because of another app is locking it\n    // This happens when Chrome or Arc is opened: they lock the History db.\n    // As an ugly workaround, we duplicate the file and read that instead\n    // (with vfs unix - none to just not care about locks)\n    let workaroundCopiedDb: string | undefined;\n    if (!workaroundCopiedDb) {\n      const tempFolder = path.join(os.tmpdir(), \"useSQL\", hash(databasePath));\n      await mkdir(tempFolder, { recursive: true });\n      checkAborted(abortSignal);\n\n      workaroundCopiedDb = path.join(tempFolder, \"db.db\");\n      await copyFile(databasePath, workaroundCopiedDb);\n\n      await writeFile(workaroundCopiedDb + \"-shm\", \"\");\n      await writeFile(workaroundCopiedDb + \"-wal\", \"\");\n\n      checkAborted(abortSignal);\n    }\n\n    spawned = childProcess.spawn(\"sqlite3\", [\"--json\", \"--readonly\", \"--vfs\", \"unix-none\", workaroundCopiedDb, query], {\n      signal: abortSignal,\n    });\n    spawnedPromise = getSpawnedPromise(spawned);\n    [{ error, exitCode, signal }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n      spawned,\n      { encoding: \"utf-8\" },\n      spawnedPromise,\n    );\n    checkAborted(abortSignal);\n  }\n\n  if (error || exitCode !== 0 || signal !== null) {\n    if (stderrResult.includes(\"authorization denied\")) {\n      throw new PermissionError(\"You do not have permission to access the database.\");\n    } else {\n      throw new Error(stderrResult || \"Unknown error\");\n    }\n  }\n\n  return JSON.parse(stdoutResult.trim() || \"[]\") as T[];\n}\n\nfunction checkAborted(signal?: AbortSignal) {\n  if (signal?.aborted) {\n    const error = new Error(\"aborted\");\n    error.name = \"AbortError\";\n    throw error;\n  }\n}\n", "import { Form } from \"@raycast/api\";\nimport { useState, useCallback, useMemo, useRef, SetStateAction } from \"react\";\nimport { useLatest } from \"./useLatest\";\n\n/**\n * Shorthands for common validation cases\n */\nexport enum FormValidation {\n  /** Show an error when the value of the item is empty */\n  Required = \"required\",\n}\n\ntype ValidationError = string | undefined | null;\ntype Validator<ValueType> = ((value: ValueType | undefined) => ValidationError) | FormValidation;\n\nfunction validationError<ValueType>(\n  validation: Validator<ValueType> | undefined,\n  value: ValueType | undefined,\n): ValidationError {\n  if (validation) {\n    if (typeof validation === \"function\") {\n      return validation(value);\n    } else if (validation === FormValidation.Required) {\n      let valueIsValid = typeof value !== \"undefined\" && value !== null;\n      if (valueIsValid) {\n        switch (typeof value) {\n          case \"string\":\n            valueIsValid = value.length > 0;\n            break;\n          case \"object\":\n            if (Array.isArray(value)) {\n              valueIsValid = value.length > 0;\n            } else if (value instanceof Date) {\n              valueIsValid = value.getTime() > 0;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      if (!valueIsValid) {\n        return \"The item is required\";\n      }\n    }\n  }\n}\n\ntype Validation<T extends Form.Values> = { [id in keyof T]?: Validator<T[id]> };\n\ninterface FormProps<T extends Form.Values> {\n  /** Function to pass to the `onSubmit` prop of the `<Action.SubmitForm>` element. It wraps the initial `onSubmit` argument with some goodies related to the validation. */\n  handleSubmit: (values: T) => void | boolean | Promise<void | boolean>;\n  /** The props that must be passed to the `<Form.Item>` elements to handle the validations. */\n  itemProps: {\n    [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & {\n      id: string;\n    };\n  };\n  /** Function that can be used to programmatically set the validation of a specific field. */\n  setValidationError: (id: keyof T, error: ValidationError) => void;\n  /** Function that can be used to programmatically set the value of a specific field. */\n  setValue: <K extends keyof T>(id: K, value: SetStateAction<T[K]>) => void;\n  /** The current values of the form. */\n  values: T;\n  /** Function that can be used to programmatically focus a specific field. */\n  focus: (id: keyof T) => void;\n  /** Function that can be used to reset the values of the Form. */\n  reset: (initialValues?: Partial<T>) => void;\n}\n\n/**\n * Hook that provides a high-level interface to work with Forms, and more particularly, with Form validations. It incorporates all the good practices to provide a great User Experience for your Forms.\n *\n * @returns an object which contains the necessary methods and props to provide a good User Experience in your Form.\n *\n * @example\n * ```\n * import { Action, ActionPanel, Form, showToast, Toast } from \"@raycast/api\";\n * import { useForm, FormValidation } from \"@raycast/utils\";\n *\n * interface SignUpFormValues {\n *   nickname: string;\n *   password: string;\n * }\n *\n * export default function Command() {\n *   const { handleSubmit, itemProps } = useForm<SignUpFormValues>({\n *     onSubmit(values) {\n *       showToast(Toast.Style.Success, \"Yay!\", `${values.nickname} account created`);\n *     },\n *     validation: {\n *       nickname: FormValidation.Required,\n *       password: (value) => {\n *         if (value && value.length < 8) {\n *           return \"Password must be at least 8 symbols\";\n *         } else if (!value) {\n *           return \"The item is required\";\n *         }\n *       },\n *     },\n *   });\n *\n *   return (\n *     <Form\n *       actions={\n *         <ActionPanel>\n *           <Action.SubmitForm title=\"Submit\" onSubmit={handleSubmit} />\n *         </ActionPanel>\n *       }\n *     >\n *       <Form.TextField title=\"Nickname\" placeholder=\"Enter your nickname\" {...itemProps.nickname} />\n *       <Form.PasswordField\n *         title=\"Password\"\n *         placeholder=\"Enter password at least 8 characters long\"\n *         {...itemProps.password}\n *       />\n *     </Form>\n *   );\n * }\n * ```\n */\nexport function useForm<T extends Form.Values>(props: {\n  /** Callback that will be called when the form is submitted and all validations pass. */\n  onSubmit: (values: T) => void | boolean | Promise<void | boolean>;\n  /** The initial values to set when the Form is first rendered. */\n  initialValues?: Partial<T>;\n  /** The validation rules for the Form. A validation for a Form item is a function that takes the current value of the item as an argument and must return a string when the validation is failing.\n   *\n   * There are also some shorthands for common cases, see {@link FormValidation}.\n   * */\n  validation?: Validation<T>;\n}): FormProps<T> {\n  const { onSubmit: _onSubmit, validation, initialValues = {} } = props;\n\n  // @ts-expect-error it's fine if we don't specify all the values\n  const [values, setValues] = useState<T>(initialValues);\n  const [errors, setErrors] = useState<{ [id in keyof T]?: ValidationError }>({});\n  const refs = useRef<{ [id in keyof T]?: Form.ItemReference }>({});\n\n  const latestValidation = useLatest<Validation<T>>(validation || {});\n  const latestOnSubmit = useLatest(_onSubmit);\n\n  const focus = useCallback(\n    (id: keyof T) => {\n      refs.current[id]?.focus();\n    },\n    [refs],\n  );\n\n  const handleSubmit = useCallback(\n    async (values: T): Promise<boolean> => {\n      let validationErrors: false | { [key in keyof T]?: ValidationError } = false;\n      for (const [id, validation] of Object.entries(latestValidation.current)) {\n        const error = validationError(validation, values[id]);\n        if (error) {\n          if (!validationErrors) {\n            validationErrors = {};\n            // we focus the first item that has an error\n            focus(id);\n          }\n          validationErrors[id as keyof T] = error;\n        }\n      }\n      if (validationErrors) {\n        setErrors(validationErrors);\n        return false;\n      }\n      const result = await latestOnSubmit.current(values);\n      return typeof result === \"boolean\" ? result : true;\n    },\n    [latestValidation, latestOnSubmit, focus],\n  );\n\n  const setValidationError = useCallback(\n    (id: keyof T, error: ValidationError) => {\n      setErrors((errors) => ({ ...errors, [id]: error }));\n    },\n    [setErrors],\n  );\n\n  const setValue = useCallback(\n    function <K extends keyof T>(id: K, value: SetStateAction<T[K]>) {\n      // @ts-expect-error TS is always confused about SetStateAction, but it's fine here\n      setValues((values) => ({ ...values, [id]: typeof value === \"function\" ? value(values[id]) : value }));\n    },\n    [setValues],\n  );\n\n  const itemProps = useMemo<{ [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & { id: string } }>(() => {\n    // we have to use a proxy because we don't actually have any object to iterate through\n    // so instead we dynamically create the props when required\n    return new Proxy<{ [id in keyof Required<T>]: Partial<Form.ItemProps<T[id]>> & { id: string } }>(\n      // @ts-expect-error the whole point of a proxy...\n      {},\n      {\n        get(target, id: keyof T) {\n          const validation = latestValidation.current[id];\n          const value = values[id];\n          return {\n            onChange(value) {\n              if (errors[id]) {\n                const error = validationError(validation, value);\n                if (!error) {\n                  setValidationError(id, undefined);\n                }\n              }\n              setValue(id, value);\n            },\n            onBlur(event) {\n              const error = validationError(validation, event.target.value);\n              if (error) {\n                setValidationError(id, error);\n              }\n            },\n            error: errors[id],\n            id,\n            // we shouldn't return `undefined` otherwise it will be an uncontrolled component\n            value: typeof value === \"undefined\" ? null : value,\n            ref: (instance: Form.ItemReference) => {\n              refs.current[id] = instance;\n            },\n          } as Partial<Form.ItemProps<T[keyof T]>> & { id: string };\n        },\n      },\n    );\n  }, [errors, latestValidation, setValidationError, values, refs, setValue]);\n\n  const reset = useCallback(\n    (values?: Partial<T>) => {\n      setErrors({});\n      Object.entries(refs.current).forEach(([id, ref]) => {\n        if (!values?.[id]) {\n          ref?.reset();\n        }\n      });\n      if (values) {\n        // @ts-expect-error it's fine if we don't specify all the values\n        setValues(values);\n      }\n    },\n    [setValues, setErrors, refs],\n  );\n\n  return { handleSubmit, setValidationError, setValue, values, itemProps, focus, reset };\n}\n", "import { useRef, useState } from \"react\";\nimport { AI } from \"@raycast/api\";\nimport { PromiseOptions, usePromise } from \"./usePromise\";\nimport { FunctionReturningPromise } from \"./types\";\n\n/**\n * Stream a prompt completion.\n *\n * @example\n * ```typescript\n * import { Detail, LaunchProps } from \"@raycast/api\";\n * import { use AI } from \"@raycast/utils\";\n *\n * export default function Command(props: LaunchProps<{ arguments: { prompt: string } }>) {\n *   const { isLoading, data } = useAI(props.arguments.prompt);\n *\n *   return <Detail isLoading={isLoading} markdown={data} />;\n * }\n * ```\n */\nexport function useAI(\n  prompt: string,\n  options: {\n    /**\n     * Concrete tasks, such as fixing grammar, require less creativity while open-ended questions, such as generating ideas, require more.\n     * If a number is passed, it needs to be in the range 0-2. For larger values, 2 will be used. For lower values, 0 will be used.\n     */\n    creativity?: AI.Creativity;\n    /**\n     * The AI model to use to answer to the prompt.\n     */\n    model?: AI.Model;\n    /**\n     * Whether to stream the answer or only update the data when the entire answer has been received.\n     */\n    stream?: boolean;\n  } & Omit<PromiseOptions<FunctionReturningPromise>, \"abortable\"> = {},\n) {\n  const { creativity, stream, model, ...usePromiseOptions } = options;\n  const [data, setData] = useState(\"\");\n  const abortable = useRef<AbortController>(null);\n  const { isLoading, error, revalidate } = usePromise(\n    async (prompt: string, creativity?: AI.Creativity, shouldStream?: boolean) => {\n      setData(\"\");\n      const stream = AI.ask(prompt, { creativity, model, signal: abortable.current?.signal });\n      if (shouldStream === false) {\n        setData(await stream);\n      } else {\n        stream.on(\"data\", (data) => {\n          setData((x) => x + data);\n        });\n        await stream;\n      }\n    },\n    [prompt, creativity, stream],\n    { ...usePromiseOptions, abortable },\n  );\n\n  return { isLoading, data, error, revalidate };\n}\n", "import { useMemo, useCallback } from \"react\";\nimport { useLatest } from \"./useLatest\";\nimport { useCachedState } from \"./useCachedState\";\n\n// The algorithm below is inspired by the one used by Firefox:\n// https://wiki.mozilla.org/User:Jesse/NewFrecency\n\ntype Frecency = {\n  lastVisited: number;\n  frecency: number;\n};\n\nconst HALF_LIFE_DAYS = 10;\n\nconst MS_PER_DAY = 24 * 60 * 60 * 1000;\n\nconst VISIT_TYPE_POINTS = {\n  Default: 100,\n  Embed: 0,\n  Bookmark: 140,\n};\n\nfunction getNewFrecency(item?: Frecency): Frecency {\n  const now = Date.now();\n  const lastVisited = item ? item.lastVisited : 0;\n  const frecency = item ? item.frecency : 0;\n\n  const visitAgeInDays = (now - lastVisited) / MS_PER_DAY;\n  const DECAY_RATE_CONSTANT = Math.log(2) / (HALF_LIFE_DAYS * MS_PER_DAY);\n  const currentVisitValue = VISIT_TYPE_POINTS.Default * Math.exp(-DECAY_RATE_CONSTANT * visitAgeInDays);\n  const totalVisitValue = frecency + currentVisitValue;\n\n  return {\n    lastVisited: now,\n    frecency: totalVisitValue,\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultKey = (item: any): string => {\n  if (\n    process.env.NODE_ENV !== \"production\" &&\n    (typeof item !== \"object\" || !item || !(\"id\" in item) || typeof item.id != \"string\")\n  ) {\n    throw new Error(\"Specify a key function or make sure your items have an 'id' property\");\n  }\n  return item.id;\n};\n\n/**\n * Sort an array by its frecency and provide methods to update the frecency of its items.\n * Frecency is a measure that combines frequency and recency. The more often an item is visited/used, and the more recently an item is visited/used, the higher it will rank.\n *\n * @example\n * ```\n * import { List, ActionPanel, Action, Icon } from \"@raycast/api\";\n * import { useFetch, useFrecencySorting } from \"@raycast/utils\";\n *\n * export default function Command() {\n *   const { isLoading, data } = useFetch(\"https://api.example\");\n *   const { data: sortedData, visitItem, resetRanking } = useFrecencySorting(data);\n *\n *   return (\n *     <List isLoading={isLoading}>\n *       {sortedData.map((item) => (\n *         <List.Item\n *           key={item.id}\n *           title={item.title}\n *           actions={\n *             <ActionPanel>\n *               <Action.OpenInBrowser url={item.url} onOpen={() => visitItem(item)} />\n *               <Action.CopyToClipboard title=\"Copy Link\" content={item.url} onCopy={() => visitItem(item)} />\n *               <Action title=\"Reset Ranking\" icon={Icon.ArrowCounterClockwise} onAction={() => resetRanking(item)} />\n *             </ActionPanel>\n *           }\n *         />\n *       ))}\n *     </List>\n *   );\n * };\n * ```\n */\nexport function useFrecencySorting<T extends { id: string }>(\n  data?: T[],\n  options?: { namespace?: string; key?: (item: T) => string; sortUnvisited?: (a: T, b: T) => number },\n): {\n  data: T[];\n  visitItem: (item: T) => Promise<void>;\n  resetRanking: (item: T) => Promise<void>;\n};\nexport function useFrecencySorting<T>(\n  data: T[] | undefined,\n  options: { namespace?: string; key: (item: T) => string; sortUnvisited?: (a: T, b: T) => number },\n): {\n  data: T[];\n  visitItem: (item: T) => Promise<void>;\n  resetRanking: (item: T) => Promise<void>;\n};\nexport function useFrecencySorting<T>(\n  data?: T[],\n  options?: { namespace?: string; key?: (item: T) => string; sortUnvisited?: (a: T, b: T) => number },\n): {\n  data: T[];\n  visitItem: (item: T) => Promise<void>;\n  resetRanking: (item: T) => Promise<void>;\n} {\n  const keyRef = useLatest(options?.key || defaultKey);\n  const sortUnvisitedRef = useLatest(options?.sortUnvisited);\n\n  const [storedFrecencies, setStoredFrecencies] = useCachedState<Record<string, Frecency | undefined>>(\n    `raycast_frecency_${options?.namespace}`,\n    {},\n  );\n\n  const visitItem = useCallback(\n    async function updateFrecency(item: T) {\n      const itemKey = keyRef.current(item);\n\n      setStoredFrecencies((storedFrecencies) => {\n        const frecency = storedFrecencies[itemKey];\n        const newFrecency = getNewFrecency(frecency);\n\n        return {\n          ...storedFrecencies,\n          [itemKey]: newFrecency,\n        };\n      });\n    },\n    [keyRef, setStoredFrecencies],\n  );\n\n  const resetRanking = useCallback(\n    async function removeFrecency(item: T) {\n      const itemKey = keyRef.current(item);\n\n      setStoredFrecencies((storedFrecencies) => {\n        const newFrencencies = { ...storedFrecencies };\n        delete newFrencencies[itemKey];\n\n        return newFrencencies;\n      });\n    },\n    [keyRef, setStoredFrecencies],\n  );\n\n  const sortedData = useMemo(() => {\n    if (!data) {\n      return [];\n    }\n\n    return data.sort((a, b) => {\n      const frecencyA = storedFrecencies[keyRef.current(a)];\n      const frecencyB = storedFrecencies[keyRef.current(b)];\n\n      // If a has a frecency, but b doesn't, a should come first\n      if (frecencyA && !frecencyB) {\n        return -1;\n      }\n\n      // If b has a frecency, but a doesn't, b should come first\n      if (!frecencyA && frecencyB) {\n        return 1;\n      }\n\n      // If both frecencies are defined,put the one with the higher frecency first\n      if (frecencyA && frecencyB) {\n        return frecencyB.frecency - frecencyA.frecency;\n      }\n\n      // If both frecencies are undefined, keep the original order\n      return sortUnvisitedRef.current ? sortUnvisitedRef.current(a, b) : 0;\n    });\n  }, [storedFrecencies, data, keyRef, sortUnvisitedRef]);\n\n  return { data: sortedData, visitItem, resetRanking };\n}\n", "import { LocalStorage } from \"@raycast/api\";\nimport { showFailureToast } from \"./showFailureToast\";\nimport { replacer, reviver } from \"./helpers\";\nimport { usePromise } from \"./usePromise\";\n\n/**\n * A hook to manage a value in the local storage.\n *\n * @remark The value is stored as a JSON string in the local storage.\n *\n * @param key - The key to use for the value in the local storage.\n * @param initialValue - The initial value to use if the key doesn't exist in the local storage.\n * @returns An object with the following properties:\n * - `value`: The value from the local storage or the initial value if the key doesn't exist.\n * - `setValue`: A function to update the value in the local storage.\n * - `removeValue`: A function to remove the value from the local storage.\n * - `isLoading`: A boolean indicating if the value is loading.\n *\n * @example\n * ```\n * const { value, setValue } = useLocalStorage<string>(\"my-key\");\n * const { value, setValue } = useLocalStorage<string>(\"my-key\", \"default value\");\n * ```\n */\nexport function useLocalStorage<T>(key: string, initialValue?: T) {\n  const {\n    data: value,\n    isLoading,\n    mutate,\n  } = usePromise(\n    async (storageKey: string) => {\n      const item = await LocalStorage.getItem<string>(storageKey);\n\n      return typeof item !== \"undefined\" ? (JSON.parse(item, reviver) as T) : initialValue;\n    },\n    [key],\n  );\n\n  async function setValue(value: T) {\n    try {\n      await mutate(LocalStorage.setItem(key, JSON.stringify(value, replacer)), {\n        optimisticUpdate(value) {\n          return value;\n        },\n      });\n    } catch (error) {\n      await showFailureToast(error, { title: \"Failed to set value in local storage\" });\n    }\n  }\n\n  async function removeValue() {\n    try {\n      await mutate(LocalStorage.removeItem(key), {\n        optimisticUpdate() {\n          return undefined;\n        },\n      });\n    } catch (error) {\n      await showFailureToast(error, { title: \"Failed to remove value from local storage\" });\n    }\n  }\n\n  return { value, setValue, removeValue, isLoading };\n}\n", "export { getAvatarIcon } from \"./avatar\";\nexport { getFavicon } from \"./favicon\";\nexport { getProgressIcon } from \"./progress\";\n", "import type { Image } from \"@raycast/api\";\nimport { slightlyLighterColor, slightlyDarkerColor } from \"./color\";\n\nfunction getWholeCharAndI(str: string, i: number): [string, number] {\n  const code = str.charCodeAt(i);\n\n  if (Number.isNaN(code)) {\n    return [\"\", i];\n  }\n  if (code < 0xd800 || code > 0xdfff) {\n    return [str.charAt(i), i]; // Normal character, keeping 'i' the same\n  }\n\n  // High surrogate (could change last hex to 0xDB7F to treat high private\n  // surrogates as single characters)\n  if (0xd800 <= code && code <= 0xdbff) {\n    if (str.length <= i + 1) {\n      throw new Error(\"High surrogate without following low surrogate\");\n    }\n    const next = str.charCodeAt(i + 1);\n    if (0xdc00 > next || next > 0xdfff) {\n      throw new Error(\"High surrogate without following low surrogate\");\n    }\n    return [str.charAt(i) + str.charAt(i + 1), i + 1];\n  }\n\n  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n  if (i === 0) {\n    throw new Error(\"Low surrogate without preceding high surrogate\");\n  }\n\n  const prev = str.charCodeAt(i - 1);\n\n  // (could change last hex to 0xDB7F to treat high private surrogates\n  // as single characters)\n  if (0xd800 > prev || prev > 0xdbff) {\n    throw new Error(\"Low surrogate without preceding high surrogate\");\n  }\n\n  // Return the next character instead (and increment)\n  return [str.charAt(i + 1), i + 1];\n}\n\nconst avatarColorSet = [\n  \"#DC829A\", // Pink\n  \"#D64854\", // Red\n  \"#D47600\", // YellowOrange\n  \"#D36CDD\", // Magenta\n  \"#52A9E4\", // Aqua\n  \"#7871E8\", // Indigo\n  \"#70920F\", // YellowGreen\n  \"#43B93A\", // Green\n  \"#EB6B3E\", // Orange\n  \"#26B795\", // BlueGreen\n  \"#D85A9B\", // HotPink\n  \"#A067DC\", // Purple\n  \"#BD9500\", // Yellow\n  \"#5385D9\", // Blue\n];\n\n/**\n * Icon to represent an avatar when you don't have one. The generated avatar\n * will be generated from the initials of the name and have a colorful but consistent background.\n *\n * @returns an Image that can be used where Raycast expects them.\n *\n * @example\n * ```\n * <List.Item icon={getAvatarIcon('Mathieu Dutour')} title=\"Project\" />\n * ```\n */\nexport function getAvatarIcon(\n  name: string,\n  options?: {\n    /**\n     * Custom background color\n     */\n    background?: string;\n    /**\n     * Whether to use a gradient for the background or not.\n     * @default true\n     */\n    gradient?: boolean;\n  },\n): Image.Asset {\n  const words = name.trim().split(\" \");\n  let initials: string;\n  if (words.length == 1 && getWholeCharAndI(words[0], 0)[0]) {\n    initials = getWholeCharAndI(words[0], 0)[0];\n  } else if (words.length > 1) {\n    const firstWordFirstLetter = getWholeCharAndI(words[0], 0)[0] || \"\";\n    const lastWordFirstLetter = getWholeCharAndI(words[words.length - 1], 0)[0] ?? \"\";\n    initials = firstWordFirstLetter + lastWordFirstLetter;\n  } else {\n    initials = \"\";\n  }\n\n  let backgroundColor: string;\n\n  if (options?.background) {\n    backgroundColor = options?.background;\n  } else {\n    let initialsCharIndex = 0;\n    let [char, i] = getWholeCharAndI(initials, 0);\n    while (char) {\n      initialsCharIndex += char.charCodeAt(0);\n      [char, i] = getWholeCharAndI(initials, i + 1);\n    }\n\n    const colorIndex = initialsCharIndex % avatarColorSet.length;\n    backgroundColor = avatarColorSet[colorIndex];\n  }\n\n  const padding = 0;\n  const radius = 50 - padding;\n\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100px\" height=\"100px\">\n  ${\n    options?.gradient !== false\n      ? `<defs>\n      <linearGradient id=\"Gradient\" x1=\"0.25\" x2=\"0.75\" y1=\"0\" y2=\"1\">\n        <stop offset=\"0%\" stop-color=\"${slightlyLighterColor(backgroundColor)}\"/>\n        <stop offset=\"50%\" stop-color=\"${backgroundColor}\"/>\n        <stop offset=\"100%\" stop-color=\"${slightlyDarkerColor(backgroundColor)}\"/>\n      </linearGradient>\n  </defs>`\n      : \"\"\n  }\n      <circle cx=\"50\" cy=\"50\" r=\"${radius}\" fill=\"${\n        options?.gradient !== false ? \"url(#Gradient)\" : backgroundColor\n      }\" />\n      ${\n        initials\n          ? `<text x=\"50\" y=\"80\" font-size=\"${\n              radius - 1\n            }\" font-family=\"Inter, sans-serif\" text-anchor=\"middle\" fill=\"white\">${initials.toUpperCase()}</text>`\n          : \"\"\n      }\n    </svg>\n  `.replaceAll(\"\\n\", \"\");\n  return `data:image/svg+xml,${encodeURIComponent(svg)}`;\n}\n", "function hexToRGB(hex: string) {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  // 3 digits\n  if (hex.length === 4) {\n    r = parseInt(`${hex[1]}${hex[1]}`, 16);\n    g = parseInt(`${hex[2]}${hex[2]}`, 16);\n    b = parseInt(`${hex[3]}${hex[3]}`, 16);\n\n    // 6 digits\n  } else if (hex.length === 7) {\n    r = parseInt(`${hex[1]}${hex[2]}`, 16);\n    g = parseInt(`${hex[3]}${hex[4]}`, 16);\n    b = parseInt(`${hex[5]}${hex[6]}`, 16);\n  } else {\n    throw new Error(`Malformed hex color: ${hex}`);\n  }\n\n  return { r, g, b };\n}\n\nfunction rgbToHex({ r, g, b }: { r: number; g: number; b: number }) {\n  let rString = r.toString(16);\n  let gString = g.toString(16);\n  let bString = b.toString(16);\n\n  if (rString.length === 1) {\n    rString = `0${rString}`;\n  }\n  if (gString.length === 1) {\n    gString = `0${gString}`;\n  }\n  if (bString.length === 1) {\n    bString = `0${bString}`;\n  }\n\n  return `#${rString}${gString}${bString}`;\n}\n\nfunction rgbToHSL({ r, g, b }: { r: number; g: number; b: number }) {\n  // Make r, g, and b fractions of 1\n  r /= 255;\n  g /= 255;\n  b /= 255;\n\n  // Find greatest and smallest channel values\n  const cmin = Math.min(r, g, b);\n  const cmax = Math.max(r, g, b);\n  const delta = cmax - cmin;\n  let h = 0;\n  let s = 0;\n  let l = 0;\n\n  // Calculate hue\n  // No difference\n  if (delta === 0) {\n    h = 0;\n  }\n  // Red is max\n  else if (cmax === r) {\n    h = ((g - b) / delta) % 6;\n  }\n  // Green is max\n  else if (cmax === g) {\n    h = (b - r) / delta + 2;\n  }\n  // Blue is max\n  else {\n    h = (r - g) / delta + 4;\n  }\n\n  h = Math.round(h * 60);\n\n  // Make negative hues positive behind 360\n  if (h < 0) {\n    h += 360;\n  }\n\n  // Calculate lightness\n  l = (cmax + cmin) / 2;\n\n  // Calculate saturation\n  s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));\n\n  // Multiply l and s by 100\n  s = +(s * 100).toFixed(1);\n  l = +(l * 100).toFixed(1);\n\n  return { h, s, l };\n}\n\nfunction hslToRGB({ h, s, l }: { h: number; s: number; l: number }) {\n  // Must be fractions of 1\n  s /= 100;\n  l /= 100;\n\n  const c = (1 - Math.abs(2 * l - 1)) * s;\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n  const m = l - c / 2;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  if (h >= 0 && h < 60) {\n    r = c;\n    g = x;\n    b = 0;\n  } else if (h >= 60 && h < 120) {\n    r = x;\n    g = c;\n    b = 0;\n  } else if (h >= 120 && h < 180) {\n    r = 0;\n    g = c;\n    b = x;\n  } else if (h >= 180 && h < 240) {\n    r = 0;\n    g = x;\n    b = c;\n  } else if (h >= 240 && h < 300) {\n    r = x;\n    g = 0;\n    b = c;\n  } else if (h >= 300 && h < 360) {\n    r = c;\n    g = 0;\n    b = x;\n  }\n  r = Math.round((r + m) * 255);\n  g = Math.round((g + m) * 255);\n  b = Math.round((b + m) * 255);\n\n  return { r, g, b };\n}\n\nfunction hexToHSL(hex: string) {\n  return rgbToHSL(hexToRGB(hex));\n}\n\nfunction hslToHex(hsl: { h: number; s: number; l: number }) {\n  return rgbToHex(hslToRGB(hsl));\n}\n\nfunction clamp(value: number, min: number, max: number) {\n  return min < max ? (value < min ? min : value > max ? max : value) : value < max ? max : value > min ? min : value;\n}\n\nconst offset = 12;\n\nexport function slightlyDarkerColor(hex: string) {\n  const hsl = hexToHSL(hex);\n\n  return hslToHex({\n    h: hsl.h,\n    s: hsl.s,\n    l: clamp(hsl.l - offset, 0, 100),\n  });\n}\n\nexport function slightlyLighterColor(hex: string) {\n  const hsl = hexToHSL(hex);\n\n  return hslToHex({\n    h: hsl.h,\n    s: hsl.s,\n    l: clamp(hsl.l + offset, 0, 100),\n  });\n}\n", "import { Icon, Image } from \"@raycast/api\";\nimport { URL } from \"node:url\";\n\n/**\n * Icon showing the favicon of a website.\n *\n * A favicon (favorite icon) is a tiny icon included along with a website, which is displayed in places like the browser's address bar, page tabs, and bookmarks menu.\n *\n * @param url The URL of the website to represent.\n *\n * @returns an Image that can be used where Raycast expects them.\n *\n * @example\n * ```\n * <List.Item icon={getFavicon(\"https://raycast.com\")} title=\"Raycast Website\" />\n * ```\n */\nexport function getFavicon(\n  url: string | URL,\n  options?: {\n    /**\n     * Size of the Favicon\n     * @default 64\n     */\n    size?: number;\n    /**\n     * Fallback icon in case the Favicon is not found.\n     * @default Icon.Link\n     */\n    fallback?: Image.Fallback;\n    /**\n     * A {@link Image.Mask} to apply to the Favicon.\n     */\n    mask?: Image.Mask;\n  },\n): Image.ImageLike {\n  try {\n    // a func adding https:// to the URL\n    // for cases where the URL is not a full URL\n    // e.g. \"raycast.com\"\n    const sanitize = (url: string) => {\n      if (!url.startsWith(\"http\")) {\n        return `https://${url}`;\n      }\n      return url;\n    };\n\n    const urlObj = typeof url === \"string\" ? new URL(sanitize(url)) : url;\n    const hostname = urlObj.hostname;\n\n    const faviconProvider: \"none\" | \"raycast\" | \"apple\" | \"google\" | \"duckDuckGo\" | \"duckduckgo\" | \"legacy\" =\n      (process.env.FAVICON_PROVIDER as any) ?? \"raycast\";\n\n    switch (faviconProvider) {\n      case \"none\":\n        return {\n          source: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"apple\":\n        // we can't support apple favicons as it's a native API\n        return {\n          source: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"duckduckgo\":\n      case \"duckDuckGo\":\n        return {\n          source: `https://icons.duckduckgo.com/ip3/${hostname}.ico`,\n          fallback: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"google\":\n        return {\n          source: `https://www.google.com/s2/favicons?sz=${options?.size ?? 64}&domain=${hostname}`,\n          fallback: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n      case \"legacy\":\n      case \"raycast\":\n      default:\n        return {\n          source: `https://api.ray.so/favicon?url=${hostname}&size=${options?.size ?? 64}`,\n          fallback: options?.fallback ?? Icon.Link,\n          mask: options?.mask,\n        };\n    }\n  } catch (e) {\n    console.error(e);\n    return Icon.Link;\n  }\n}\n", "import { environment, Color } from \"@raycast/api\";\nimport type { Image } from \"@raycast/api\";\n\nfunction polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {\n  const angleInRadians = ((angleInDegrees - 90) * Math.PI) / 180.0;\n\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians),\n  };\n}\n\nfunction describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number) {\n  const start = polarToCartesian(x, y, radius, endAngle);\n  const end = polarToCartesian(x, y, radius, startAngle);\n\n  const largeArcFlag = endAngle - startAngle <= 180 ? \"0\" : \"1\";\n\n  const d = [\"M\", start.x, start.y, \"A\", radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(\" \");\n\n  return d;\n}\n\n/**\n * Icon to represent the progress of _something_.\n *\n * @param progress Number between 0 and 1.\n * @param color Hex color (default `\"#FF6363\"`) or Color.\n *\n * @returns an Image that can be used where Raycast expects them.\n *\n * @example\n * ```\n * <List.Item icon={getProgressIcon(0.1)} title=\"Project\" />\n * ```\n */\nexport function getProgressIcon(\n  progress: number,\n  color: Color | string = Color.Red,\n  options?: { background?: Color | string; backgroundOpacity?: number },\n): Image.Asset {\n  const background = options?.background || (environment.appearance === \"light\" ? \"black\" : \"white\");\n  const backgroundOpacity = options?.backgroundOpacity || 0.1;\n\n  const stroke = 10;\n  const padding = 5;\n  const radius = 50 - padding - stroke / 2;\n\n  const svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100px\" height=\"100px\">\n      <circle cx=\"50\" cy=\"50\" r=\"${radius}\" stroke-width=\"${stroke}\" stroke=\"${\n        progress < 1 ? background : color\n      }\" opacity=\"${progress < 1 ? backgroundOpacity : \"1\"}\" fill=\"none\" />\n      ${\n        progress > 0 && progress < 1\n          ? `<path d=\"${describeArc(\n              50,\n              50,\n              radius,\n              0,\n              progress * 360,\n            )}\" stroke=\"${color}\" stroke-width=\"${stroke}\" fill=\"none\" />`\n          : \"\"\n      }\n    </svg>\n  `.replaceAll(\"\\n\", \"\");\n  return `data:image/svg+xml,${encodeURIComponent(svg)}`;\n}\n", "export { OAuthService } from \"./OAuthService\";\nexport { withAccessToken, getAccessToken } from \"./withAccessToken\";\n\nexport type { WithAccessTokenComponentOrFn } from \"./withAccessToken\";\nexport type {\n  OnAuthorizeParams,\n  OAuthServiceOptions,\n  ProviderWithDefaultClientOptions,\n  ProviderOptions,\n} from \"./types\";\n", "import { Color, OAuth } from \"@raycast/api\";\nimport { PROVIDER_CLIENT_IDS } from \"./providers\";\nimport type {\n  OAuthServiceOptions,\n  OnAuthorizeParams,\n  ProviderOptions,\n  ProviderWithDefaultClientOptions,\n} from \"./types\";\n\n/**\n * Class allowing to create an OAuth service using the the PKCE (Proof Key for Code Exchange) flow.\n *\n * This service is capable of starting the authorization process, fetching and refreshing tokens,\n * as well as managing the authentication state.\n *\n * @example\n * ```typescript\n * const oauthClient = new OAuth.PKCEClient({ ... });\n * const oauthService = new OAuthService({\n *   client: oauthClient,\n *   clientId: 'your-client-id',\n *   scope: 'required scopes',\n *   authorizeUrl: 'https://provider.com/oauth/authorize',\n *   tokenUrl: 'https://provider.com/oauth/token',\n *   refreshTokenUrl: 'https://provider.com/oauth/token',\n *   extraParameters: { 'additional_param': 'value' }\n * });\n * ```\n */\nexport class OAuthService implements OAuthServiceOptions {\n  public clientId: string;\n  public scope: string;\n  public client: OAuth.PKCEClient;\n  public extraParameters?: Record<string, string>;\n  public authorizeUrl: string;\n  public tokenUrl: string;\n  public refreshTokenUrl?: string;\n  public bodyEncoding?: \"json\" | \"url-encoded\";\n  public personalAccessToken?: string;\n  onAuthorize?: (params: OnAuthorizeParams) => void;\n  tokenResponseParser: (response: unknown) => OAuth.TokenResponse;\n  tokenRefreshResponseParser: (response: unknown) => OAuth.TokenResponse;\n\n  constructor(options: OAuthServiceOptions) {\n    this.clientId = options.clientId;\n    this.scope = Array.isArray(options.scope) ? options.scope.join(\" \") : options.scope;\n    this.personalAccessToken = options.personalAccessToken;\n    this.bodyEncoding = options.bodyEncoding;\n    this.client = options.client;\n    this.extraParameters = options.extraParameters;\n    this.authorizeUrl = options.authorizeUrl;\n    this.tokenUrl = options.tokenUrl;\n    this.refreshTokenUrl = options.refreshTokenUrl;\n    this.onAuthorize = options.onAuthorize;\n    this.tokenResponseParser = options.tokenResponseParser ?? ((x) => x as OAuth.TokenResponse);\n    this.tokenRefreshResponseParser = options.tokenRefreshResponseParser ?? ((x) => x as OAuth.TokenResponse);\n    this.authorize = this.authorize.bind(this);\n  }\n\n  /**\n   * Asana OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const asana = OAuthService.asana({ scope: 'default' })\n   * ```\n   */\n  public static asana(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Asana\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"251\" height=\"232\" fill=\"none\"><path fill=\"#F06A6A\" d=\"M179.383 54.373c0 30.017-24.337 54.374-54.354 54.374-30.035 0-54.373-24.338-54.373-54.374C70.656 24.338 94.993 0 125.029 0c30.017 0 54.354 24.338 54.354 54.373ZM54.393 122.33C24.376 122.33.02 146.668.02 176.685c0 30.017 24.337 54.373 54.373 54.373 30.035 0 54.373-24.338 54.373-54.373 0-30.017-24.338-54.355-54.373-54.355Zm141.253 0c-30.035 0-54.373 24.338-54.373 54.374 0 30.035 24.338 54.373 54.373 54.373 30.017 0 54.374-24.338 54.374-54.373 0-30.036-24.338-54.374-54.374-54.374Z\"/></svg>`,\n        )}`,\n        providerId: \"asana\",\n        description: \"Connect your Asana account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.asana,\n      authorizeUrl: options.authorizeUrl ?? \"https://asana.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://asana.oauth.raycast.com/token\",\n      refreshTokenUrl: options.refreshTokenUrl ?? \"https://asana.oauth.raycast.com/refresh-token\",\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * GitHub OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const github = OAuthService.github({ scope: 'repo user' })\n   * ```\n   */\n  public static github(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"GitHub\",\n        providerIcon: {\n          source: `data:image/svg+xml,${encodeURIComponent(\n            `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z\"/></svg>`,\n          )}`,\n\n          tintColor: Color.PrimaryText,\n        },\n        providerId: \"github\",\n        description: \"Connect your GitHub account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.github,\n      authorizeUrl: options.authorizeUrl ?? \"https://github.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://github.oauth.raycast.com/token\",\n      refreshTokenUrl: options.refreshTokenUrl ?? \"https://github.oauth.raycast.com/refresh-token\",\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Google OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const google = OAuthService.google({\n   *   clientId: 'custom-client-id',\n   *   authorizeUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n   *   tokenUrl: 'https://oauth2.googleapis.com/token',\n   *   scope: 'https://www.googleapis.com/auth/drive.readonly',\n   * });\n   * ```\n   */\n  public static google(options: ProviderOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.AppURI,\n        providerName: \"Google\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display:block\" viewBox=\"0 0 48 48\"><path fill=\"#EA4335\" d=\"M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z\"/><path fill=\"#4285F4\" d=\"M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z\"/><path fill=\"#FBBC05\" d=\"M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z\"/><path fill=\"#34A853\" d=\"M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z\"/><path fill=\"none\" d=\"M0 0h48v48H0z\"/></svg>`,\n        )}`,\n        providerId: \"google\",\n        description: \"Connect your Google account\",\n      }),\n      clientId: options.clientId,\n      authorizeUrl: options.authorizeUrl ?? \"https://accounts.google.com/o/oauth2/v2/auth\",\n      tokenUrl: options.tokenUrl ?? \"https://oauth2.googleapis.com/token\",\n      refreshTokenUrl: options.tokenUrl,\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      bodyEncoding: options.bodyEncoding ?? \"url-encoded\",\n      onAuthorize: options.onAuthorize,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Jira OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const jira = OAuthService.jira({\n   *   clientId: 'custom-client-id',\n   *   authorizeUrl: 'https://auth.atlassian.com/authorize',\n   *   tokenUrl: 'https://api.atlassian.com/oauth/token',\n   *   scope: 'read:jira-user read:jira-work offline_access'\n   * });\n   * ```\n   */\n  public static jira(options: ProviderOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Jira\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2361\" height=\"2500\" viewBox=\"2.59 0 214.091 224\"><linearGradient id=\"a\" x1=\"102.4\" x2=\"56.15\" y1=\"218.63\" y2=\"172.39\" gradientTransform=\"matrix(1 0 0 -1 0 264)\" gradientUnits=\"userSpaceOnUse\"><stop offset=\".18\" stop-color=\"#0052cc\"/><stop offset=\"1\" stop-color=\"#2684ff\"/></linearGradient><linearGradient xlink:href=\"#a\" id=\"b\" x1=\"114.65\" x2=\"160.81\" y1=\"85.77\" y2=\"131.92\"/><path fill=\"#2684ff\" d=\"M214.06 105.73 117.67 9.34 108.33 0 35.77 72.56 2.59 105.73a8.89 8.89 0 0 0 0 12.54l66.29 66.29L108.33 224l72.55-72.56 1.13-1.12 32.05-32a8.87 8.87 0 0 0 0-12.59zm-105.73 39.39L75.21 112l33.12-33.12L141.44 112z\"/><path fill=\"url(#a)\" d=\"M108.33 78.88a55.75 55.75 0 0 1-.24-78.61L35.62 72.71l39.44 39.44z\"/><path fill=\"url(#b)\" d=\"m141.53 111.91-33.2 33.21a55.77 55.77 0 0 1 0 78.86L181 151.35z\"/></svg>`,\n        )}`,\n        providerId: \"jira\",\n        description: \"Connect your Jira account\",\n      }),\n      clientId: options.clientId,\n      authorizeUrl: options.authorizeUrl ?? \"https://auth.atlassian.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://auth.atlassian.com/oauth/token\",\n      refreshTokenUrl: options.refreshTokenUrl,\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Linear OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const linear = OAuthService.linear({ scope: 'read write' })\n   * ```\n   */\n  public static linear(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Linear\",\n        providerIcon: {\n          source: {\n            light: `data:image/svg+xml,${encodeURIComponent(\n              `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#222326\" width=\"200\" height=\"200\" viewBox=\"0 0 100 100\"><path d=\"M1.22541 61.5228c-.2225-.9485.90748-1.5459 1.59638-.857L39.3342 97.1782c.6889.6889.0915 1.8189-.857 1.5964C20.0515 94.4522 5.54779 79.9485 1.22541 61.5228ZM.00189135 46.8891c-.01764375.2833.08887215.5599.28957165.7606L52.3503 99.7085c.2007.2007.4773.3075.7606.2896 2.3692-.1476 4.6938-.46 6.9624-.9259.7645-.157 1.0301-1.0963.4782-1.6481L2.57595 39.4485c-.55186-.5519-1.49117-.2863-1.648174.4782-.465915 2.2686-.77832 4.5932-.92588465 6.9624ZM4.21093 29.7054c-.16649.3738-.08169.8106.20765 1.1l64.77602 64.776c.2894.2894.7262.3742 1.1.2077 1.7861-.7956 3.5171-1.6927 5.1855-2.684.5521-.328.6373-1.0867.1832-1.5407L8.43566 24.3367c-.45409-.4541-1.21271-.3689-1.54074.1832-.99132 1.6684-1.88843 3.3994-2.68399 5.1855ZM12.6587 18.074c-.3701-.3701-.393-.9637-.0443-1.3541C21.7795 6.45931 35.1114 0 49.9519 0 77.5927 0 100 22.4073 100 50.0481c0 14.8405-6.4593 28.1724-16.7199 37.3375-.3903.3487-.984.3258-1.3542-.0443L12.6587 18.074Z\"/></svg>`,\n            )}`,\n            dark: `data:image/svg+xml,${encodeURIComponent(\n              `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"#fff\" width=\"200\" height=\"200\" viewBox=\"0 0 100 100\"><path d=\"M1.22541 61.5228c-.2225-.9485.90748-1.5459 1.59638-.857L39.3342 97.1782c.6889.6889.0915 1.8189-.857 1.5964C20.0515 94.4522 5.54779 79.9485 1.22541 61.5228ZM.00189135 46.8891c-.01764375.2833.08887215.5599.28957165.7606L52.3503 99.7085c.2007.2007.4773.3075.7606.2896 2.3692-.1476 4.6938-.46 6.9624-.9259.7645-.157 1.0301-1.0963.4782-1.6481L2.57595 39.4485c-.55186-.5519-1.49117-.2863-1.648174.4782-.465915 2.2686-.77832 4.5932-.92588465 6.9624ZM4.21093 29.7054c-.16649.3738-.08169.8106.20765 1.1l64.77602 64.776c.2894.2894.7262.3742 1.1.2077 1.7861-.7956 3.5171-1.6927 5.1855-2.684.5521-.328.6373-1.0867.1832-1.5407L8.43566 24.3367c-.45409-.4541-1.21271-.3689-1.54074.1832-.99132 1.6684-1.88843 3.3994-2.68399 5.1855ZM12.6587 18.074c-.3701-.3701-.393-.9637-.0443-1.3541C21.7795 6.45931 35.1114 0 49.9519 0 77.5927 0 100 22.4073 100 50.0481c0 14.8405-6.4593 28.1724-16.7199 37.3375-.3903.3487-.984.3258-1.3542-.0443L12.6587 18.074Z\" /></svg>`,\n            )}`,\n          },\n        },\n        providerId: \"linear\",\n        description: \"Connect your Linear account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.linear,\n      authorizeUrl: options.authorizeUrl ?? \"https://linear.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://linear.oauth.raycast.com/token\",\n      refreshTokenUrl: options.refreshTokenUrl ?? \"https://linear.oauth.raycast.com/refresh-token\",\n      scope: options.scope,\n      extraParameters: {\n        actor: \"user\",\n      },\n      onAuthorize: options.onAuthorize,\n      bodyEncoding: options.bodyEncoding,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Slack OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const slack = OAuthService.slack({ scope: 'emoji:read' })\n   * ```\n   */\n  public static slack(options: ProviderWithDefaultClientOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Slack\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"73 73 124 124\"><style>.st0{fill:#e01e5a}.st1{fill:#36c5f0}.st2{fill:#2eb67d}.st3{fill:#ecb22e}</style><path d=\"M99.4 151.2c0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9h12.9v12.9zM105.9 151.2c0-7.1 5.8-12.9 12.9-12.9s12.9 5.8 12.9 12.9v32.3c0 7.1-5.8 12.9-12.9 12.9s-12.9-5.8-12.9-12.9v-32.3z\" class=\"st0\"/><path d=\"M118.8 99.4c-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9s12.9 5.8 12.9 12.9v12.9h-12.9zM118.8 105.9c7.1 0 12.9 5.8 12.9 12.9s-5.8 12.9-12.9 12.9H86.5c-7.1 0-12.9-5.8-12.9-12.9s5.8-12.9 12.9-12.9h32.3z\" class=\"st1\"/><path d=\"M170.6 118.8c0-7.1 5.8-12.9 12.9-12.9 7.1 0 12.9 5.8 12.9 12.9s-5.8 12.9-12.9 12.9h-12.9v-12.9zM164.1 118.8c0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9V86.5c0-7.1 5.8-12.9 12.9-12.9 7.1 0 12.9 5.8 12.9 12.9v32.3z\" class=\"st2\"/><path d=\"M151.2 170.6c7.1 0 12.9 5.8 12.9 12.9 0 7.1-5.8 12.9-12.9 12.9-7.1 0-12.9-5.8-12.9-12.9v-12.9h12.9zM151.2 164.1c-7.1 0-12.9-5.8-12.9-12.9 0-7.1 5.8-12.9 12.9-12.9h32.3c7.1 0 12.9 5.8 12.9 12.9 0 7.1-5.8 12.9-12.9 12.9h-32.3z\" class=\"st3\"/></svg>`,\n        )}`,\n        providerId: \"slack\",\n        description: \"Connect your Slack account\",\n      }),\n      clientId: options.clientId ?? PROVIDER_CLIENT_IDS.slack,\n      authorizeUrl: options.authorizeUrl ?? \"https://slack.oauth.raycast.com/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://slack.oauth.raycast.com/token\",\n      refreshTokenUrl: options.tokenUrl ?? \"https://slack.oauth.raycast.com/refresh-token\",\n      scope: \"\",\n      extraParameters: {\n        user_scope: options.scope,\n      },\n      personalAccessToken: options.personalAccessToken,\n      bodyEncoding: options.tokenUrl ? options.bodyEncoding ?? \"url-encoded\" : \"json\",\n      onAuthorize: options.onAuthorize,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      tokenResponseParser:\n        options.tokenResponseParser ??\n        ((response: any) => {\n          return {\n            access_token: response.authed_user.access_token,\n            scope: response.authed_user.scope,\n          };\n        }),\n    });\n  }\n\n  /**\n   * Zoom OAuth service provided out of the box.\n   *\n   * @example\n   * ```typescript\n   * const zoom = OAuthService.zoom({\n   *   clientId: 'custom-client-id',\n   *   authorizeUrl: 'https://zoom.us/oauth/authorize',\n   *   tokenUrl: 'https://zoom.us/oauth/token',\n   *   scope: 'meeting:write',\n   *   personalAccessToken: 'personal-access-token',\n   * });\n   * ```\n   */\n  public static zoom(options: ProviderOptions) {\n    return new OAuthService({\n      client: new OAuth.PKCEClient({\n        redirectMethod: OAuth.RedirectMethod.Web,\n        providerName: \"Zoom\",\n        providerIcon: `data:image/svg+xml,${encodeURIComponent(\n          `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 351.845 80\"><path d=\"M73.786 78.835H10.88A10.842 10.842 0 0 1 .833 72.122a10.841 10.841 0 0 1 2.357-11.85L46.764 16.7h-31.23C6.954 16.699 0 9.744 0 1.165h58.014c4.414 0 8.357 2.634 10.046 6.712a10.843 10.843 0 0 1-2.356 11.85L22.13 63.302h36.122c8.58 0 15.534 6.955 15.534 15.534Zm278.059-48.544C351.845 13.588 338.256 0 321.553 0c-8.934 0-16.975 3.89-22.524 10.063C293.48 3.89 285.44 0 276.505 0c-16.703 0-30.291 13.588-30.291 30.291v48.544c8.579 0 15.534-6.955 15.534-15.534v-33.01c0-8.137 6.62-14.757 14.757-14.757s14.757 6.62 14.757 14.757v33.01c0 8.58 6.955 15.534 15.534 15.534V30.291c0-8.137 6.62-14.757 14.757-14.757s14.758 6.62 14.758 14.757v33.01c0 8.58 6.954 15.534 15.534 15.534V30.291ZM238.447 40c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.908-40 40-40 40 17.909 40 40Zm-15.534 0c0-13.512-10.954-24.466-24.466-24.466S173.98 26.488 173.98 40s10.953 24.466 24.466 24.466S222.913 53.512 222.913 40Zm-70.68 0c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40 40 17.909 40 40Zm-15.534 0c0-13.512-10.954-24.466-24.466-24.466S87.767 26.488 87.767 40s10.954 24.466 24.466 24.466S136.699 53.512 136.699 40Z\" style=\"fill:#0b5cff\"/></svg>`,\n        )}`,\n        providerId: \"zoom\",\n        description: \"Connect your Zoom account\",\n      }),\n      clientId: options.clientId,\n      authorizeUrl: options.authorizeUrl ?? \"https://zoom.us/oauth/authorize\",\n      tokenUrl: options.tokenUrl ?? \"https://zoom.us/oauth/token\",\n      refreshTokenUrl: options.refreshTokenUrl,\n      scope: options.scope,\n      personalAccessToken: options.personalAccessToken,\n      bodyEncoding: options.bodyEncoding ?? \"url-encoded\",\n      onAuthorize: options.onAuthorize,\n      tokenRefreshResponseParser: options.tokenRefreshResponseParser,\n      tokenResponseParser: options.tokenResponseParser,\n    });\n  }\n\n  /**\n   * Initiates the OAuth authorization process or refreshes existing tokens if necessary.\n   * If the current token set has a refresh token and it is expired, then the function will refresh the tokens.\n   * If no tokens exist, it will initiate the OAuth authorization process and fetch the tokens.\n   *\n   * @returns {Promise<string>} A promise that resolves with the access token obtained from the authorization flow, or null if the token could not be obtained.\n   */\n  async authorize() {\n    const currentTokenSet = await this.client.getTokens();\n    if (currentTokenSet?.accessToken) {\n      if (currentTokenSet.refreshToken && currentTokenSet.isExpired()) {\n        const tokens = await this.refreshTokens({\n          token: currentTokenSet.refreshToken,\n        });\n\n        // In the case where the refresh token flows fails, nothing is returned and the authorize function is called again.\n        if (tokens) {\n          await this.client.setTokens(tokens);\n          return tokens.access_token;\n        }\n      }\n      return currentTokenSet.accessToken;\n    }\n\n    const authRequest = await this.client.authorizationRequest({\n      endpoint: this.authorizeUrl,\n      clientId: this.clientId,\n      scope: this.scope,\n      extraParameters: this.extraParameters,\n    });\n\n    const { authorizationCode } = await this.client.authorize(authRequest);\n    const tokens = await this.fetchTokens({\n      authRequest,\n      authorizationCode,\n    });\n\n    await this.client.setTokens(tokens);\n\n    return tokens.access_token;\n  }\n\n  private async fetchTokens({\n    authRequest,\n    authorizationCode,\n  }: {\n    authRequest: OAuth.AuthorizationRequest;\n    authorizationCode: string;\n  }) {\n    let options;\n    if (this.bodyEncoding === \"url-encoded\") {\n      const params = new URLSearchParams();\n      params.append(\"client_id\", this.clientId);\n      params.append(\"code\", authorizationCode);\n      params.append(\"code_verifier\", authRequest.codeVerifier);\n      params.append(\"grant_type\", \"authorization_code\");\n      params.append(\"redirect_uri\", authRequest.redirectURI);\n\n      options = { body: params };\n    } else {\n      options = {\n        body: JSON.stringify({\n          client_id: this.clientId,\n          code: authorizationCode,\n          code_verifier: authRequest.codeVerifier,\n          grant_type: \"authorization_code\",\n          redirect_uri: authRequest.redirectURI,\n        }),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = await fetch(this.tokenUrl, { method: \"POST\", ...options });\n    if (!response.ok) {\n      const responseText = await response.text();\n      console.error(\"fetch tokens error:\", responseText);\n      throw new Error(`Error while fetching tokens: ${response.status} (${response.statusText})\\n${responseText}`);\n    }\n    const tokens = this.tokenResponseParser(await response.json());\n\n    // Some clients such as Linear can return a scope array instead of a string\n    return Array.isArray(tokens.scope) ? { ...tokens, scope: tokens.scope.join(\" \") } : tokens;\n  }\n\n  private async refreshTokens({ token }: { token: string }) {\n    let options;\n    if (this.bodyEncoding === \"url-encoded\") {\n      const params = new URLSearchParams();\n      params.append(\"client_id\", this.clientId);\n      params.append(\"refresh_token\", token);\n      params.append(\"grant_type\", \"refresh_token\");\n\n      options = { body: params };\n    } else {\n      options = {\n        body: JSON.stringify({\n          client_id: this.clientId,\n          refresh_token: token,\n          grant_type: \"refresh_token\",\n        }),\n        headers: { \"Content-Type\": \"application/json\" },\n      };\n    }\n\n    const response = await fetch(this.refreshTokenUrl ?? this.tokenUrl, { method: \"POST\", ...options });\n    if (!response.ok) {\n      const responseText = await response.text();\n      console.error(\"refresh tokens error:\", responseText);\n      // If the refresh token is invalid, stop the flow here, log out the user and prompt them to re-authorize.\n      this.client.description = `${this.client.providerName} needs you to sign-in again. Press  or click the button below to continue.`;\n      await this.client.removeTokens();\n      await this.authorize();\n    } else {\n      const tokenResponse = this.tokenRefreshResponseParser(await response.json());\n      tokenResponse.refresh_token = tokenResponse.refresh_token ?? token;\n      return tokenResponse;\n    }\n  }\n}\n", "export const PROVIDER_CLIENT_IDS = {\n  asana: \"1191201745684312\",\n  github: \"7235fe8d42157f1f38c0\",\n  linear: \"c8ff37b9225c3c9aefd7d66ea0e5b6f1\",\n  slack: \"851756884692.5546927290212\",\n};\n", "import React from \"react\";\nimport { environment, OAuth } from \"@raycast/api\";\nimport type { OAuthType, OnAuthorizeParams } from \"./types\";\n\nlet token: string | null = null;\nlet type: OAuthType | null = null;\nlet authorize: Promise<string> | null = null;\nlet getIdToken: Promise<string | undefined> | null = null;\nlet onAuthorize: Promise<void> | null = null;\n\ntype WithAccessTokenParameters = {\n  /**\n   * An optional instance of a PKCE Client that you can create using Raycast API.\n   * This client is used to return the `idToken` as part of the `onAuthorize` callback.\n   */\n  client?: OAuth.PKCEClient;\n  /**\n   * A function that initiates the OAuth token retrieval process\n   * @returns a promise that resolves to an access token.\n   */\n  authorize: () => Promise<string>;\n  /**\n   * An optional string that represents an already obtained personal access token\n   */\n  personalAccessToken?: string;\n  /**\n   * An optional callback function that is called once the user has been properly logged in through OAuth.\n   * @param {object} params - Parameters of the callback\n   * @param {string} options.token - The retrieved access token\n   * @param {string} options.type - The access token's type (either `oauth` or `personal`)\n   * @param {string} options.idToken - The optional id token. The `idToken` is returned if `options.client` is provided and if it's returned in the initial token set.\n   */\n  onAuthorize?: (params: OnAuthorizeParams) => void;\n};\n\n/**\n * The component (for a view/menu-bar commands) or function (for a no-view command) that is passed to withAccessToken.\n */\nexport type WithAccessTokenComponentOrFn<T = any, U = any> = ((params: T) => Promise<U> | U) | React.ComponentType<T>;\n\n/**\n * Higher-order component to wrap a given component or function and set an access token in a shared global variable.\n *\n * The function intercepts the component rendering process to either fetch an OAuth token asynchronously\n * or use a provided personal access token. A global variable will be then set with the received token\n * that you can get with the `getAccessToken` function.\n *\n * @example\n * ```typescript\n * import { Detail } from \"@raycast/api\";\n * import { OAuthService, getAccessToken, withAccessToken } from \"@raycast/utils\";\n *\n * const github = OAuthService.github({ scope: \"notifications repo read:org read:user read:project\" });\n *\n * function AuthorizedComponent() {\n *  const { token } = getAccessToken();\n *  ...\n * }\n *\n * export default withAccessToken(github)(AuthorizedComponent);\n * ```\n *\n * @returns {React.ComponentType<T>} The wrapped component.\n */\nexport function withAccessToken<T = any, U = any>(\n  options: WithAccessTokenParameters,\n): <V extends WithAccessTokenComponentOrFn<T, U>>(\n  fnOrComponent: V,\n) => V extends React.ComponentType<T> ? React.FunctionComponent<T> : (props: T) => Promise<U>;\nexport function withAccessToken<T>(options: WithAccessTokenParameters) {\n  if (environment.commandMode === \"no-view\") {\n    return (fn: (props: T) => Promise<void> | (() => void)) => {\n      const noViewFn = async (props: T) => {\n        if (!token) {\n          token = options.personalAccessToken ?? (await options.authorize());\n          type = options.personalAccessToken ? \"personal\" : \"oauth\";\n          const idToken = (await options.client?.getTokens())?.idToken;\n\n          if (options.onAuthorize) {\n            await Promise.resolve(options.onAuthorize({ token, type, idToken }));\n          }\n        }\n\n        return fn(props);\n      };\n\n      return noViewFn;\n    };\n  }\n\n  return (Component: React.ComponentType<T>) => {\n    const WrappedComponent: React.ComponentType<T> = (props) => {\n      if (options.personalAccessToken) {\n        token = options.personalAccessToken;\n        type = \"personal\";\n      } else {\n        if (!authorize) {\n          authorize = options.authorize();\n        }\n        token = React.use(authorize);\n        type = \"oauth\";\n      }\n\n      let idToken: string | undefined;\n      if (options.client) {\n        if (!getIdToken) {\n          getIdToken = options.client?.getTokens().then((tokens) => tokens?.idToken);\n        }\n        idToken = React.use(getIdToken);\n      }\n\n      if (options.onAuthorize) {\n        if (!onAuthorize) {\n          onAuthorize = Promise.resolve(options.onAuthorize({ token: token!, type, idToken }));\n        }\n        React.use(onAuthorize);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore too complicated for TS\n      return <Component {...props} />;\n    };\n\n    WrappedComponent.displayName = `withAccessToken(${Component.displayName || Component.name})`;\n\n    return WrappedComponent;\n  };\n}\n\n/**\n * Returns the access token and its type. Note that this function must be called in a component wrapped with `withAccessToken`.\n *\n * Will throw an Error if called outside of a function or component wrapped with `withAccessToken`\n *\n * @returns {{ token: string, type: \"oauth\" | \"personal\" }} An object containing the `token`\n * and its `type`, where type can be either 'oauth' for OAuth tokens or 'personal' for a\n * personal access token.\n */\nexport function getAccessToken(): {\n  token: string;\n  /** `oauth` for OAuth tokens or `personal` for personal access token */\n  type: \"oauth\" | \"personal\";\n} {\n  if (!token || !type) {\n    throw new Error(\"getAccessToken must be used when authenticated (eg. used inside `withAccessToken`)\");\n  }\n\n  return { token, type };\n}\n", "import { environment, LaunchProps, LaunchType } from \"@raycast/api\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\n\nexport enum DeeplinkType {\n  /** A script command */\n  ScriptCommand = \"script-command\",\n  /** An extension command */\n  Extension = \"extension\",\n}\n\n/**\n * Options for creating a deeplink to a script command.\n */\nexport type CreateScriptCommandDeeplinkOptions = {\n  /**\n   * The type of deeplink, which should be \"script-command\".\n   */\n  type: DeeplinkType.ScriptCommand;\n  /**\n   * The name of the command.\n   */\n  command: string;\n  /**\n   * If the command accepts arguments, they can be passed using this query parameter.\n   */\n  arguments?: string[];\n};\n\n/**\n * Base options for creating a deeplink to an extension.\n */\nexport type CreateExtensionDeeplinkBaseOptions = {\n  /**\n   * The type of deeplink, which should be \"extension\".\n   */\n  type?: DeeplinkType.Extension;\n  /**\n   * The command associated with the extension.\n   */\n  command: string;\n  /**\n   * Either \"userInitiated\", which runs the command in the foreground, or \"background\", which skips bringing Raycast to the front.\n   */\n  launchType?: LaunchType;\n  /**\n   * If the command accepts arguments, they can be passed using this query parameter.\n   */\n  arguments?: LaunchProps[\"arguments\"];\n  /**\n   * If the command make use of LaunchContext, it can be passed using this query parameter.\n   */\n  context?: LaunchProps[\"launchContext\"];\n  /**\n   * Some text to prefill the search bar or first text input of the command\n   */\n  fallbackText?: string;\n};\n\n/**\n * Options for creating a deeplink to an extension from another extension.\n * Requires both the ownerOrAuthorName and extensionName.\n */\nexport type CreateInterExtensionDeeplinkOptions = CreateExtensionDeeplinkBaseOptions & {\n  /**\n   * The name of the owner or author of the extension.\n   */\n  ownerOrAuthorName: string;\n  /**\n   * The name of the extension.\n   */\n  extensionName: string;\n};\n\n/**\n * Options for creating a deeplink to an extension.\n */\nexport type CreateExtensionDeeplinkOptions = CreateInterExtensionDeeplinkOptions | CreateExtensionDeeplinkBaseOptions;\n\n/**\n * Options for creating a deeplink.\n */\nexport type CreateDeeplinkOptions = CreateScriptCommandDeeplinkOptions | CreateExtensionDeeplinkOptions;\n\nfunction getProtocol() {\n  return environment.raycastVersion.includes(\"alpha\") ? \"raycastinternal://\" : \"raycast://\";\n}\n\nfunction getOwnerOrAuthorName() {\n  const packageJSON = JSON.parse(fs.readFileSync(path.join(environment.assetsPath, \"..\", \"package.json\"), \"utf8\"));\n  return packageJSON.owner || packageJSON.author;\n}\n\nexport function createScriptCommandDeeplink(options: CreateScriptCommandDeeplinkOptions): string {\n  let url = `${getProtocol()}script-commands/${options.command}`;\n\n  if (options.arguments) {\n    let params = \"\";\n    for (const arg of options.arguments) {\n      params += \"&arguments=\" + encodeURIComponent(arg);\n    }\n    url += \"?\" + params.substring(1);\n  }\n\n  return url;\n}\n\nexport function createExtensionDeeplink(options: CreateExtensionDeeplinkOptions): string {\n  let ownerOrAuthorName = getOwnerOrAuthorName();\n  let extensionName = environment.extensionName;\n\n  if (\"ownerOrAuthorName\" in options && \"extensionName\" in options) {\n    ownerOrAuthorName = options.ownerOrAuthorName;\n    extensionName = options.extensionName;\n  }\n\n  let url = `${getProtocol()}extensions/${ownerOrAuthorName}/${extensionName}/${options.command}`;\n\n  let params = \"\";\n  if (options.launchType) {\n    params += \"&launchType=\" + encodeURIComponent(options.launchType);\n  }\n\n  if (options.arguments) {\n    params += \"&arguments=\" + encodeURIComponent(JSON.stringify(options.arguments));\n  }\n\n  if (options.context) {\n    params += \"&context=\" + encodeURIComponent(JSON.stringify(options.context));\n  }\n\n  if (options.fallbackText) {\n    params += \"&fallbackText=\" + encodeURIComponent(options.fallbackText);\n  }\n\n  if (params) {\n    url += \"?\" + params.substring(1);\n  }\n\n  return url;\n}\n\n/**\n * Creates a deeplink to a script command or extension.\n */\nexport function createDeeplink(options: CreateDeeplinkOptions): string {\n  if (options.type === DeeplinkType.ScriptCommand) {\n    return createScriptCommandDeeplink(options);\n  } else {\n    return createExtensionDeeplink(options);\n  }\n}\n", "import { baseExecuteSQL } from \"./sql-utils\";\n\n/**\n * Executes a SQL query on a local SQLite database and returns the query result in JSON format.\n *\n * @param databasePath - The path to the SQLite database file.\n * @param query - The SQL query to execute.\n * @returns A Promise that resolves to an array of objects representing the query results.\n *\n * @example\n * ```typescript\n * import { closeMainWindow, Clipboard } from \"@raycast/api\";\n * import { executeSQL } from \"@raycast/utils\";\n *\n * type Message = { body: string; code: string };\n *\n * const DB_PATH = \"/path/to/chat.db\";\n *\n * export default async function Command() {\n *   const query = `SELECT body, code FROM ...`\n *\n *   const messages = await executeSQL<Message>(DB_PATH, query);\n *\n *   if (messages.length > 0) {\n *     const latestCode = messages[0].code;\n *     await Clipboard.paste(latestCode);\n *     await closeMainWindow();\n *   }\n * }\n * ```\n */\nexport function executeSQL<T = unknown>(databasePath: string, query: string) {\n  return baseExecuteSQL<T>(databasePath, query);\n}\n", "import childProcess from \"node:child_process\";\nimport {\n  defaultParsing,\n  getSpawnedPromise,\n  getSpawnedResult,\n  handleOutput,\n  ParseExecOutputHandler,\n} from \"./exec-utils\";\n\ntype AppleScriptOptions = {\n  /**\n   * By default, `runAppleScript` returns its results in human-readable form: strings do not have quotes around them, characters are not escaped, braces for lists and records are omitted, etc. This is generally more useful, but can introduce ambiguities. For example, the lists `{\"foo\", \"bar\"}` and `{{\"foo\", {\"bar\"}}}` would both be displayed as foo, bar. To see the results in an unambiguous form that could be recompiled into the same value, set `humanReadableOutput` to `false`.\n   *\n   * @default true\n   */\n  humanReadableOutput?: boolean;\n  /**\n   * Whether the script is using [`AppleScript`](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html#//apple_ref/doc/uid/TP40000983) or [`JavaScript`](https://developer.apple.com/library/archive/releasenotes/InterapplicationCommunication/RN-JavaScriptForAutomation/Articles/Introduction.html#//apple_ref/doc/uid/TP40014508-CH111-SW1).\n   *\n   * @default \"AppleScript\"\n   */\n  language?: \"AppleScript\" | \"JavaScript\";\n  /**\n   * A Signal object that allows you to abort the request if required via an AbortController object.\n   */\n  signal?: AbortSignal;\n  /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.\n   *\n   * @default 10000\n   */\n  timeout?: number;\n};\n\n/**\n * Executes an AppleScript script.\n *\n * @example\n * ```typescript\n * import { showHUD } from \"@raycast/api\";\n * import { runAppleScript, showFailureToast } from \"@raycast/utils\";\n *\n * export default async function () {\n *   try {\n *     const res = await runAppleScript(\n *       `\n *       on run argv\n *         return \"hello, \" & item 1 of argv & \".\"\n *       end run\n *       `,\n *       [\"world\"]\n *     );\n *     await showHUD(res);\n *   } catch (error) {\n *     showFailureToast(error, { title: \"Could not run AppleScript\" });\n *   }\n * }\n * ```\n */\nexport async function runAppleScript<T = string>(\n  script: string,\n  options?: AppleScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n  },\n): Promise<string>;\nexport async function runAppleScript<T = string>(\n  script: string,\n  /**\n   * The arguments to pass to the script.\n   */\n  args: string[],\n  options?: AppleScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n  },\n): Promise<string>;\nexport async function runAppleScript<T = string>(\n  script: string,\n  optionsOrArgs?:\n    | string[]\n    | (AppleScriptOptions & {\n        parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n      }),\n  options?: AppleScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, AppleScriptOptions>;\n  },\n): Promise<string> {\n  if (process.platform !== \"darwin\") {\n    throw new Error(\"AppleScript is only supported on macOS\");\n  }\n\n  const { humanReadableOutput, language, timeout, ...execOptions } = Array.isArray(optionsOrArgs)\n    ? options || {}\n    : optionsOrArgs || {};\n\n  const outputArguments = humanReadableOutput !== false ? [] : [\"-ss\"];\n  if (language === \"JavaScript\") {\n    outputArguments.push(\"-l\", \"JavaScript\");\n  }\n  if (Array.isArray(optionsOrArgs)) {\n    outputArguments.push(\"-\", ...optionsOrArgs);\n  }\n\n  const spawned = childProcess.spawn(\"osascript\", outputArguments, {\n    ...execOptions,\n    env: { PATH: \"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\" },\n  });\n  const spawnedPromise = getSpawnedPromise(spawned, { timeout: timeout ?? 10000 });\n\n  spawned.stdin.end(script);\n\n  const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n    spawned,\n    { encoding: \"utf8\" },\n    spawnedPromise,\n  );\n  const stdout = handleOutput({ stripFinalNewline: true }, stdoutResult);\n  const stderr = handleOutput({ stripFinalNewline: true }, stderrResult);\n\n  return defaultParsing({\n    stdout,\n    stderr,\n    error,\n    exitCode,\n    signal,\n    timedOut,\n    command: \"osascript\",\n    options,\n    parentError: new Error(),\n  });\n}\n", "import childProcess from \"node:child_process\";\nimport {\n  defaultParsing,\n  getSpawnedPromise,\n  getSpawnedResult,\n  handleOutput,\n  ParseExecOutputHandler,\n} from \"./exec-utils\";\n\ntype PowerShellScriptOptions = {\n  /**\n   * A Signal object that allows you to abort the request if required via an AbortController object.\n   */\n  signal?: AbortSignal;\n  /** If timeout is greater than `0`, the parent will send the signal `SIGTERM` if the child runs longer than timeout milliseconds.\n   *\n   * @default 10000\n   */\n  timeout?: number;\n};\n\n/**\n * Executes a PowerShell script.\n *\n * @example\n * ```typescript\n * import { showHUD } from \"@raycast/api\";\n * import { runPowerShellScript, showFailureToast } from \"@raycast/utils\";\n *\n * export default async function () {\n *   try {\n *     const res = await runPowerShellScript(\n *       `\n *       Write-Host \"hello, world.\"\n *       `,\n *     );\n *     await showHUD(res);\n *   } catch (error) {\n *     showFailureToast(error, { title: \"Could not run PowerShell\" });\n *   }\n * }\n * ```\n */\nexport async function runPowerShellScript<T = string>(\n  script: string,\n  options?: PowerShellScriptOptions & {\n    parseOutput?: ParseExecOutputHandler<T, string, PowerShellScriptOptions>;\n  },\n): Promise<string> {\n  if (process.platform !== \"win32\") {\n    throw new Error(\"PowerShell is only supported on Windows\");\n  }\n\n  const { timeout, ...execOptions } = options || {};\n\n  const outputArguments = [\"-NoLogo\", \"-NoProfile\", \"-NonInteractive\", \"-Command\", \"-\"];\n\n  const spawned = childProcess.spawn(\"powershell.exe\", outputArguments, {\n    ...execOptions,\n  });\n  const spawnedPromise = getSpawnedPromise(spawned, { timeout: timeout ?? 10000 });\n\n  spawned.stdin.end(script);\n\n  const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult] = await getSpawnedResult<string>(\n    spawned,\n    { encoding: \"utf8\" },\n    spawnedPromise,\n  );\n  const stdout = handleOutput({ stripFinalNewline: true }, stdoutResult);\n  const stderr = handleOutput({ stripFinalNewline: true }, stderrResult);\n\n  return defaultParsing({\n    stdout,\n    stderr,\n    error,\n    exitCode,\n    signal,\n    timedOut,\n    command: \"powershell.exe\",\n    options,\n    parentError: new Error(),\n  });\n}\n", "import { Cache } from \"@raycast/api\";\nimport { hash, replacer, reviver } from \"./helpers\";\n\n/**\n * Wraps a function with caching functionality using Raycast's Cache API.\n * Allows for caching of expensive functions like paginated API calls that rarely change.\n *\n * @param fn - The async function to cache results from\n * @param options - Optional configuration for the cache behavior\n * @param options.validate - Optional validation function for cached data\n * @param options.maxAge - Maximum age of cached data in milliseconds\n * @returns An async function that returns the result of the function, either from cache or fresh execution\n *\n * @example\n * ```ts\n * const cachedFunction = withCache(fetchExpensiveData, {\n *   maxAge: 5 * 60 * 1000 // Cache for 5 minutes\n * });\n *\n * const result = await cachedFunction(query);\n * ```\n */\nexport function withCache<Fn extends (...args: any) => Promise<any>>(\n  fn: Fn,\n  options?: {\n    /** function that receives the cached data and returns a boolean depending on whether the data is still valid or not. */\n    validate?: (data: Awaited<ReturnType<Fn>>) => boolean;\n    /** Maximum age of cached data in milliseconds after which the data will be considered invalid */\n    maxAge?: number;\n  },\n): Fn & { clearCache: () => void } {\n  const cache = new Cache({ namespace: hash(fn) });\n\n  const wrappedFn = async (...args: Parameters<Fn>) => {\n    const key =\n      hash(args || []) + (options as unknown as { internal_cacheKeySuffix?: string })?.internal_cacheKeySuffix;\n    const cached = cache.get(key);\n    if (cached) {\n      const { data, timestamp } = JSON.parse(cached, reviver);\n      const isExpired = options?.maxAge && Date.now() - timestamp > options.maxAge;\n      if (!isExpired && (!options?.validate || options.validate(data))) {\n        return data;\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const result = await fn(...args);\n    cache.set(\n      key,\n      JSON.stringify(\n        {\n          data: result,\n          timestamp: Date.now(),\n        },\n        replacer,\n      ),\n    );\n    return result;\n  };\n\n  wrappedFn.clearCache = () => {\n    cache.clear();\n  };\n\n  // @ts-expect-error too complex for TS\n  return wrappedFn;\n}\n", "import { List } from \"@raycast/api\";\n\nexport const VaultLoadingFallback = () => <List searchBarPlaceholder=\"Search vault\" isLoading />;\n", "import { useReducer } from \"react\";\nimport { SessionState } from \"~/types/session\";\n\nconst initialState: SessionState = {\n  token: undefined,\n  passwordHash: undefined,\n\n  isLoading: true,\n  isLocked: false,\n  isAuthenticated: false,\n};\n\ntype SessionReducerActions =\n  | ({ type: \"loadState\" } & Partial<Omit<SessionState, \"isLoading\" | \"isLocked\" | \"isAuthenticated\">>)\n  | { type: \"lock\" }\n  | ({ type: \"unlock\" } & Pick<SessionState, \"token\" | \"passwordHash\">)\n  | { type: \"logout\" }\n  | { type: \"vaultTimeout\" }\n  | { type: \"finishLoadingSavedState\" }\n  | { type: \"failLoadingSavedState\" };\n\nexport const useSessionReducer = () => {\n  return useReducer((state: SessionState, action: SessionReducerActions): SessionState => {\n    switch (action.type) {\n      case \"loadState\": {\n        const { type: _, ...actionPayload } = action;\n        return { ...state, ...actionPayload };\n      }\n      case \"lock\": {\n        return {\n          ...state,\n          token: undefined,\n          passwordHash: undefined,\n          isLoading: false,\n          isLocked: true,\n        };\n      }\n      case \"unlock\": {\n        return {\n          ...state,\n          token: action.token,\n          passwordHash: action.passwordHash,\n          isLocked: false,\n          isAuthenticated: true,\n        };\n      }\n      case \"logout\": {\n        return {\n          ...state,\n          token: undefined,\n          passwordHash: undefined,\n          isLocked: true,\n          isAuthenticated: false,\n          isLoading: false,\n        };\n      }\n      case \"vaultTimeout\": {\n        return {\n          ...state,\n          isLocked: true,\n        };\n      }\n      case \"finishLoadingSavedState\": {\n        if (!state.token || !state.passwordHash) {\n          throw new Error(\"Missing required fields: token, passwordHash\");\n        }\n\n        const hasToken = !!state.token;\n        return {\n          ...state,\n          isLoading: false,\n          isLocked: !hasToken,\n          isAuthenticated: hasToken,\n        };\n      }\n      case \"failLoadingSavedState\": {\n        return {\n          ...state,\n          isLoading: false,\n          isLocked: true,\n        };\n      }\n      default: {\n        return state;\n      }\n    }\n  }, initialState);\n};\n", "import { LocalStorage } from \"@raycast/api\";\nimport { LOCAL_STORAGE_KEY } from \"~/constants/general\";\nimport { exec as callbackExec, PromiseWithChild } from \"child_process\";\nimport { promisify } from \"util\";\nimport { captureException, debugLog } from \"~/utils/development\";\n\nconst exec = promisify(callbackExec);\n\nexport const SessionStorage = {\n  getSavedSession: () => {\n    return Promise.all([\n      LocalStorage.getItem<string>(LOCAL_STORAGE_KEY.SESSION_TOKEN),\n      LocalStorage.getItem<string>(LOCAL_STORAGE_KEY.REPROMPT_HASH),\n      LocalStorage.getItem<string>(LOCAL_STORAGE_KEY.LAST_ACTIVITY_TIME),\n      LocalStorage.getItem<string>(LOCAL_STORAGE_KEY.VAULT_LAST_STATUS),\n    ]);\n  },\n  clearSession: async () => {\n    await Promise.all([\n      LocalStorage.removeItem(LOCAL_STORAGE_KEY.SESSION_TOKEN),\n      LocalStorage.removeItem(LOCAL_STORAGE_KEY.REPROMPT_HASH),\n    ]);\n  },\n  saveSession: async (token: string, passwordHash: string) => {\n    await Promise.all([\n      LocalStorage.setItem(LOCAL_STORAGE_KEY.SESSION_TOKEN, token),\n      LocalStorage.setItem(LOCAL_STORAGE_KEY.REPROMPT_HASH, passwordHash),\n    ]);\n  },\n  logoutClearSession: async () => {\n    // clear everything related to the session\n    await Promise.all([\n      LocalStorage.removeItem(LOCAL_STORAGE_KEY.SESSION_TOKEN),\n      LocalStorage.removeItem(LOCAL_STORAGE_KEY.REPROMPT_HASH),\n      LocalStorage.removeItem(LOCAL_STORAGE_KEY.LAST_ACTIVITY_TIME),\n    ]);\n  },\n};\n\nexport const checkSystemLockedSinceLastAccess = (lastActivityTime: Date) => {\n  return checkSystemLogTimeAfter(lastActivityTime, (time: number) => getLastSyslog(time, \"handleUnlockResult\"));\n};\nexport const checkSystemSleptSinceLastAccess = (lastActivityTime: Date) => {\n  return checkSystemLogTimeAfter(lastActivityTime, (time: number) => getLastSyslog(time, \"sleep 0\"));\n};\n\nfunction getLastSyslog(hours: number, filter: string) {\n  return exec(\n    `log show --style syslog --predicate \"process == 'loginwindow'\" --info --last ${hours}h | grep \"${filter}\" | tail -n 1`\n  );\n}\n\nexport async function checkSystemLogTimeAfter(\n  time: Date,\n  getLogEntry: (timeSpanHours: number) => PromiseWithChild<{ stdout: string; stderr: string }>\n): Promise<boolean> {\n  const lastScreenLockTime = await getSystemLogTime(getLogEntry);\n  if (!lastScreenLockTime) return true; // assume that log was found for improved safety\n  return new Date(lastScreenLockTime).getTime() > time.getTime();\n}\n\nconst getSystemLogTime_INCREMENT_HOURS = 2;\nconst getSystemLogTime_MAX_RETRIES = 5;\n/**\n * Starts by checking the last hour and increases the time span by {@link getSystemLogTime_INCREMENT_HOURS} hours on each retry.\n * \u26A0\uFE0F Calls to the system log are very slow, and if the screen hasn't been locked for some hours, it gets slower.\n */\nasync function getSystemLogTime(\n  getLogEntry: (timeSpanHours: number) => PromiseWithChild<{ stdout: string; stderr: string }>,\n  timeSpanHours = 1,\n  retryAttempt = 0\n): Promise<Date | undefined> {\n  try {\n    if (retryAttempt > getSystemLogTime_MAX_RETRIES) {\n      debugLog(\"Max retry attempts reached to get last screen lock time\");\n      return undefined;\n    }\n    const { stdout, stderr } = await getLogEntry(timeSpanHours);\n    const [logDate, logTime] = stdout?.split(\" \") ?? [];\n    if (stderr || !logDate || !logTime) {\n      return getSystemLogTime(getLogEntry, timeSpanHours + getSystemLogTime_INCREMENT_HOURS, retryAttempt + 1);\n    }\n\n    const logFullDate = new Date(`${logDate}T${logTime}`);\n    if (!logFullDate || logFullDate.toString() === \"Invalid Date\") return undefined;\n\n    return logFullDate;\n  } catch (error) {\n    captureException(\"Failed to get last screen lock time\", error);\n    return undefined;\n  }\n}\n", "import { EffectCallback, useEffect, useRef } from \"react\";\n\ntype AsyncEffectCallback = () => Promise<any>;\ntype Effect = EffectCallback | AsyncEffectCallback;\n\ntype DefinedValue = null | boolean | number | string | object | symbol;\n\n/** `useEffect` that only runs once after the `condition` is met */\nfunction useOnceEffect(effect: Effect, condition?: DefinedValue) {\n  const hasRun = useRef(false);\n\n  useEffect(() => {\n    if (hasRun.current) return;\n    if (condition !== undefined && !condition) return;\n    hasRun.current = true;\n    void effect();\n  }, [condition]);\n}\n\nexport default useOnceEffect;\n", "import { Action, Clipboard, Icon, Toast, environment, getPreferenceValues, showToast } from \"@raycast/api\";\nimport { captureException } from \"~/utils/development\";\nimport { exec as execWithCallbacks } from \"child_process\";\nimport { promisify } from \"util\";\nimport { cliInfo } from \"~/api/bitwarden\";\nimport { existsSync } from \"fs\";\nimport { dirname } from \"path\";\nimport { platform } from \"~/utils/platform\";\n\nconst exec = promisify(execWithCallbacks);\nconst { supportPath } = environment;\n\n/** strip out any sensitive data from preferences */\nconst getSafePreferences = () => {\n  const {\n    clientId,\n    clientSecret,\n    fetchFavicons,\n    generatePasswordQuickAction,\n    repromptIgnoreDuration,\n    serverCertsPath,\n    serverUrl,\n    shouldCacheVaultItems,\n    transientCopyGeneratePassword,\n    transientCopyGeneratePasswordQuick,\n    transientCopySearch,\n    windowActionOnCopy,\n  } = getPreferenceValues<AllPreferences>();\n\n  return {\n    has_clientId: !!clientId,\n    has_clientSecret: !!clientSecret,\n    fetchFavicons,\n    generatePasswordQuickAction,\n    repromptIgnoreDuration,\n    has_serverCertsPath: !!serverCertsPath,\n    has_serverUrl: !!serverUrl,\n    shouldCacheVaultItems,\n    transientCopyGeneratePassword,\n    transientCopyGeneratePasswordQuick,\n    transientCopySearch,\n    windowActionOnCopy,\n  };\n};\n\nconst NA = \"N/A\";\nconst tryExec = async (command: string, trimLineBreaks = true) => {\n  try {\n    let cmd = command;\n\n    if (platform === \"windows\") {\n      cmd = `powershell -Command \"${command}\"`;\n    } else {\n      cmd = `PATH=\"$PATH:${dirname(process.execPath)}\" ${command}`;\n    }\n    const { stdout } = await exec(cmd, { env: { BITWARDENCLI_APPDATA_DIR: supportPath } });\n    const response = stdout.trim();\n    if (trimLineBreaks) return response.replace(/\\n|\\r/g, \"\");\n    return response;\n  } catch (error) {\n    captureException(`Failed to execute command: ${command}`, error);\n    return NA;\n  }\n};\n\nconst getBwBinInfo = () => {\n  try {\n    const cliPathPref = getPreferenceValues<Preferences>().cliPath;\n    if (cliPathPref) {\n      return { type: \"custom\", path: cliPathPref };\n    }\n    if (cliInfo.path.bin === cliInfo.path.downloadedBin) {\n      return { type: \"downloaded\", path: cliInfo.path.downloadedBin };\n    }\n    return { type: \"installed\", path: cliInfo.path.installedBin };\n  } catch (error) {\n    return { type: NA, path: NA };\n  }\n};\n\nconst getHomebrewInfo = async () => {\n  try {\n    let path = \"/opt/homebrew/bin/brew\";\n    if (!existsSync(path)) path = \"/usr/local/bin/brew\";\n    if (!existsSync(path)) return { arch: NA, version: NA };\n\n    const config = await tryExec(`${path} config`, false);\n    if (config === NA) return { arch: NA, version: NA };\n\n    const archValue = /HOMEBREW_PREFIX: (.+)/.exec(config)?.[1] || NA;\n    const version = /HOMEBREW_VERSION: (.+)/.exec(config)?.[1] || NA;\n    const arch = archValue !== NA ? (archValue.includes(\"/opt/homebrew\") ? \"arm64\" : \"x86_64\") : NA;\n\n    return { arch, version };\n  } catch (error) {\n    return { arch: NA, version: NA };\n  }\n};\n\nfunction BugReportCollectDataAction() {\n  const collectData = async () => {\n    const toast = await showToast(Toast.Style.Animated, \"Collecting data...\");\n    try {\n      const preferences = getSafePreferences();\n      const bwInfo = getBwBinInfo();\n      const [systemArch, osVersion, osBuildVersion, bwVersion] = await Promise.all([\n        ...(platform === \"macos\"\n          ? [tryExec(\"uname -m\"), tryExec(\"sw_vers -productVersion\"), tryExec(\"sw_vers -buildVersion\")]\n          : [\n              tryExec(\"(Get-CimInstance Win32_OperatingSystem).OSArchitecture\"),\n              tryExec(\"(Get-CimInstance Win32_OperatingSystem).Caption\"),\n              tryExec(\"(Get-CimInstance Win32_OperatingSystem).Version\"),\n            ]),\n        tryExec(`${bwInfo.path} --version`),\n      ]);\n\n      const data: Record<string, any> = {\n        raycast: {\n          version: environment.raycastVersion,\n        },\n        system: {\n          arch: systemArch,\n          version: osVersion,\n          buildVersion: osBuildVersion,\n        },\n        node: {\n          arch: process.arch,\n          version: process.version,\n        },\n        cli: {\n          type: bwInfo.type,\n          version: bwVersion,\n        },\n        preferences,\n      };\n\n      if (platform === \"macos\") {\n        const brewInfo = await getHomebrewInfo();\n        data.homebrew = {\n          arch: brewInfo.arch,\n          version: brewInfo.version,\n        };\n      }\n\n      await Clipboard.copy(JSON.stringify(data, null, 2));\n      toast.style = Toast.Style.Success;\n      toast.title = \"Data copied to clipboard\";\n    } catch (error) {\n      toast.style = Toast.Style.Failure;\n      toast.title = \"Failed to collect bug report data\";\n      captureException(\"Failed to collect bug report data\", error);\n    }\n  };\n\n  return <Action title=\"Collect Bug Report Data\" icon={Icon.Bug} onAction={collectData} />;\n}\n\nexport default BugReportCollectDataAction;\n", "import { Action } from \"@raycast/api\";\n\nexport const BUG_REPORT_URL =\n  \"https://github.com/raycast/extensions/issues/new?assignees=&labels=extension%2Cbug&template=extension_bug_report.yml&title=%5BBitwarden%5D+...\";\n\nfunction BugReportOpenAction() {\n  return <Action.OpenInBrowser title=\"Open Bug Report\" url={BUG_REPORT_URL} />;\n}\n\nexport default BugReportOpenAction;\n", "import { Action, Alert, Clipboard, Icon, Toast, confirmAlert, showToast } from \"@raycast/api\";\nimport { capturedExceptions } from \"~/utils/development\";\n\nfunction CopyRuntimeErrorLog() {\n  const copyErrors = async () => {\n    const errorString = capturedExceptions.toString();\n    if (errorString.length === 0) {\n      return showToast(Toast.Style.Success, \"No errors to copy\");\n    }\n    await Clipboard.copy(errorString);\n    await showToast(Toast.Style.Success, \"Errors copied to clipboard\");\n    await confirmAlert({\n      title: \"Be careful with this information\",\n      message:\n        \"Please be mindful of where you share this error log, as it may contain sensitive information. Always analyze it before sharing.\",\n      primaryAction: { title: \"Got it\", style: Alert.ActionStyle.Default },\n    });\n  };\n\n  return (\n    <Action onAction={copyErrors} title=\"Copy Last Errors\" icon={Icon.CopyClipboard} style={Action.Style.Regular} />\n  );\n}\n\nexport default CopyRuntimeErrorLog;\n", "import { ActionPanel } from \"@raycast/api\";\nimport { BugReportCollectDataAction, BugReportOpenAction, CopyRuntimeErrorLog } from \"~/components/actions\";\nimport { useCliVersion } from \"~/utils/hooks/useCliVersion\";\n\nexport function DebuggingBugReportingActionSection() {\n  const cliVersion = useCliVersion();\n\n  return (\n    <ActionPanel.Section title={`Debugging & Bug Reporting (CLI v${cliVersion})`}>\n      <CopyRuntimeErrorLog />\n      <BugReportOpenAction />\n      <BugReportCollectDataAction />\n    </ActionPanel.Section>\n  );\n}\n", "import { useState } from \"react\";\nimport { CACHE_KEYS } from \"~/constants/general\";\nimport { Cache } from \"~/utils/cache\";\nimport useOnceEffect from \"~/utils/hooks/useOnceEffect\";\n\nconst getCliVersion = () => {\n  const version = Cache.get(CACHE_KEYS.CLI_VERSION);\n  if (version) return parseFloat(version);\n  return -1;\n};\n\nexport const useCliVersion = () => {\n  const [version, setVersion] = useState<number>(getCliVersion);\n\n  useOnceEffect(() => {\n    Cache.subscribe((key, value) => {\n      if (value && key === CACHE_KEYS.CLI_VERSION) {\n        setVersion(parseFloat(value) || -1);\n      }\n    });\n  });\n\n  return version;\n};\n", "import { Action, ActionPanel, Color, Icon, showToast, Toast } from \"@raycast/api\";\nimport { VAULT_LOCK_MESSAGES } from \"~/constants/general\";\nimport { useBitwarden } from \"~/context/bitwarden\";\nimport { useVaultContext } from \"~/context/vault\";\n\nexport function VaultActionsSection() {\n  const vault = useVaultContext();\n  const bitwarden = useBitwarden();\n\n  const handleLockVault = async () => {\n    const toast = await showToast(Toast.Style.Animated, \"Locking Vault...\", \"Please wait\");\n    await bitwarden.lock({ reason: VAULT_LOCK_MESSAGES.MANUAL });\n    await toast.hide();\n  };\n\n  const handleLogoutVault = async () => {\n    const toast = await showToast({ title: \"Logging Out...\", style: Toast.Style.Animated });\n    try {\n      await bitwarden.logout();\n      await toast.hide();\n    } catch (error) {\n      toast.title = \"Failed to logout\";\n      toast.style = Toast.Style.Failure;\n    }\n  };\n\n  return (\n    <ActionPanel.Section title=\"Vault Actions\">\n      <Action\n        title=\"Sync Vault\"\n        shortcut={{ macOS: { key: \"r\", modifiers: [\"opt\"] }, windows: { key: \"r\", modifiers: [\"alt\"] } }}\n        icon={Icon.ArrowClockwise}\n        onAction={vault.syncItems}\n      />\n      <Action\n        icon={{ source: \"sf_symbols_lock.svg\", tintColor: Color.PrimaryText }} // Does not immediately follow theme\n        title=\"Lock Vault\"\n        shortcut={{\n          macOS: { key: \"l\", modifiers: [\"opt\", \"shift\"] },\n          windows: { key: \"l\", modifiers: [\"alt\", \"shift\"] },\n        }}\n        onAction={handleLockVault}\n      />\n      <Action style={Action.Style.Destructive} title=\"Logout\" icon={Icon.Logout} onAction={handleLogoutVault} />\n    </ActionPanel.Section>\n  );\n}\n", "import { getPreferenceValues, showToast, Toast } from \"@raycast/api\";\nimport { createContext, ReactNode, useContext, useMemo, useReducer } from \"react\";\nimport { useVaultItemPublisher } from \"~/components/searchVault/context/vaultListeners\";\nimport { useBitwarden } from \"~/context/bitwarden\";\nimport { useSession } from \"~/context/session\";\nimport { Folder, Item, Vault } from \"~/types/vault\";\nimport { captureException } from \"~/utils/development\";\nimport useVaultCaching from \"~/components/searchVault/utils/useVaultCaching\";\nimport { FailedToLoadVaultItemsError, getDisplayableErrorMessage } from \"~/utils/errors\";\nimport useOnceEffect from \"~/utils/hooks/useOnceEffect\";\nimport { useCachedState } from \"@raycast/utils\";\nimport { CACHE_KEYS, FOLDER_OPTIONS } from \"~/constants/general\";\n\nexport type VaultState = Vault & {\n  isLoading: boolean;\n};\n\nexport type VaultContextType = VaultState & {\n  isEmpty: boolean;\n  syncItems: () => Promise<void>;\n  loadItems: () => Promise<void>;\n  currentFolderId: Nullable<string>;\n  setCurrentFolder: (folderOrId: Nullable<string | Folder>) => void;\n  updateState: (next: React.SetStateAction<VaultState>) => void;\n};\n\nconst VaultContext = createContext<VaultContextType | null>(null);\n\nfunction getInitialState(): VaultState {\n  return { items: [], folders: [], isLoading: true };\n}\n\nexport type VaultProviderProps = {\n  children: ReactNode;\n};\n\nconst { syncOnLaunch } = getPreferenceValues<AllPreferences>();\n\nexport function VaultProvider(props: VaultProviderProps) {\n  const { children } = props;\n\n  const session = useSession();\n  const bitwarden = useBitwarden();\n  const publishItems = useVaultItemPublisher();\n  const { getCachedVault, cacheVault } = useVaultCaching();\n\n  const [currentFolderId, setCurrentFolderId] = useCachedState<Nullable<string>>(CACHE_KEYS.CURRENT_FOLDER_ID, null);\n  const [state, setState] = useReducer(\n    (previous: VaultState, next: Partial<VaultState>) => ({ ...previous, ...next }),\n    { ...getInitialState(), ...getCachedVault() }\n  );\n\n  useOnceEffect(() => {\n    if (syncOnLaunch) {\n      void syncItems({ isInitial: true });\n    } else {\n      void loadItems();\n    }\n  }, session.active && session.token);\n\n  async function loadItems() {\n    try {\n      setState({ isLoading: true });\n\n      let items: Item[] = [];\n      let folders: Folder[] = [];\n      try {\n        const [itemsResult, foldersResult] = await Promise.all([bitwarden.listItems(), bitwarden.listFolders()]);\n        if (itemsResult.error) throw itemsResult.error;\n        if (foldersResult.error) throw foldersResult.error;\n        items = itemsResult.result;\n        folders = foldersResult.result;\n        items.sort(favoriteItemsFirstSorter);\n      } catch (error) {\n        publishItems(new FailedToLoadVaultItemsError());\n        throw error;\n      }\n\n      setState({ items, folders });\n      publishItems(items);\n      cacheVault(items, folders);\n    } catch (error) {\n      await showToast(Toast.Style.Failure, \"Failed to load vault items\", getDisplayableErrorMessage(error));\n      captureException(\"Failed to load vault items\", error);\n    } finally {\n      setState({ isLoading: false });\n    }\n  }\n\n  async function syncItems(props?: { isInitial?: boolean }) {\n    const { isInitial = false } = props ?? {};\n\n    const toast = await showToast({\n      title: \"Syncing Vault...\",\n      message: isInitial ? \"Background Task\" : undefined,\n      style: Toast.Style.Animated,\n    });\n    try {\n      await bitwarden.sync();\n      await loadItems();\n      await toast.hide();\n    } catch (error) {\n      await bitwarden.logout();\n      toast.style = Toast.Style.Failure;\n      toast.title = \"Failed to sync vault\";\n      toast.message = getDisplayableErrorMessage(error);\n    }\n  }\n\n  function setCurrentFolder(folderOrId: Nullable<string | Folder>) {\n    setCurrentFolderId(typeof folderOrId === \"string\" ? folderOrId : folderOrId?.id);\n  }\n\n  function updateState(next: React.SetStateAction<VaultState>) {\n    const newState = typeof next === \"function\" ? next(state) : next;\n    setState(newState);\n    cacheVault(newState.items, newState.folders);\n  }\n\n  const memoizedValue: VaultContextType = useMemo(\n    () => ({\n      ...state,\n      items: filterItemsByFolderId(state.items, currentFolderId),\n      isEmpty: state.items.length == 0,\n      isLoading: state.isLoading || session.isLoading,\n      currentFolderId,\n      syncItems,\n      loadItems,\n      setCurrentFolder,\n      updateState,\n    }),\n    [state, session.isLoading, currentFolderId, syncItems, loadItems, setCurrentFolder, updateState]\n  );\n\n  return <VaultContext.Provider value={memoizedValue}>{children}</VaultContext.Provider>;\n}\n\nfunction filterItemsByFolderId(items: Item[], folderId: Nullable<string>) {\n  if (!folderId || folderId === FOLDER_OPTIONS.ALL) return items;\n  if (folderId === FOLDER_OPTIONS.NO_FOLDER) return items.filter((item) => item.folderId === null);\n  return items.filter((item) => item.folderId === folderId);\n}\n\nfunction favoriteItemsFirstSorter(a: Item, b: Item) {\n  if (a.favorite && b.favorite) return 0;\n  return a.favorite ? -1 : 1;\n}\n\nexport const useVaultContext = () => {\n  const context = useContext(VaultContext);\n  if (context == null) {\n    throw new Error(\"useVault must be used within a VaultProvider\");\n  }\n\n  return context;\n};\n", "import { createContext, MutableRefObject, ReactNode, useContext, useMemo, useRef } from \"react\";\nimport { Item } from \"~/types/vault\";\nimport { FailedToLoadVaultItemsError } from \"~/utils/errors\";\n\nexport type ItemListener = (item: Item | FailedToLoadVaultItemsError) => void;\n\nexport type VaultListenersContextType = {\n  listeners: MutableRefObject<Map<string, ItemListener>>;\n  subscribeItem: (itemId: string, listener: ItemListener) => () => void;\n  publishItems: (items: Item[] | FailedToLoadVaultItemsError) => void;\n};\n\nconst VaultListenersContext = createContext<VaultListenersContextType | null>(null);\n\nconst VaultListenersProvider = ({ children }: { children: ReactNode }) => {\n  const listeners = useRef(new Map<string, ItemListener>());\n\n  const publishItems = (itemsOrError: Item[] | FailedToLoadVaultItemsError) => {\n    if (itemsOrError instanceof FailedToLoadVaultItemsError) {\n      listeners.current.forEach((listener) => listener(itemsOrError));\n    } else {\n      listeners.current.forEach((listener, itemId) => {\n        const item = itemsOrError.find((item) => item.id === itemId);\n        if (item) listener(item);\n      });\n    }\n  };\n\n  const subscribeItem = (itemId: string, listener: ItemListener) => {\n    listeners.current.set(itemId, listener);\n    return () => {\n      listeners.current.delete(itemId);\n    };\n  };\n\n  const memoizedValue = useMemo(() => ({ listeners, publishItems, subscribeItem }), []);\n\n  return <VaultListenersContext.Provider value={memoizedValue}>{children}</VaultListenersContext.Provider>;\n};\n\nexport const useVaultItemPublisher = () => {\n  const context = useContext(VaultListenersContext);\n  if (context == null) throw new Error(\"useVaultItemPublisher must be used within a VaultListenersProvider\");\n\n  return context.publishItems;\n};\n\n/** Allows you to subscribe to a specific item and get notified when it changes. */\nexport const useVaultItemSubscriber = () => {\n  const context = useContext(VaultListenersContext);\n  if (context == null) throw new Error(\"useVaultItemSubscriber must be used within a VaultListenersProvider\");\n\n  return (itemId: string) => {\n    let timeoutId: NodeJS.Timeout;\n\n    return new Promise<Item>((resolve, reject) => {\n      const unsubscribe = context.subscribeItem(itemId, (itemOrError) => {\n        try {\n          unsubscribe();\n          if (itemOrError instanceof FailedToLoadVaultItemsError) {\n            throw itemOrError;\n          }\n          resolve(itemOrError);\n          clearTimeout(timeoutId);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      timeoutId = setTimeout(() => {\n        unsubscribe();\n        reject(new SubscriberTimeoutError());\n      }, 15000);\n    });\n  };\n};\n\nclass SubscriberTimeoutError extends Error {\n  constructor() {\n    super(\"Timed out waiting for item\");\n    this.name = \"SubscriberTimeoutError\";\n  }\n}\n\nexport default VaultListenersProvider;\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { prepareFoldersForCache, prepareItemsForCache } from \"~/components/searchVault/utils/caching\";\nimport { CACHE_KEYS } from \"~/constants/general\";\nimport { Folder, Item, Vault } from \"~/types/vault\";\nimport { Cache } from \"~/utils/cache\";\nimport { captureException } from \"~/utils/development\";\nimport { useContentEncryptor } from \"~/utils/hooks/useContentEncryptor\";\nimport useOnceEffect from \"~/utils/hooks/useOnceEffect\";\n\nfunction useVaultCaching() {\n  const { encrypt, decrypt } = useContentEncryptor();\n  const isCachingEnable = getPreferenceValues<Preferences.Search>().shouldCacheVaultItems;\n\n  useOnceEffect(() => {\n    // users that opt out of caching probably want to delete any cached data\n    if (!Cache.isEmpty) Cache.clear();\n  }, !isCachingEnable);\n\n  const getCachedVault = (): Vault => {\n    try {\n      if (!isCachingEnable) throw new VaultCachingNoEnabledError();\n\n      const cachedIv = Cache.get(CACHE_KEYS.IV);\n      const cachedEncryptedVault = Cache.get(CACHE_KEYS.VAULT);\n      if (!cachedIv || !cachedEncryptedVault) throw new VaultCachingNoEnabledError();\n\n      const decryptedVault = decrypt(cachedEncryptedVault, cachedIv);\n      return JSON.parse<Vault>(decryptedVault);\n    } catch (error) {\n      if (!(error instanceof VaultCachingNoEnabledError)) {\n        captureException(\"Failed to decrypt cached vault\", error);\n      }\n      return { items: [], folders: [] };\n    }\n  };\n\n  const cacheVault = (items: Item[], folders: Folder[]): void => {\n    try {\n      if (!isCachingEnable) throw new VaultCachingNoEnabledError();\n\n      const vaultToEncrypt = JSON.stringify({\n        items: prepareItemsForCache(items),\n        folders: prepareFoldersForCache(folders),\n      });\n      const encryptedVault = encrypt(vaultToEncrypt);\n      Cache.set(CACHE_KEYS.VAULT, encryptedVault.content);\n      Cache.set(CACHE_KEYS.IV, encryptedVault.iv);\n    } catch (error) {\n      if (!(error instanceof VaultCachingNoEnabledError)) {\n        captureException(\"Failed to cache vault\", error);\n      }\n    }\n  };\n\n  return { getCachedVault, cacheVault };\n}\n\nclass VaultCachingNoEnabledError extends Error {}\n\nexport default useVaultCaching;\n", "import { getPreferenceValues } from \"@raycast/api\";\nimport { createCipheriv, createDecipheriv, createHash, randomBytes } from \"crypto\";\nimport { useMemo } from \"react\";\n\nconst ALGORITHM = \"aes-256-cbc\";\n\nexport type EncryptedContent = { iv: string; content: string };\n\n/** Encrypts and decrypts data using the user's client secret */\nexport function useContentEncryptor() {\n  const { clientSecret } = getPreferenceValues<Preferences>();\n  const cipherKeyBuffer = useMemo(() => get32BitSecretKeyBuffer(clientSecret.trim()), [clientSecret]);\n\n  const encrypt = (data: string): EncryptedContent => {\n    const ivBuffer = randomBytes(16);\n    const cipher = createCipheriv(ALGORITHM, cipherKeyBuffer, ivBuffer);\n    const encryptedContentBuffer = Buffer.concat([cipher.update(data), cipher.final()]);\n    return { iv: ivBuffer.toString(\"hex\"), content: encryptedContentBuffer.toString(\"hex\") };\n  };\n\n  const decrypt = (content: string, iv: string): string => {\n    const decipher = createDecipheriv(ALGORITHM, cipherKeyBuffer, Buffer.from(iv, \"hex\"));\n    const decryptedContentBuffer = Buffer.concat([decipher.update(Buffer.from(content, \"hex\")), decipher.final()]);\n    return decryptedContentBuffer.toString();\n  };\n\n  return { encrypt, decrypt };\n}\n\nfunction get32BitSecretKeyBuffer(key: string) {\n  return Buffer.from(createHash(\"sha256\").update(key).digest(\"base64\").slice(0, 32));\n}\n", "import { environment, showToast, Toast } from \"@raycast/api\";\nimport { Component, ErrorInfo, ReactNode } from \"react\";\nimport TroubleshootingGuide from \"~/components/TroubleshootingGuide\";\nimport { ManuallyThrownError } from \"~/utils/errors\";\n\ntype Props = {\n  children?: ReactNode;\n};\n\ntype State = {\n  hasError: boolean;\n  error?: string;\n};\n\nexport default class RootErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  async componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    if (error instanceof ManuallyThrownError) {\n      this.setState((state) => ({ ...state, hasError: true, error: error.message }));\n      await showToast(Toast.Style.Failure, error.message);\n    } else {\n      if (environment.isDevelopment) {\n        this.setState((state) => ({ ...state, hasError: true, error: error.message }));\n      }\n      console.error(\"Error:\", error, errorInfo);\n    }\n  }\n\n  render() {\n    try {\n      if (this.state.hasError) return <TroubleshootingGuide error={this.state.error} />;\n      return this.props.children;\n    } catch {\n      return <TroubleshootingGuide />;\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_windows", "__commonJSMin", "exports", "module", "isexe", "sync", "fs", "checkPathExt", "path", "options", "pathext", "i", "p", "checkStat", "stat", "cb", "er", "require_mode", "__commonJSMin", "exports", "module", "isexe", "sync", "fs", "path", "options", "cb", "er", "stat", "checkStat", "checkMode", "mod", "uid", "gid", "myUid", "myGid", "u", "g", "o", "ug", "ret", "require_isexe", "__commonJSMin", "exports", "module", "fs", "core", "isexe", "sync", "path", "options", "cb", "resolve", "reject", "er", "is", "require_which", "__commonJSMin", "exports", "module", "isWindows", "path", "COLON", "isexe", "getNotFoundError", "cmd", "getPathInfo", "opt", "colon", "pathEnv", "pathExtExe", "pathExt", "which", "cb", "found", "step", "i", "resolve", "reject", "ppRaw", "pathPart", "pCmd", "p", "subStep", "ii", "ext", "er", "is", "res", "whichSync", "j", "cur", "require_path_key", "__commonJSMin", "exports", "module", "pathKey", "options", "environment", "key", "require_resolveCommand", "__commonJSMin", "exports", "module", "path", "which", "getPathKey", "resolveCommandAttempt", "parsed", "withoutPathExt", "env", "cwd", "hasCustomCwd", "shouldSwitchCwd", "resolved", "resolveCommand", "require_escape", "__commonJSMin", "exports", "module", "metaCharsRegExp", "escapeCommand", "arg", "escapeArgument", "doubleEscapeMetaChars", "require_shebang_regex", "__commonJSMin", "exports", "module", "require_shebang_command", "__commonJSMin", "exports", "module", "shebangRegex", "string", "match", "path", "argument", "binary", "require_readShebang", "__commonJSMin", "exports", "module", "fs", "shebangCommand", "readShebang", "command", "buffer", "fd", "require_parse", "__commonJSMin", "exports", "module", "path", "resolveCommand", "escape", "readShebang", "isWin", "isExecutableRegExp", "isCmdShimRegExp", "detectShebang", "parsed", "shebang", "parseNonShell", "commandFile", "needsShell", "needsDoubleEscapeMetaChars", "arg", "shellCommand", "parse", "command", "args", "options", "require_enoent", "__commonJSMin", "exports", "module", "isWin", "notFoundError", "original", "syscall", "hookChildProcess", "cp", "parsed", "originalEmit", "name", "arg1", "err", "verifyENOENT", "status", "verifyENOENTSync", "require_cross_spawn", "__commonJSMin", "exports", "module", "cp", "parse", "enoent", "spawn", "command", "args", "options", "parsed", "spawned", "spawnSync", "result", "require_signals", "__commonJSMin", "exports", "module", "require_signal_exit", "__commonJSMin", "exports", "module", "process", "processOk", "assert", "signals", "isWin", "EE", "emitter", "cb", "opts", "loaded", "load", "ev", "remove", "unload", "sig", "sigListeners", "originalProcessEmit", "originalProcessReallyExit", "emit", "event", "code", "signal", "listeners", "processEmit", "processReallyExit", "arg", "ret", "require_buffer_stream", "__commonJSMin", "exports", "module", "PassThroughStream", "options", "array", "encoding", "isBuffer", "objectMode", "stream", "length", "chunks", "chunk", "require_get_stream", "__commonJSMin", "exports", "module", "BufferConstants", "stream", "promisify", "bufferStream", "streamPipelinePromisified", "MaxBufferError", "getStream", "inputStream", "options", "maxBuffer", "resolve", "reject", "rejectPromise", "error", "require_merge_stream", "__commonJSMin", "exports", "module", "PassThrough", "sources", "output", "add", "isEmpty", "remove", "source", "it", "require_node_stream_zip", "__commonJSMin", "exports", "module", "fs", "util", "path", "events", "zlib", "stream", "consts", "StreamZip", "config", "fd", "fileSize", "chunkSize", "op", "centralDirectory", "closed", "that", "entries", "fileName", "textDecoder", "open", "readFile", "err", "stat", "readCentralDirectory", "readUntilFoundCallback", "bytesRead", "pos", "bufferPosition", "buffer", "minPos", "expandLength", "totalReadLength", "FileWindowBuffer", "readCentralDirectoryComplete", "CentralDirectoryHeader", "readZip64CentralDirectoryLocator", "readEntries", "length", "readZip64CentralDirectoryLocatorComplete", "locHeader", "CentralDirectoryLoc64Header", "readLength", "readZip64CentralDirectoryComplete", "zip64cd", "CentralDirectoryZip64Header", "readEntriesCallback", "bufferPos", "entry", "bufferLength", "ZipEntry", "entryHeaderSize", "advanceBytes", "checkEntriesExist", "name", "callback", "offset", "dataOffset", "entryStream", "EntryDataReaderStream", "canVerifyCrc", "EntryVerifyStream", "e", "en", "data", "FsRead", "CrcVerify", "sync", "readEx", "ex", "extract", "outPath", "stm", "fsStm", "errThrown", "fdFile", "createDirectories", "baseDir", "dirs", "dir", "extractFiles", "baseRelPath", "files", "extractedCount", "file", "targetPath", "entryName", "allDirs", "relPath", "childEntry", "parts", "f", "partsPath", "x", "y", "originalEmit", "args", "customFs", "propZip", "zip", "resolve", "reject", "chunk", "res", "readUInt64LE", "timebytes", "datebytes", "parseZipTime", "compressedSize", "size", "nameData", "lastChar", "signature", "maxPos", "position", "shift", "n", "baseStm", "crc", "encoding", "_CrcVerify", "crcTable", "off", "len", "buf", "b", "c", "k", "timebits", "toBits", "datebits", "mt", "dt_str", "dec", "create_folder_exports", "__export", "create_folder_default", "__toCommonJS", "import_api", "import_react", "import_api", "import_node_buffer", "import_node_path", "import_node_child_process", "import_node_process", "import_cross_spawn", "stripFinalNewline", "input", "LF", "CR", "import_node_process", "import_node_path", "import_node_url", "pathKey", "options", "env", "platform", "key", "npmRunPath", "options", "cwd", "process", "path_", "pathKey", "execPath", "previous", "cwdString", "url", "cwdPath", "path", "result", "npmRunPathEnv", "env", "copyProperty", "to", "from", "property", "ignoreNonConfigurable", "toDescriptor", "fromDescriptor", "canCopyProperty", "changePrototype", "fromPrototype", "wrappedToString", "withName", "fromBody", "toStringDescriptor", "toStringName", "changeToString", "name", "newToString", "mimicFunction", "calledFunctions", "onetime", "function_", "options", "returnValue", "callCount", "functionName", "arguments_", "mimicFunction", "onetime_default", "import_node_os", "getRealtimeSignals", "length", "SIGRTMAX", "SIGRTMIN", "getRealtimeSignal", "value", "index", "import_node_os", "SIGNALS", "getSignals", "realtimeSignals", "getRealtimeSignals", "SIGNALS", "normalizeSignal", "name", "defaultNumber", "description", "action", "forced", "standard", "constantSignal", "supported", "getSignalsByName", "signals", "getSignals", "getSignalByName", "name", "number", "description", "supported", "action", "forced", "standard", "signalsByName", "getSignalsByNumber", "length", "signalsA", "value", "getSignalByNumber", "signal", "findSignalByNumber", "signalA", "signalsByNumber", "getErrorPrefix", "timedOut", "timeout", "errorCode", "signal", "signalDescription", "exitCode", "isCanceled", "makeError", "stdout", "stderr", "all", "error", "command", "escapedCommand", "killed", "signalsByName", "execaMessage", "isError", "shortMessage", "message", "aliases", "hasAlias", "options", "alias", "normalizeStdio", "stdio", "length", "value", "index", "import_node_os", "import_signal_exit", "DEFAULT_FORCE_KILL_TIMEOUT", "spawnedKill", "kill", "signal", "options", "killResult", "setKillTimeout", "shouldForceKill", "timeout", "getForceKillAfterTimeout", "t", "forceKillAfterTimeout", "isSigterm", "os", "spawnedCancel", "spawned", "context", "timeoutKill", "reject", "setupTimeout", "killSignal", "spawnedPromise", "timeoutId", "timeoutPromise", "resolve", "safeSpawnedPromise", "validateTimeout", "setExitHandler", "cleanup", "detached", "timedPromise", "removeExitHandler", "onExit", "isStream", "stream", "import_get_stream", "import_merge_stream", "handleInput", "spawned", "input", "isStream", "makeAllStream", "all", "mixed", "mergeStream", "getBufferedData", "stream", "streamPromise", "error", "getStreamPromise", "encoding", "buffer", "maxBuffer", "getStream", "getSpawnedResult", "stdout", "stderr", "processDone", "stdoutPromise", "stderrPromise", "allPromise", "nativePromisePrototype", "descriptors", "property", "mergePromise", "spawned", "promise", "descriptor", "value", "args", "getSpawnedPromise", "resolve", "reject", "exitCode", "signal", "error", "normalizeArgs", "file", "args", "NO_ESCAPE_REGEXP", "DOUBLE_QUOTES_REGEXP", "escapeArg", "arg", "joinCommand", "getEscapedCommand", "DEFAULT_MAX_BUFFER", "getEnv", "envOption", "extendEnv", "preferLocal", "localDir", "execPath", "env", "process", "npmRunPathEnv", "handleArguments", "file", "args", "options", "parsed", "crossSpawn", "normalizeStdio", "path", "handleOutput", "value", "error", "stripFinalNewline", "execa", "command", "joinCommand", "escapedCommand", "getEscapedCommand", "validateTimeout", "spawned", "childProcess", "dummySpawned", "errorPromise", "makeError", "mergePromise", "spawnedPromise", "getSpawnedPromise", "timedPromise", "setupTimeout", "processDone", "setExitHandler", "context", "spawnedKill", "spawnedCancel", "handlePromiseOnce", "onetime_default", "exitCode", "signal", "timedOut", "stdoutResult", "stderrResult", "allResult", "getSpawnedResult", "stdout", "stderr", "all", "returnedError", "handleInput", "makeAllStream", "import_fs", "import_api", "DEFAULT_SERVER_URL", "LOCAL_STORAGE_KEY", "VAULT_LOCK_MESSAGES", "CACHE_KEYS", "ITEM_TYPE_TO_ICON_MAP", "import_api", "import_crypto", "REPROMPT_HASH_SALT", "getPasswordGeneratingArgs", "options", "arg", "value", "hashMasterPasswordForReprompting", "password", "resolve", "reject", "REPROMPT_HASH_SALT", "error", "hashed", "import_api", "VAULT_TIMEOUT_OPTIONS", "VAULT_TIMEOUT", "acc", "key", "value", "VAULT_TIMEOUT_MS_TO_LABEL", "VAULT_TIMEOUT", "ITEM_TYPE_TO_LABEL", "getServerUrlPreference", "serverUrl", "getLabelForTimeoutPreference", "timeout", "VAULT_TIMEOUT_MS_TO_LABEL", "ManuallyThrownError", "message", "stack", "DisplayableError", "InstalledCLINotFoundError", "DisplayableError", "message", "stack", "VaultIsLockedError", "DisplayableError", "message", "stack", "NotLoggedInError", "ManuallyThrownError", "EnsureCliBinError", "PremiumFeatureError", "SendNeedsPasswordError", "SendInvalidPasswordError", "tryExec", "fn", "fallbackValue", "getErrorString", "error", "message", "name", "import_path", "import_promises", "import_fs", "import_promises", "import_path", "import_node_stream_zip", "waitForFileAvailable", "path", "resolve", "reject", "interval", "decompressFile", "filePath", "targetPath", "zip", "streamZip", "removeFilesThatStartWith", "startingWith", "removedAtLeastOne", "files", "file", "tryExec", "unlinkAllSync", "paths", "import_fs", "import_http", "import_https", "import_api", "import_api", "_exceptions", "message", "error", "capturedExceptions", "str", "log", "date", "getErrorString", "captureException", "description", "options", "captureToRaycast", "desc", "captureExceptionRaycast", "debugLog", "args", "import_fs", "import_crypto", "getFileSha256", "filePath", "download", "url", "path", "options", "onProgress", "sha256", "resolve", "reject", "uri", "protocol", "https", "http", "redirectCount", "request", "response", "redirectUrl", "fileSize", "fileStream", "downloadedBytes", "cleanup", "cleanupAndReject", "error", "chunk", "percent", "waitForFileAvailable", "waitForHashToMatch", "captureException", "fileSha", "getFileSha256", "interval", "prepareSendPayload", "template", "values", "import_api", "Cache", "RaycastCache", "platform", "supportPath", "\u0394", "BinDownloadLogger", "filePath", "error", "tryExec", "cliInfo", "platform", "name", "archSuffix", "Bitwarden", "toastInstance", "toastOpts", "previousStateToastOpts", "toast", "cliPathPreference", "clientId", "clientSecret", "serverCertsPath", "serverUrl", "getServerUrlPreference", "InstalledCLINotFoundError", "hadOldBinaries", "removeFilesThatStartWith", "zipPath", "download", "percent", "downloadError", "decompressFile", "decompressedBinPath", "waitForFileAvailable", "Cache", "CACHE_KEYS", "extractError", "EnsureCliBinError", "unlinkAllSync", "result", "captureException", "token", "storedServer", "LOCAL_STORAGE_KEY", "DEFAULT_SERVER_URL", "args", "options", "abortController", "input", "resetVaultTimeout", "env", "execa", "VaultIsLockedError", "execError", "reason", "immediate", "checkVaultStatus", "NotLoggedInError", "password", "sessionToken", "id", "stdout", "item", "itemTemplateError", "itemTemplate", "loginTemplateError", "loginTemplate", "encodedItem", "encodeError", "folder", "encodedFolder", "type", "getPasswordGeneratingArgs", "values", "templateError", "template", "payload", "prepareSendPayload", "encodedPayload", "url", "stderr", "SendInvalidPasswordError", "SendNeedsPasswordError", "errorMessage", "savePath", "callName", "status", "lastSavedStatus", "PremiumFeatureError", "action", "listener", "listeners", "import_api", "import_jsx_runtime", "LoadingFallback", "import_api", "import_api", "import_react", "VaultItemContext", "import_api", "import_api", "import_jsx_runtime", "import_api", "import_react", "import_api", "import_react", "isObject", "obj", "treatError", "error", "options", "execaError", "errorString", "isObject", "omitSensitiveValueFromString", "value", "sensitiveValue", "import_api", "import_react", "useVaultMessages", "bitwarden", "useBitwarden", "vaultState", "setVaultState", "error", "result", "shouldShowServer", "getServerUrlPreference", "userMessage", "serverMessage", "status", "userEmail", "serverUrl", "closeExtension", "useVaultMessages_default", "import_api", "has", "dequal", "foo", "bar", "ctor", "len", "$a57ed8effbd797c7$export$722debc0e56fea39", "value", "ref", "$hgUW1$useRef", "signalRef", "dequal", "$hgUW1$useMemo", "$bfcf6ee368b3bd9f$export$d4b699e2c1148419", "$c718fd03aba6111c$export$80e5033e369189f3", "error", "options", "message", "$hgUW1$showToast", "$hgUW1$Toast", "$c718fd03aba6111c$var$handleErrorToastAction", "privateExtension", "title", "extensionURL", "packageJSON", "$hgUW1$readFileSync", "$hgUW1$join", "$hgUW1$environment", "fallback", "stack", "toast", "$hgUW1$Clipboard", "$hgUW1$open", "$cefc05764ce5eacd$export$dd6b79aaabe7bc37", "fn", "args", "lastCallId", "state", "set", "$hgUW1$useState", "fnRef", "latestAbortable", "latestArgs", "latestOnError", "latestOnData", "latestOnWillExecute", "latestFailureToast", "latestValue", "latestCallback", "paginationArgsRef", "usePaginationRef", "hasMoreRef", "pageSizeRef", "abort", "$hgUW1$useCallback", "callback", "callId", "prevState", "promiseOrPaginatedPromise", "$cefc05764ce5eacd$var$bindPromiseIfNeeded", "handleError", "$hgUW1$LaunchType", "data", "hasMore", "cursor", "previousData", "revalidate", "mutate", "asyncUpdate", "dataBeforeOptimisticUpdate", "update", "err", "onLoadMore", "$hgUW1$useEffect", "isLoading", "stateWithLoadingFixed", "pagination", "$79498421851e7e84$export$cd58ffd7e3880e66", "FormValidation", "$79498421851e7e84$var$validationError", "validation", "value", "valueIsValid", "$79498421851e7e84$export$87c0cf8eb5a167e0", "props", "_onSubmit", "initialValues", "values", "setValues", "$hgUW1$useState", "errors", "setErrors", "refs", "$hgUW1$useRef", "latestValidation", "$bfcf6ee368b3bd9f$export$d4b699e2c1148419", "latestOnSubmit", "focus", "$hgUW1$useCallback", "id", "handleSubmit", "validationErrors", "error", "result", "setValidationError", "setValue", "itemProps", "$hgUW1$useMemo", "target", "event", "instance", "reset", "ref", "useLocalStorageItem", "key", "defaultValue", "value", "revalidate", "isLoading", "$cefc05764ce5eacd$export$dd6b79aaabe7bc37", "import_jsx_runtime", "UnlockForm", "pendingAction", "bitwarden", "useBitwarden", "userMessage", "serverMessage", "shouldShowServer", "useVaultMessages_default", "isLoading", "setLoading", "unlockError", "setUnlockError", "showPassword", "setShowPassword", "password", "setPassword", "lockReason", "clearLockReason", "useLocalStorageItem", "LOCAL_STORAGE_KEY", "onSubmit", "toast", "error", "vaultState", "displayableError", "treatedError", "getUsefulError", "captureException", "copyUnlockError", "PasswordField", "passwordFieldId", "prev", "DebuggingBugReportingActionSection", "field", "platform", "TimeoutInfoDescription", "vaultTimeoutMs", "timeoutLabel", "getLabelForTimeoutPreference", "treatError", "UnlockForm_default", "import_api", "import_jsx_runtime", "VaultLoadingFallback", "import_react", "initialState", "useSessionReducer", "state", "action", "_", "actionPayload", "hasToken", "import_api", "import_child_process", "import_util", "exec", "callbackExec", "SessionStorage", "LOCAL_STORAGE_KEY", "token", "passwordHash", "checkSystemLockedSinceLastAccess", "lastActivityTime", "checkSystemLogTimeAfter", "time", "getLastSyslog", "checkSystemSleptSinceLastAccess", "hours", "filter", "getLogEntry", "lastScreenLockTime", "getSystemLogTime", "getSystemLogTime_INCREMENT_HOURS", "getSystemLogTime_MAX_RETRIES", "timeSpanHours", "retryAttempt", "debugLog", "stdout", "stderr", "logDate", "logTime", "logFullDate", "error", "captureException", "import_react", "useOnceEffect", "effect", "condition", "hasRun", "useOnceEffect_default", "import_jsx_runtime", "SessionContext", "SessionProvider", "props", "children", "loadingFallback", "VaultLoadingFallback", "unlock", "bitwarden", "useBitwarden", "state", "dispatch", "useSessionReducer", "pendingActionRef", "useOnceEffect_default", "bootstrapSession", "handleLock", "handleUnlock", "handleLogout", "token", "passwordHash", "lastActivityTimeString", "lastVaultStatus", "SessionStorage", "LockVaultError", "LogoutVaultError", "VAULT_LOCK_MESSAGES", "lastActivityTime", "vaultTimeoutMs", "platform", "VAULT_TIMEOUT", "checkSystemLockedSinceLastAccess", "checkSystemSleptSinceLastAccess", "timeElapseSinceLastActivity", "error", "captureException", "password", "hashMasterPasswordForReprompting", "LOCAL_STORAGE_KEY", "reason", "Cache", "confirmMasterPassword", "contextValue", "showUnlockForm", "_children", "UnlockForm_default", "LockVaultError", "lockReason", "LogoutVaultError", "import_jsx_runtime", "import_jsx_runtime", "import_api", "import_child_process", "import_util", "import_fs", "import_path", "import_jsx_runtime", "exec", "execWithCallbacks", "supportPath", "getSafePreferences", "clientId", "clientSecret", "fetchFavicons", "generatePasswordQuickAction", "repromptIgnoreDuration", "serverCertsPath", "serverUrl", "shouldCacheVaultItems", "transientCopyGeneratePassword", "transientCopyGeneratePasswordQuick", "transientCopySearch", "windowActionOnCopy", "NA", "tryExec", "command", "trimLineBreaks", "cmd", "platform", "stdout", "response", "error", "captureException", "getBwBinInfo", "cliPathPref", "cliInfo", "getHomebrewInfo", "path", "config", "archValue", "version", "BugReportCollectDataAction", "collectData", "toast", "preferences", "bwInfo", "systemArch", "osVersion", "osBuildVersion", "bwVersion", "data", "brewInfo", "BugReportCollectDataAction_default", "import_api", "import_jsx_runtime", "BUG_REPORT_URL", "BugReportOpenAction", "BugReportOpenAction_default", "import_api", "import_jsx_runtime", "CopyRuntimeErrorLog", "errorString", "capturedExceptions", "CopyRuntimeErrorLog_default", "import_api", "import_react", "getCliVersion", "version", "Cache", "CACHE_KEYS", "useCliVersion", "setVersion", "useOnceEffect_default", "key", "value", "import_jsx_runtime", "DebuggingBugReportingActionSection", "cliVersion", "useCliVersion", "CopyRuntimeErrorLog_default", "BugReportOpenAction_default", "BugReportCollectDataAction_default", "import_api", "import_api", "import_react", "import_react", "import_jsx_runtime", "VaultListenersContext", "import_api", "import_api", "import_react", "import_jsx_runtime", "VaultContext", "syncOnLaunch", "import_jsx_runtime", "import_jsx_runtime", "LINE_BREAK", "CLI_INSTALLATION_HELP_URL", "getCodeBlock", "content", "TroubleshootingGuide", "error", "errorString", "getErrorString", "localCliPath", "isCliDownloadError", "EnsureCliBinError", "needsToInstallCli", "InstalledCLINotFoundError", "messages", "cliPathString", "BUG_REPORT_URL", "isArchError", "platform", "BugReportOpenAction_default", "BugReportCollectDataAction_default", "TroubleshootingGuide_default", "import_jsx_runtime", "BitwardenContext", "BitwardenProvider", "children", "loadingFallback", "LoadingFallback", "bitwarden", "setBitwarden", "error", "setError", "useOnceEffect_default", "Bitwarden", "handleBwInitError", "InstalledCLINotFoundError", "TroubleshootingGuide_default", "useBitwarden", "context", "import_api", "import_react", "import_jsx_runtime", "RootErrorBoundary", "props", "error", "errorInfo", "ManuallyThrownError", "state", "TroubleshootingGuide_default", "import_jsx_runtime", "CreateFolderCommand", "RootErrorBoundary", "BitwardenProvider", "SessionProvider", "CreateFolderComponent", "bitwarden", "useBitwarden", "handleSubmit", "itemProps", "$79498421851e7e84$export$87c0cf8eb5a167e0", "formData", "toast", "error", "$79498421851e7e84$export$cd58ffd7e3880e66", "DebuggingBugReportingActionSection", "create_folder_default"]
}
